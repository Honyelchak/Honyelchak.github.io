<!doctype html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.0" />
    <meta name="theme" content="VuePress Theme Hope 2.0.0-rc.1" />
    <style>
      html {
        background: var(--bg-color, #fff);
      }

      html[data-theme="dark"] {
        background: var(--bg-color, #1d1e1f);
      }

      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <meta property="og:url" content="https://yuejinzhao.cn/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html"><meta property="og:site_name" content="Honyelchak's Blog"><meta property="og:title" content="一、基础知识"><meta property="og:description" content="一、基础知识 操作系统层面 IO读写的基础原理 为了避免用户进程直接操作内核， 保证内核安全， 操作系统将内存（虚拟内存） 划分为两部分， 一部分是内核空间（Kernel-Space） ， 一部分是用户空间（User-Space） 。 在 Linux系统中， 内核模块运行在内核空间， 对应的进程处于内核态； 而用户程序运行在用户空间，对应的进程处于用户态。 操作系统的核心是内核， 独立于普通的应用程序， 可以访问受保护的内核空间， 也有访问底层硬件设备的权限。 内核空间总是驻留在内存中， 它是为操作系统的内核保留的。 应用程序是不允许直接在内核空间区域进行读写， 也是不容许直接调用内核代码定义的函数的。每个应用程序进程都有一个单独的用户空间， 对应的进程处于用户态， 用户态进程不能访问内核空间中的数据， 也不能直接调用内核函数的，因此要进行系统调用的时候， 就要将进程切换到内核态才能进行。"><meta property="og:type" content="article"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2023-12-02T06:45:03.000Z"><meta property="article:author" content="Honyelchak"><meta property="article:modified_time" content="2023-12-02T06:45:03.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"一、基础知识","image":[""],"dateModified":"2023-12-02T06:45:03.000Z","author":[{"@type":"Person","name":"Honyelchak","url":"https://yuejinzhao.cn"}]}</script><title>一、基础知识 | Honyelchak's Blog</title><meta name="description" content="一、基础知识 操作系统层面 IO读写的基础原理 为了避免用户进程直接操作内核， 保证内核安全， 操作系统将内存（虚拟内存） 划分为两部分， 一部分是内核空间（Kernel-Space） ， 一部分是用户空间（User-Space） 。 在 Linux系统中， 内核模块运行在内核空间， 对应的进程处于内核态； 而用户程序运行在用户空间，对应的进程处于用户态。 操作系统的核心是内核， 独立于普通的应用程序， 可以访问受保护的内核空间， 也有访问底层硬件设备的权限。 内核空间总是驻留在内存中， 它是为操作系统的内核保留的。 应用程序是不允许直接在内核空间区域进行读写， 也是不容许直接调用内核代码定义的函数的。每个应用程序进程都有一个单独的用户空间， 对应的进程处于用户态， 用户态进程不能访问内核空间中的数据， 也不能直接调用内核函数的，因此要进行系统调用的时候， 就要将进程切换到内核态才能进行。">
    <link rel="preload" href="/assets/style-s-J8-r2b.css" as="style"><link rel="stylesheet" href="/assets/style-s-J8-r2b.css">
    <link rel="modulepreload" href="/assets/app-_dQeDwys.js"><link rel="modulepreload" href="/assets/Netty.html-aexxJpU6.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper-x3n3nnut.js"><link rel="modulepreload" href="/assets/Netty.html-4dzw_auG.js">
    <link rel="prefetch" href="/assets/index.html-TJyD3cLk.js" as="script"><link rel="prefetch" href="/assets/intro.html-1OPW3V7h.js" as="script"><link rel="prefetch" href="/assets/project.html-1c2u4iC9.js" as="script"><link rel="prefetch" href="/assets/slides.html-lVESjsnf.js" as="script"><link rel="prefetch" href="/assets/cherry.html-nS81mElm.js" as="script"><link rel="prefetch" href="/assets/index.html-4H3YBJgo.js" as="script"><link rel="prefetch" href="/assets/disable.html-dU7RYcGn.js" as="script"><link rel="prefetch" href="/assets/encrypt.html-khbb8xwB.js" as="script"><link rel="prefetch" href="/assets/markdown.html-Yx5_DxvR.js" as="script"><link rel="prefetch" href="/assets/page.html-OnIm-J2S.js" as="script"><link rel="prefetch" href="/assets/Git.html-oNpdMzPA.js" as="script"><link rel="prefetch" href="/assets/JavaWeb.html-oc6THKuy.js" as="script"><link rel="prefetch" href="/assets/Java复习汇总.html-FEkRgJDv.js" as="script"><link rel="prefetch" href="/assets/LeetCode.html-wZBUP_Cp.js" as="script"><link rel="prefetch" href="/assets/Mybatis.html-rQMkYXsT.js" as="script"><link rel="prefetch" href="/assets/Netty.html-UvLeulHs.js" as="script"><link rel="prefetch" href="/assets/Untitled.html-wpkW5Hz-.js" as="script"><link rel="prefetch" href="/assets/个人剖析.html-Qux-C6vI.js" as="script"><link rel="prefetch" href="/assets/奇奇怪怪的问题.html-R2AxlnQN.js" as="script"><link rel="prefetch" href="/assets/数据结构.html-AaLXwRzK.js" as="script"><link rel="prefetch" href="/assets/斗智斗勇.html-jr6x8I8D.js" as="script"><link rel="prefetch" href="/assets/简历埋点.html-IhryRitK.js" as="script"><link rel="prefetch" href="/assets/dragonfruit.html-REUIcmkv.js" as="script"><link rel="prefetch" href="/assets/strawberry.html-13YPqcHt.js" as="script"><link rel="prefetch" href="/assets/tomato.html-NhdZoPTn.js" as="script"><link rel="prefetch" href="/assets/前缀和题单.html-R6MndNAg.js" as="script"><link rel="prefetch" href="/assets/原则.html-JA6wxwpp.js" as="script"><link rel="prefetch" href="/assets/小知识点.html-fagpbEUh.js" as="script"><link rel="prefetch" href="/assets/由数据范围反推算法复杂度以及算法内容.html-xpUkKYl-.js" as="script"><link rel="prefetch" href="/assets/面试常考算法模板.html-i0XZjljp.js" as="script"><link rel="prefetch" href="/assets/DP.html-WiFxcle4.js" as="script"><link rel="prefetch" href="/assets/LIS.html-h-dqg6Hf.js" as="script"><link rel="prefetch" href="/assets/区间DP.html-xTd8Gfqw.js" as="script"><link rel="prefetch" href="/assets/数位DP.html-22nQiboi.js" as="script"><link rel="prefetch" href="/assets/数字三角形模型.html-Hd6I0qCy.js" as="script"><link rel="prefetch" href="/assets/斜率优化DP.html-lma1t9G6.js" as="script"><link rel="prefetch" href="/assets/树形DP.html-rHCeZz09.js" as="script"><link rel="prefetch" href="/assets/状态压缩DP.html-SLYf7WbL.js" as="script"><link rel="prefetch" href="/assets/状态机.html-LLzfw_7m.js" as="script"><link rel="prefetch" href="/assets/二分.html-QNEhReAH.js" as="script"><link rel="prefetch" href="/assets/位运算.html-2eHDuHWH.js" as="script"><link rel="prefetch" href="/assets/前缀和.html-6mcJEeIr.js" as="script"><link rel="prefetch" href="/assets/快速幂.html-EdHQND9b.js" as="script"><link rel="prefetch" href="/assets/离散化.html-SrTvrZlI.js" as="script"><link rel="prefetch" href="/assets/BFS.html-zULDF6Cv.js" as="script"><link rel="prefetch" href="/assets/DFS.html-Zyq1Alr7.js" as="script"><link rel="prefetch" href="/assets/单调栈.html-m2BDrvPz.js" as="script"><link rel="prefetch" href="/assets/并查集.html-XgWBTZ1x.js" as="script"><link rel="prefetch" href="/assets/树状数组.html-LDW52PBO.js" as="script"><link rel="prefetch" href="/assets/线段树.html-mWchzgBB.js" as="script"><link rel="prefetch" href="/assets/STL.html-ph9XXeW4.js" as="script"><link rel="prefetch" href="/assets/基础算法.html-Vih4xw3c.js" as="script"><link rel="prefetch" href="/assets/搜索与图论.html-qOdq5f8p.js" as="script"><link rel="prefetch" href="/assets/数据结构.html-KpibRNSM.js" as="script"><link rel="prefetch" href="/assets/贪心.html-1uHjL1bO.js" as="script"><link rel="prefetch" href="/assets/CPU.html-nRszTbKA.js" as="script"><link rel="prefetch" href="/assets/Linux常用命令及线上项目调优.html-xJNWFxx_.js" as="script"><link rel="prefetch" href="/assets/操作系统.html-j-jahRCL.js" as="script"><link rel="prefetch" href="/assets/IP.html-ooHZS7Ra.js" as="script"><link rel="prefetch" href="/assets/IP冲突.html-yrytBUBs.js" as="script"><link rel="prefetch" href="/assets/Netty.html-SbVYJtub.js" as="script"><link rel="prefetch" href="/assets/UDT和QUIC.html-zBnAWslA.js" as="script"><link rel="prefetch" href="/assets/网络问题.html-iokrm3Ka.js" as="script"><link rel="prefetch" href="/assets/计算机网络.html-51AKb3zX.js" as="script"><link rel="prefetch" href="/assets/MVCC多版本并发控制.html-6oHzKDEC.js" as="script"><link rel="prefetch" href="/assets/MySQL数据库性能优化.html-SWW1Elbi.js" as="script"><link rel="prefetch" href="/assets/MySQL相关指令.html-w15QIOSt.js" as="script"><link rel="prefetch" href="/assets/SQL.html-Men8iY6P.js" as="script"><link rel="prefetch" href="/assets/SQL优化.html-9YVl9_PD.js" as="script"><link rel="prefetch" href="/assets/mysql的加锁情况.html-lQuvXxK7.js" as="script"><link rel="prefetch" href="/assets/手撕SQL.html-I1oi0HDI.js" as="script"><link rel="prefetch" href="/assets/金三银四Mysql面试突击班.html-lXCakC7i.js" as="script"><link rel="prefetch" href="/assets/锁.html-iL1ZA_qB.js" as="script"><link rel="prefetch" href="/assets/IO.html-vaADi92u.js" as="script"><link rel="prefetch" href="/assets/Java8新特性.html-uXOwhN5b.js" as="script"><link rel="prefetch" href="/assets/Java基础.html-cd-t6WYR.js" as="script"><link rel="prefetch" href="/assets/Java疑难点.html-A39ZJ9uH.js" as="script"><link rel="prefetch" href="/assets/Java集合.html-yrDYFwRv.js" as="script"><link rel="prefetch" href="/assets/Streams.html-OlVuTBBp.js" as="script"><link rel="prefetch" href="/assets/查漏补缺.html-aQg5QtiM.js" as="script"><link rel="prefetch" href="/assets/SpringBoot.html-RfMG4wQo.js" as="script"><link rel="prefetch" href="/assets/SpringBoot配置文件.html-gblPkDkU.js" as="script"><link rel="prefetch" href="/assets/SpringMVC.html-edpw_Lqq.js" as="script"><link rel="prefetch" href="/assets/Spring启动过程.html-Fb0gjLIE.js" as="script"><link rel="prefetch" href="/assets/Spring框架.html-iUnC64L5.js" as="script"><link rel="prefetch" href="/assets/Spring框架面试题.html-A-6vPun2.js" as="script"><link rel="prefetch" href="/assets/Spring源码阅读.html-64253mtH.js" as="script"><link rel="prefetch" href="/assets/Spring面试题(1).html-XSPzLdxS.js" as="script"><link rel="prefetch" href="/assets/Spring面试题.html-gPZhge76.js" as="script"><link rel="prefetch" href="/assets/奇奇怪怪的Spring问题.html-UijzzvQ2.js" as="script"><link rel="prefetch" href="/assets/循坏依赖专题.html-s9pUwxWS.js" as="script"><link rel="prefetch" href="/assets/手写一个Spring框架.html-LGw0GIVU.js" as="script"><link rel="prefetch" href="/assets/设计模式专题.html-AXq-b0LV.js" as="script"><link rel="prefetch" href="/assets/12306项目分析.html-29vrC0KF.js" as="script"><link rel="prefetch" href="/assets/12306项目查漏补缺.html-nIqK_YML.js" as="script"><link rel="prefetch" href="/assets/QPS20W接口测试.html-qgDvHIgZ.js" as="script"><link rel="prefetch" href="/assets/分布式雪花算法.html-2QXODQGV.js" as="script"><link rel="prefetch" href="/assets/单机20W并发的接口设计.html-zgC7QT4Y.js" as="script"><link rel="prefetch" href="/assets/项目相关.html-gsRLX_K0.js" as="script"><link rel="prefetch" href="/assets/基本理论.html-hG_H3x4V.js" as="script"><link rel="prefetch" href="/assets/nginx.html-MAoy_qLU.js" as="script"><link rel="prefetch" href="/assets/消息队列.html-fVGKtE-R.js" as="script"><link rel="prefetch" href="/assets/2019常见面试题.html-8XyYraer.js" as="script"><link rel="prefetch" href="/assets/Java面试题(答案).html-v1wiLhXn.js" as="script"><link rel="prefetch" href="/assets/Java面试题.html-uBWc-U87.js" as="script"><link rel="prefetch" href="/assets/面试常问的问题.html-1uWz3eOz.js" as="script"><link rel="prefetch" href="/assets/网络.html--mrgvBP1.js" as="script"><link rel="prefetch" href="/assets/测试安全问题.html-8OCb_kvc.js" as="script"><link rel="prefetch" href="/assets/RISC-V.html-5Cl8EY3X.js" as="script"><link rel="prefetch" href="/assets/秒杀.html-8mH6jTUa.js" as="script"><link rel="prefetch" href="/assets/1.html-l7LwHYr5.js" as="script"><link rel="prefetch" href="/assets/2.html-iDGX3PdD.js" as="script"><link rel="prefetch" href="/assets/3.html-xxZpy1PR.js" as="script"><link rel="prefetch" href="/assets/4.html-KVfWHQvA.js" as="script"><link rel="prefetch" href="/assets/1.html-2P9V0Zzm.js" as="script"><link rel="prefetch" href="/assets/2.html-zjevKTJb.js" as="script"><link rel="prefetch" href="/assets/3.html-KmAMgI8v.js" as="script"><link rel="prefetch" href="/assets/4.html-dKO_Yw-C.js" as="script"><link rel="prefetch" href="/assets/Floyd.html-18LX8b2q.js" as="script"><link rel="prefetch" href="/assets/综述.html-HIG0Tx1T.js" as="script"><link rel="prefetch" href="/assets/基本理论.html-UC_YVBxj.js" as="script"><link rel="prefetch" href="/assets/次小生成树.html-xXEOF_Je.js" as="script"><link rel="prefetch" href="/assets/网络.html-MIXrv6fO.js" as="script"><link rel="prefetch" href="/assets/Redis.html-jY6OUvTt.js" as="script"><link rel="prefetch" href="/assets/Redis削峰.html-hcDk-sZ4.js" as="script"><link rel="prefetch" href="/assets/redis配置文件.html-awJcFh1H.js" as="script"><link rel="prefetch" href="/assets/缓存和数据库双写一致性.html-ftB7L-E1.js" as="script"><link rel="prefetch" href="/assets/缓存更新策略.html-Ws8dPBI1.js" as="script"><link rel="prefetch" href="/assets/ReentrantLock中的lockInterruptibly和lock.html-8jVpnec5.js" as="script"><link rel="prefetch" href="/assets/多线程题目.html-LA_QYezZ.js" as="script"><link rel="prefetch" href="/assets/多线程高并发笔记.html-Irdva4SV.js" as="script"><link rel="prefetch" href="/assets/并发.html-_Un2zYtv.js" as="script"><link rel="prefetch" href="/assets/线程池.html-uyUy7hhG.js" as="script"><link rel="prefetch" href="/assets/JVM.html-CYW6uuHo.js" as="script"><link rel="prefetch" href="/assets/JVM上.html-icNsX-58.js" as="script"><link rel="prefetch" href="/assets/JVM下.html-KjBqO_ew.js" as="script"><link rel="prefetch" href="/assets/JVM中.html-dmvqAVCm.js" as="script"><link rel="prefetch" href="/assets/JVM面试 (copy).html-n1-HiW0B.js" as="script"><link rel="prefetch" href="/assets/JVM面试.html-sxIWVtxC.js" as="script"><link rel="prefetch" href="/assets/404.html-tlyei_5h.js" as="script"><link rel="prefetch" href="/assets/index.html-5JTjs8mG.js" as="script"><link rel="prefetch" href="/assets/index.html--YxBfJSp.js" as="script"><link rel="prefetch" href="/assets/index.html-71JEMejL.js" as="script"><link rel="prefetch" href="/assets/index.html-ITzakDtH.js" as="script"><link rel="prefetch" href="/assets/index.html-fjktaOAH.js" as="script"><link rel="prefetch" href="/assets/index.html-ysR9goIb.js" as="script"><link rel="prefetch" href="/assets/index.html-DJ7Ym7Iq.js" as="script"><link rel="prefetch" href="/assets/index.html-tyJNw07b.js" as="script"><link rel="prefetch" href="/assets/index.html-d7UHyMoy.js" as="script"><link rel="prefetch" href="/assets/index.html-tBkkuQ9X.js" as="script"><link rel="prefetch" href="/assets/index.html-oYedy5bF.js" as="script"><link rel="prefetch" href="/assets/index.html-WqtN1zQQ.js" as="script"><link rel="prefetch" href="/assets/index.html-o-IVSgtO.js" as="script"><link rel="prefetch" href="/assets/index.html-1E9AP5fk.js" as="script"><link rel="prefetch" href="/assets/index.html-me3FmHfA.js" as="script"><link rel="prefetch" href="/assets/index.html-nZyBrfgS.js" as="script"><link rel="prefetch" href="/assets/index.html-Ca2m7Cu4.js" as="script"><link rel="prefetch" href="/assets/index.html-gjy07egy.js" as="script"><link rel="prefetch" href="/assets/index.html-pMhppvm1.js" as="script"><link rel="prefetch" href="/assets/index.html-a4Ze5x_t.js" as="script"><link rel="prefetch" href="/assets/index.html-TAN0vn8L.js" as="script"><link rel="prefetch" href="/assets/index.html-nGmkbY1x.js" as="script"><link rel="prefetch" href="/assets/index.html-312PX0oj.js" as="script"><link rel="prefetch" href="/assets/index.html-ObEgcdx_.js" as="script"><link rel="prefetch" href="/assets/index.html-DcRl1Zu4.js" as="script"><link rel="prefetch" href="/assets/index.html-RYgsJuRz.js" as="script"><link rel="prefetch" href="/assets/index.html-0hP2H4N-.js" as="script"><link rel="prefetch" href="/assets/index.html-jSgb6ZKH.js" as="script"><link rel="prefetch" href="/assets/index.html-mP0vS9o6.js" as="script"><link rel="prefetch" href="/assets/index.html-9U3Hmi6I.js" as="script"><link rel="prefetch" href="/assets/index.html-Lx5ri6mA.js" as="script"><link rel="prefetch" href="/assets/index.html-V0HSX5Sw.js" as="script"><link rel="prefetch" href="/assets/index.html--RD3L-9a.js" as="script"><link rel="prefetch" href="/assets/index.html-TLF0Maaf.js" as="script"><link rel="prefetch" href="/assets/index.html-7B1umk9D.js" as="script"><link rel="prefetch" href="/assets/index.html-LDS5hg0b.js" as="script"><link rel="prefetch" href="/assets/index.html-03f83TYL.js" as="script"><link rel="prefetch" href="/assets/index.html-Vm7CMeJ9.js" as="script"><link rel="prefetch" href="/assets/index.html-PxwaX4D5.js" as="script"><link rel="prefetch" href="/assets/index.html-GD-sGv9o.js" as="script"><link rel="prefetch" href="/assets/index.html-7fHiBdve.js" as="script"><link rel="prefetch" href="/assets/index.html-uaVWCPeu.js" as="script"><link rel="prefetch" href="/assets/index.html-9Qhj3LDt.js" as="script"><link rel="prefetch" href="/assets/index.html-1pEV0-DQ.js" as="script"><link rel="prefetch" href="/assets/index.html-HG-dF-LV.js" as="script"><link rel="prefetch" href="/assets/index.html-Awfi2Oy0.js" as="script"><link rel="prefetch" href="/assets/index.html-kjfsO1qY.js" as="script"><link rel="prefetch" href="/assets/index.html-m-ubR1oj.js" as="script"><link rel="prefetch" href="/assets/index.html-zti7c-jn.js" as="script"><link rel="prefetch" href="/assets/index.html-yLAg9VY_.js" as="script"><link rel="prefetch" href="/assets/index.html-FUeLVl_L.js" as="script"><link rel="prefetch" href="/assets/index.html-OqUPM_6t.js" as="script"><link rel="prefetch" href="/assets/index.html-FvD6AmyZ.js" as="script"><link rel="prefetch" href="/assets/index.html-IzKBN8uZ.js" as="script"><link rel="prefetch" href="/assets/index.html-hx-a2twd.js" as="script"><link rel="prefetch" href="/assets/index.html-BQhJTnsp.js" as="script"><link rel="prefetch" href="/assets/index.html-4T1nTBMu.js" as="script"><link rel="prefetch" href="/assets/index.html-j1p3xwFm.js" as="script"><link rel="prefetch" href="/assets/intro.html-CrFd_OkX.js" as="script"><link rel="prefetch" href="/assets/project.html-PxmS83I7.js" as="script"><link rel="prefetch" href="/assets/slides.html-foxsdEPI.js" as="script"><link rel="prefetch" href="/assets/cherry.html-69QbF_X2.js" as="script"><link rel="prefetch" href="/assets/index.html-rHITYQO6.js" as="script"><link rel="prefetch" href="/assets/disable.html-5UHP5c6M.js" as="script"><link rel="prefetch" href="/assets/encrypt.html-PQdbK8nw.js" as="script"><link rel="prefetch" href="/assets/markdown.html-WTzrSQQF.js" as="script"><link rel="prefetch" href="/assets/page.html-Tvns-x-U.js" as="script"><link rel="prefetch" href="/assets/Git.html-_IRUUxIU.js" as="script"><link rel="prefetch" href="/assets/JavaWeb.html-e3NGPneM.js" as="script"><link rel="prefetch" href="/assets/Java复习汇总.html-dg6jwjVv.js" as="script"><link rel="prefetch" href="/assets/LeetCode.html-U93QfIFK.js" as="script"><link rel="prefetch" href="/assets/Mybatis.html-uJrkWgfj.js" as="script"><link rel="prefetch" href="/assets/Netty.html-MWIwbuk_.js" as="script"><link rel="prefetch" href="/assets/Untitled.html-qH2pTOfa.js" as="script"><link rel="prefetch" href="/assets/个人剖析.html-DPTBZ98C.js" as="script"><link rel="prefetch" href="/assets/奇奇怪怪的问题.html-V8rVhf4T.js" as="script"><link rel="prefetch" href="/assets/数据结构.html-jc5Gky_u.js" as="script"><link rel="prefetch" href="/assets/斗智斗勇.html-38k6LtCy.js" as="script"><link rel="prefetch" href="/assets/简历埋点.html-Xgp4Nztj.js" as="script"><link rel="prefetch" href="/assets/dragonfruit.html-beGhF_B3.js" as="script"><link rel="prefetch" href="/assets/strawberry.html-7IHsIBcj.js" as="script"><link rel="prefetch" href="/assets/tomato.html-CG7gZS24.js" as="script"><link rel="prefetch" href="/assets/前缀和题单.html-IZgNq2rC.js" as="script"><link rel="prefetch" href="/assets/原则.html-GcTwBchL.js" as="script"><link rel="prefetch" href="/assets/小知识点.html-qDsWzWs8.js" as="script"><link rel="prefetch" href="/assets/由数据范围反推算法复杂度以及算法内容.html-KYYzpbxt.js" as="script"><link rel="prefetch" href="/assets/面试常考算法模板.html-vA5BqgpZ.js" as="script"><link rel="prefetch" href="/assets/DP.html-HMgJceNr.js" as="script"><link rel="prefetch" href="/assets/LIS.html-AwsbRk8t.js" as="script"><link rel="prefetch" href="/assets/区间DP.html-u6KUZPML.js" as="script"><link rel="prefetch" href="/assets/数位DP.html-PwXKaxg1.js" as="script"><link rel="prefetch" href="/assets/数字三角形模型.html-qCQQrYf9.js" as="script"><link rel="prefetch" href="/assets/斜率优化DP.html-a1RafgH-.js" as="script"><link rel="prefetch" href="/assets/树形DP.html-UchQcJSI.js" as="script"><link rel="prefetch" href="/assets/状态压缩DP.html-TADWIv_s.js" as="script"><link rel="prefetch" href="/assets/状态机.html-ikXMnM_D.js" as="script"><link rel="prefetch" href="/assets/二分.html-MlL0ty7i.js" as="script"><link rel="prefetch" href="/assets/位运算.html-Q9u5_Vge.js" as="script"><link rel="prefetch" href="/assets/前缀和.html-6ULMGduI.js" as="script"><link rel="prefetch" href="/assets/快速幂.html-8xjtKNiT.js" as="script"><link rel="prefetch" href="/assets/离散化.html-T1nabbq_.js" as="script"><link rel="prefetch" href="/assets/BFS.html-NgT46bQa.js" as="script"><link rel="prefetch" href="/assets/DFS.html-sNK-Ey73.js" as="script"><link rel="prefetch" href="/assets/单调栈.html-zSOFxjb0.js" as="script"><link rel="prefetch" href="/assets/并查集.html-prZwbIQp.js" as="script"><link rel="prefetch" href="/assets/树状数组.html-i4uikXEc.js" as="script"><link rel="prefetch" href="/assets/线段树.html-H0mWmyOf.js" as="script"><link rel="prefetch" href="/assets/STL.html-cL7cVbPU.js" as="script"><link rel="prefetch" href="/assets/基础算法.html-2Da1qLAP.js" as="script"><link rel="prefetch" href="/assets/搜索与图论.html-ZBkaoFI7.js" as="script"><link rel="prefetch" href="/assets/数据结构.html-ymUTaIQJ.js" as="script"><link rel="prefetch" href="/assets/贪心.html-deT6FEOU.js" as="script"><link rel="prefetch" href="/assets/CPU.html-RyFQgprw.js" as="script"><link rel="prefetch" href="/assets/Linux常用命令及线上项目调优.html-tPnFLaLm.js" as="script"><link rel="prefetch" href="/assets/操作系统.html-_BPZUfrf.js" as="script"><link rel="prefetch" href="/assets/IP.html-2v2E_bzD.js" as="script"><link rel="prefetch" href="/assets/IP冲突.html-GV32IREe.js" as="script"><link rel="prefetch" href="/assets/Netty.html-J7QkovFO.js" as="script"><link rel="prefetch" href="/assets/UDT和QUIC.html-HDtOoSjO.js" as="script"><link rel="prefetch" href="/assets/网络问题.html-ilmzGnBL.js" as="script"><link rel="prefetch" href="/assets/计算机网络.html-DcQUj-mn.js" as="script"><link rel="prefetch" href="/assets/MVCC多版本并发控制.html-bHjwhWko.js" as="script"><link rel="prefetch" href="/assets/MySQL数据库性能优化.html-PNAW7UfT.js" as="script"><link rel="prefetch" href="/assets/MySQL相关指令.html-IbpeGyab.js" as="script"><link rel="prefetch" href="/assets/SQL.html-8ZLvTbIV.js" as="script"><link rel="prefetch" href="/assets/SQL优化.html-Tc60Z2KH.js" as="script"><link rel="prefetch" href="/assets/mysql的加锁情况.html-XJB9jHAJ.js" as="script"><link rel="prefetch" href="/assets/手撕SQL.html-tFQlSdlY.js" as="script"><link rel="prefetch" href="/assets/金三银四Mysql面试突击班.html-5Pke0g7v.js" as="script"><link rel="prefetch" href="/assets/锁.html-JJISi0zY.js" as="script"><link rel="prefetch" href="/assets/IO.html-5wGVTsEd.js" as="script"><link rel="prefetch" href="/assets/Java8新特性.html-uCQAfmVe.js" as="script"><link rel="prefetch" href="/assets/Java基础.html-KkIPpvSi.js" as="script"><link rel="prefetch" href="/assets/Java疑难点.html-jao7Q06V.js" as="script"><link rel="prefetch" href="/assets/Java集合.html-oWdTraws.js" as="script"><link rel="prefetch" href="/assets/Streams.html-qwviTMKA.js" as="script"><link rel="prefetch" href="/assets/查漏补缺.html-Tzv_yLM_.js" as="script"><link rel="prefetch" href="/assets/SpringBoot.html-RKoCVXfb.js" as="script"><link rel="prefetch" href="/assets/SpringBoot配置文件.html-bBydVLOD.js" as="script"><link rel="prefetch" href="/assets/SpringMVC.html-mqIf9uaH.js" as="script"><link rel="prefetch" href="/assets/Spring启动过程.html-7PyxpbbR.js" as="script"><link rel="prefetch" href="/assets/Spring框架.html-FaJo75jH.js" as="script"><link rel="prefetch" href="/assets/Spring框架面试题.html-_1UBB7m5.js" as="script"><link rel="prefetch" href="/assets/Spring源码阅读.html-5VaTozO0.js" as="script"><link rel="prefetch" href="/assets/Spring面试题(1).html-0yewJnNa.js" as="script"><link rel="prefetch" href="/assets/Spring面试题.html-3uhVdxqQ.js" as="script"><link rel="prefetch" href="/assets/奇奇怪怪的Spring问题.html-BBtunO5H.js" as="script"><link rel="prefetch" href="/assets/循坏依赖专题.html-IqJ7C5oe.js" as="script"><link rel="prefetch" href="/assets/手写一个Spring框架.html-4I9P32q0.js" as="script"><link rel="prefetch" href="/assets/设计模式专题.html-Al4S02v2.js" as="script"><link rel="prefetch" href="/assets/12306项目分析.html-RAgFuytj.js" as="script"><link rel="prefetch" href="/assets/12306项目查漏补缺.html-5yfLAC9u.js" as="script"><link rel="prefetch" href="/assets/QPS20W接口测试.html-EIVqGUhR.js" as="script"><link rel="prefetch" href="/assets/分布式雪花算法.html-K9Eyz9qS.js" as="script"><link rel="prefetch" href="/assets/单机20W并发的接口设计.html-h-OdwGR1.js" as="script"><link rel="prefetch" href="/assets/项目相关.html-_IzamkhF.js" as="script"><link rel="prefetch" href="/assets/基本理论.html-vmS7SL6u.js" as="script"><link rel="prefetch" href="/assets/nginx.html-l71ey52r.js" as="script"><link rel="prefetch" href="/assets/消息队列.html-f9hLe4IL.js" as="script"><link rel="prefetch" href="/assets/2019常见面试题.html-yKmaUpx2.js" as="script"><link rel="prefetch" href="/assets/Java面试题(答案).html-5IochmPC.js" as="script"><link rel="prefetch" href="/assets/Java面试题.html-NGaZnRlX.js" as="script"><link rel="prefetch" href="/assets/面试常问的问题.html-u31RLHXt.js" as="script"><link rel="prefetch" href="/assets/网络.html-8D1RiJ1M.js" as="script"><link rel="prefetch" href="/assets/测试安全问题.html-pf-724Y0.js" as="script"><link rel="prefetch" href="/assets/RISC-V.html-kXlQz7PJ.js" as="script"><link rel="prefetch" href="/assets/秒杀.html-l_vj0GYQ.js" as="script"><link rel="prefetch" href="/assets/1.html-SC5D4HMm.js" as="script"><link rel="prefetch" href="/assets/2.html-xokqY9JS.js" as="script"><link rel="prefetch" href="/assets/3.html-63tT5sWY.js" as="script"><link rel="prefetch" href="/assets/4.html-uVfNHt85.js" as="script"><link rel="prefetch" href="/assets/1.html-4OJRlIqR.js" as="script"><link rel="prefetch" href="/assets/2.html-kgms37SS.js" as="script"><link rel="prefetch" href="/assets/3.html-RfRnp7WV.js" as="script"><link rel="prefetch" href="/assets/4.html-_Lr9o4OG.js" as="script"><link rel="prefetch" href="/assets/Floyd.html-XMaZ3aiT.js" as="script"><link rel="prefetch" href="/assets/综述.html-NQPrRx2b.js" as="script"><link rel="prefetch" href="/assets/基本理论.html-uNElyDu8.js" as="script"><link rel="prefetch" href="/assets/次小生成树.html-EIlPRK75.js" as="script"><link rel="prefetch" href="/assets/网络.html-7cZdNpiQ.js" as="script"><link rel="prefetch" href="/assets/Redis.html-JbQ9AYw5.js" as="script"><link rel="prefetch" href="/assets/Redis削峰.html-OznxY4mS.js" as="script"><link rel="prefetch" href="/assets/redis配置文件.html-hDrpVKYX.js" as="script"><link rel="prefetch" href="/assets/缓存和数据库双写一致性.html-CVX1XVEh.js" as="script"><link rel="prefetch" href="/assets/缓存更新策略.html-Rl25CQPe.js" as="script"><link rel="prefetch" href="/assets/ReentrantLock中的lockInterruptibly和lock.html-f8ZhTtNl.js" as="script"><link rel="prefetch" href="/assets/多线程题目.html-tSnTWS-L.js" as="script"><link rel="prefetch" href="/assets/多线程高并发笔记.html-JsChvawk.js" as="script"><link rel="prefetch" href="/assets/并发.html-Dctl45Z-.js" as="script"><link rel="prefetch" href="/assets/线程池.html-KT6KNP2e.js" as="script"><link rel="prefetch" href="/assets/JVM.html-VUZyPoKG.js" as="script"><link rel="prefetch" href="/assets/JVM上.html-oQMtVYRG.js" as="script"><link rel="prefetch" href="/assets/JVM下.html-_hKQrgr6.js" as="script"><link rel="prefetch" href="/assets/JVM中.html-YADHTrja.js" as="script"><link rel="prefetch" href="/assets/JVM面试 (copy).html-AoNTwFzm.js" as="script"><link rel="prefetch" href="/assets/JVM面试.html-gefUgiqF.js" as="script"><link rel="prefetch" href="/assets/404.html-r5ZCmiM0.js" as="script"><link rel="prefetch" href="/assets/index.html-rCUKvMnN.js" as="script"><link rel="prefetch" href="/assets/index.html-N57fgIrH.js" as="script"><link rel="prefetch" href="/assets/index.html-a8XbNRNn.js" as="script"><link rel="prefetch" href="/assets/index.html-COlppnQk.js" as="script"><link rel="prefetch" href="/assets/index.html-pyRVdBTv.js" as="script"><link rel="prefetch" href="/assets/index.html-HOL3-gQ2.js" as="script"><link rel="prefetch" href="/assets/index.html-5RjGse8e.js" as="script"><link rel="prefetch" href="/assets/index.html-pzP15I8X.js" as="script"><link rel="prefetch" href="/assets/index.html-qXdun72T.js" as="script"><link rel="prefetch" href="/assets/index.html-0BN1kCla.js" as="script"><link rel="prefetch" href="/assets/index.html-YS3W3JZb.js" as="script"><link rel="prefetch" href="/assets/index.html-FXP2QW3w.js" as="script"><link rel="prefetch" href="/assets/index.html-YZ35KlwH.js" as="script"><link rel="prefetch" href="/assets/index.html-_9gs_jod.js" as="script"><link rel="prefetch" href="/assets/index.html-CZrgcu4u.js" as="script"><link rel="prefetch" href="/assets/index.html-YgouxP__.js" as="script"><link rel="prefetch" href="/assets/index.html-eBIoycM0.js" as="script"><link rel="prefetch" href="/assets/index.html-BiUJxVxu.js" as="script"><link rel="prefetch" href="/assets/index.html-EnZpQpUA.js" as="script"><link rel="prefetch" href="/assets/index.html--7D36E37.js" as="script"><link rel="prefetch" href="/assets/index.html-BcwO5X8n.js" as="script"><link rel="prefetch" href="/assets/index.html-5R0k2Ezv.js" as="script"><link rel="prefetch" href="/assets/index.html-Gvy_XkL7.js" as="script"><link rel="prefetch" href="/assets/index.html-74nCY1q_.js" as="script"><link rel="prefetch" href="/assets/index.html-pRNAqr0A.js" as="script"><link rel="prefetch" href="/assets/index.html-ZCqi0TXh.js" as="script"><link rel="prefetch" href="/assets/index.html-LV1REigO.js" as="script"><link rel="prefetch" href="/assets/index.html-tpBtlDjF.js" as="script"><link rel="prefetch" href="/assets/index.html-G0oyTrBa.js" as="script"><link rel="prefetch" href="/assets/index.html-QA4aMZDh.js" as="script"><link rel="prefetch" href="/assets/index.html-ODBpfQ_1.js" as="script"><link rel="prefetch" href="/assets/index.html-QnG2w8BB.js" as="script"><link rel="prefetch" href="/assets/index.html-Bq6eknPY.js" as="script"><link rel="prefetch" href="/assets/index.html-wg00LF7W.js" as="script"><link rel="prefetch" href="/assets/index.html-oYMnXBND.js" as="script"><link rel="prefetch" href="/assets/index.html-25ZDAwRm.js" as="script"><link rel="prefetch" href="/assets/index.html-0LvI7w65.js" as="script"><link rel="prefetch" href="/assets/index.html-tjNU7l4_.js" as="script"><link rel="prefetch" href="/assets/index.html-BWxhqCva.js" as="script"><link rel="prefetch" href="/assets/index.html-8gCl_xkT.js" as="script"><link rel="prefetch" href="/assets/index.html-AHoht34p.js" as="script"><link rel="prefetch" href="/assets/index.html-JWvCdv7f.js" as="script"><link rel="prefetch" href="/assets/index.html-7m-BTi2r.js" as="script"><link rel="prefetch" href="/assets/index.html-IRMUWs3j.js" as="script"><link rel="prefetch" href="/assets/index.html-A8YxbXPy.js" as="script"><link rel="prefetch" href="/assets/index.html-p6QAuL_c.js" as="script"><link rel="prefetch" href="/assets/index.html-BSpRSIQL.js" as="script"><link rel="prefetch" href="/assets/index.html-5vMJo5zl.js" as="script"><link rel="prefetch" href="/assets/index.html-NzOldGCw.js" as="script"><link rel="prefetch" href="/assets/index.html-8LHbHViB.js" as="script"><link rel="prefetch" href="/assets/index.html-QJ1JiGiQ.js" as="script"><link rel="prefetch" href="/assets/index.html-luFRsGQO.js" as="script"><link rel="prefetch" href="/assets/index.html-lEOgePBM.js" as="script"><link rel="prefetch" href="/assets/index.html-n2WOIVUQ.js" as="script"><link rel="prefetch" href="/assets/index.html-Rr0p6vcr.js" as="script"><link rel="prefetch" href="/assets/index.html-uigoOqzk.js" as="script"><link rel="prefetch" href="/assets/index.html-ekS7DzYz.js" as="script"><link rel="prefetch" href="/assets/photoswipe.esm-i2ohwMnJ.js" as="script"><link rel="prefetch" href="/assets/SearchResult-3GFtD4MS.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container has-toc"><!--[--><header id="navbar" class="vp-navbar"><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><!--[--><a class="vp-link vp-brand vp-brand" href="/"><img class="vp-nav-logo" src="/icon.png" alt="Honyelchak&#39;s Blog"><!----><span class="vp-site-name hide-in-pad">Honyelchak&#39;s Blog</span></a><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-center"><!--[--><!----><!--]--><!--[--><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-end"><!--[--><!----><!--]--><!--[--><!--[--><button type="button" class="search-pro-button" role="search" aria-label="搜索"><svg xmlns="http://www.w3.org/2000/svg" class="icon search-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="search icon"><path d="M192 480a256 256 0 1 1 512 0 256 256 0 0 1-512 0m631.776 362.496-143.2-143.168A318.464 318.464 0 0 0 768 480c0-176.736-143.264-320-320-320S128 303.264 128 480s143.264 320 320 320a318.016 318.016 0 0 0 184.16-58.592l146.336 146.368c12.512 12.48 32.768 12.48 45.28 0 12.48-12.512 12.48-32.768 0-45.28"></path></svg><div class="search-pro-placeholder">搜索</div><div class="search-pro-key-hints"><kbd class="search-pro-key">Ctrl</kbd><kbd class="search-pro-key">K</kbd></div></button><!--]--><!----><div class="nav-item hide-in-mobile"><button type="button" id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><nav class="vp-nav-links"><div class="nav-item hide-in-mobile"><a aria-label="主页" class="vp-link nav-link nav-link" href="/"><span class="font-icon icon fa-fw fa-sm fas fa-home" style=""></span>主页<!----></a></div><div class="nav-item hide-in-mobile"><a aria-label="Java学习" class="vp-link nav-link active nav-link active" href="/interview.html"><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span>Java学习<!----></a></div><div class="nav-item hide-in-mobile"><a aria-label="算法学习" class="vp-link nav-link nav-link" href="/algorithm.html"><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span>算法学习<!----></a></div><div class="nav-item hide-in-mobile"><a aria-label="课程学习" class="vp-link nav-link nav-link" href="/course.html"><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span>课程学习<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button type="button" class="dropdown-title" aria-label="项目"><span class="title"><span class="font-icon icon fa-fw fa-sm fas fa-circle-info" style=""></span>项目</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>教程</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a aria-label="/zh/cookbook/markdown/" class="vp-link nav-link nav-link" href="/zh/cookbook/markdown/"><!---->/zh/cookbook/markdown/<!----></a></li><li class="dropdown-subitem"><a aria-label="/zh/cookbook/vuepress/" class="vp-link nav-link nav-link" href="/zh/cookbook/vuepress/"><!---->/zh/cookbook/vuepress/<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>项目</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a aria-label="/zh/changelog" class="vp-link nav-link nav-link" href="/zh/changelog.html"><!---->/zh/changelog<!----></a></li><li class="dropdown-subitem"><a aria-label="/zh/migration/" class="vp-link nav-link nav-link" href="/zh/migration/"><!---->/zh/migration/<!----></a></li><li class="dropdown-subitem"><a aria-label="/zh/related" class="vp-link nav-link nav-link" href="/zh/related.html"><!---->/zh/related<!----></a></li><li class="dropdown-subitem"><a aria-label="/zh/contribution" class="vp-link nav-link nav-link" href="/zh/contribution.html"><!---->/zh/contribution<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><a aria-label="关于我" class="vp-link nav-link nav-link" href="/project.html"><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span>关于我<!----></a></div></nav><!--]--><!--[--><!----><!--]--><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar"><!--[--><!----><!--]--><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><p class="vp-sidebar-heading clickable active"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span><a aria-label="操作系统" class="vp-link nav-link vp-sidebar-title nav-link vp-sidebar-title" href="/interview/A1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><!---->操作系统<!----></a><!----></p><ul class="vp-sidebar-links"><li><!--[--><a aria-label="/interview/Git" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/Git.html"><!---->/interview/Git<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="/interview/JavaWeb" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/JavaWeb.html"><!---->/interview/JavaWeb<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="/interview/Java复习汇总" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/Java%E5%A4%8D%E4%B9%A0%E6%B1%87%E6%80%BB.html"><!---->/interview/Java复习汇总<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="/interview/Mybatis" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/Mybatis.html"><!---->/interview/Mybatis<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="/interview/Untitled" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/Untitled.html"><!---->/interview/Untitled<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="/interview/个人剖析" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/%E4%B8%AA%E4%BA%BA%E5%89%96%E6%9E%90.html"><!---->/interview/个人剖析<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="/interview/数据结构" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html"><!---->/interview/数据结构<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="/interview/斗智斗勇" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/%E6%96%97%E6%99%BA%E6%96%97%E5%8B%87.html"><!---->/interview/斗智斗勇<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="2 算法" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/LeetCode.html"><!---->2 算法<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">A1 操作系统</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">A2 计算机网络</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">A3 数据库</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">A4 Java</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">A5 Spring</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">A6 高并发相关</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">A7 分布式</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable active" type="button"><!----><span class="vp-sidebar-title">A8 中间件</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><!--[--><a aria-label="/interview/A8-中间件/nginx" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx.html"><!---->/interview/A8-中间件/nginx<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="一、基础知识" class="vp-link nav-link active vp-sidebar-link vp-sidebar-page active nav-link active vp-sidebar-link vp-sidebar-page active" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html"><!---->一、基础知识<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="操作系统层面" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#操作系统层面"><!---->操作系统层面<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="IO读写的基础原理" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#io读写的基础原理"><!---->IO读写的基础原理<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="干掉同步与异步、阻塞与非阻塞" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#干掉同步与异步、阻塞与非阻塞"><!---->干掉同步与异步、阻塞与非阻塞<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="五种IO模型" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#五种io模型"><!---->五种IO模型<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="回顾IO" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#回顾io"><!---->回顾IO<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="回顾BIO" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#回顾bio"><!---->回顾BIO<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="核心组件" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#核心组件"><!---->核心组件<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="Channel" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#channel"><!---->Channel<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Selector" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#selector"><!---->Selector<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Buffer" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#buffer"><!---->Buffer<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="总结" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#总结"><!---->总结<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="模块组件" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#模块组件"><!---->模块组件<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="Bootstrap、ServerBootstrap" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#bootstrap、serverbootstrap"><!---->Bootstrap、ServerBootstrap<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Future、ChannelFuture" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#future、channelfuture"><!---->Future、ChannelFuture<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="服务端Netty工作架构" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#服务端netty工作架构"><!---->服务端Netty工作架构<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="相关面试题" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#相关面试题"><!---->相关面试题<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="1、是否保证可靠传输？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#_1、是否保证可靠传输"><!---->1、是否保证可靠传输？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Java NIO" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#java-nio"><!---->Java NIO<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Netty中的NIO" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#netty中的nio"><!---->Netty中的NIO<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="Pipeline通道" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#pipeline通道"><!---->Pipeline通道<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="ByteBuf" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#bytebuf"><!---->ByteBuf<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="网络包接收流程" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#网络包接收流程"><!---->网络包接收流程<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="性能开销" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#性能开销"><!---->性能开销<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="网络包发送流程" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#网络包发送流程"><!---->网络包发送流程<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="性能开销" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#性能开销-1"><!---->性能开销<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="再谈(阻塞，非阻塞)与(同步，异步)" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#再谈-阻塞-非阻塞-与-同步-异步"><!---->再谈(阻塞，非阻塞)与(同步，异步)<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="阻塞与非阻塞" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#阻塞与非阻塞-1"><!---->阻塞与非阻塞<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="阻塞" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#阻塞-1"><!---->阻塞<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="非阻塞" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#非阻塞-1"><!---->非阻塞<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="同步与异步" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#同步与异步-1"><!---->同步与异步<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="同步" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#同步-1"><!---->同步<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="异步" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#异步-1"><!---->异步<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="IO模型" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#io模型"><!---->IO模型<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="阻塞IO（BIO）" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#阻塞io-bio"><!---->阻塞IO（BIO）<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="阻塞读" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#阻塞读"><!---->阻塞读<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="阻塞写" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#阻塞写"><!---->阻塞写<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="阻塞IO模型" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#阻塞io模型"><!---->阻塞IO模型<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="适用场景" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#适用场景"><!---->适用场景<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="非阻塞IO（NIO）" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#非阻塞io-nio"><!---->非阻塞IO（NIO）<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="非阻塞读" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#非阻塞读"><!---->非阻塞读<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="非阻塞写" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#非阻塞写"><!---->非阻塞写<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="非阻塞IO模型" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#非阻塞io模型"><!---->非阻塞IO模型<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="适用场景" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#适用场景-1"><!---->适用场景<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="IO多路复用" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#io多路复用"><!---->IO多路复用<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="select" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#select"><!---->select<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="API介绍" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#api介绍"><!---->API介绍<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="性能开销" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#性能开销-2"><!---->性能开销<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="poll" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#poll"><!---->poll<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="epoll" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#epoll"><!---->epoll<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="Socket的创建" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#socket的创建"><!---->Socket的创建<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="进程中管理文件列表结构" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#进程中管理文件列表结构"><!---->进程中管理文件列表结构<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Socket内核结构" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#socket内核结构"><!---->Socket内核结构<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="阻塞IO中用户进程阻塞以及唤醒原理" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#阻塞io中用户进程阻塞以及唤醒原理"><!---->阻塞IO中用户进程阻塞以及唤醒原理<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="epoll_create创建epoll对象" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#epoll-create创建epoll对象"><!---->epoll_create创建epoll对象<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="epoll_ctl向epoll对象中添加监听的Socket" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#epoll-ctl向epoll对象中添加监听的socket"><!---->epoll_ctl向epoll对象中添加监听的Socket<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="epoll_wait同步阻塞获取IO就绪的Socket" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#epoll-wait同步阻塞获取io就绪的socket"><!---->epoll_wait同步阻塞获取IO就绪的Socket<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="再谈水平触发和边缘触发" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#再谈水平触发和边缘触发"><!---->再谈水平触发和边缘触发<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="epoll对select，poll的优化总结" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#epoll对select-poll的优化总结"><!---->epoll对select，poll的优化总结<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="信号驱动IO" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#信号驱动io"><!---->信号驱动IO<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="IO线程模型" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#io线程模型"><!---->IO线程模型<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Reactor" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#reactor"><!---->Reactor<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="单Reactor单线程" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#单reactor单线程"><!---->单Reactor单线程<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="单Reactor多线程" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#单reactor多线程"><!---->单Reactor多线程<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="主从Reactor多线程" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#主从reactor多线程"><!---->主从Reactor多线程<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Proactor" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#proactor"><!---->Proactor<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Reactor与Proactor对比" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#reactor与proactor对比"><!---->Reactor与Proactor对比<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Netty的IO模型" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#netty的io模型"><!---->Netty的IO模型<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="配置单Reactor单线程" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#配置单reactor单线程"><!---->配置单Reactor单线程<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="配置单Reactor多线程" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#配置单reactor多线程"><!---->配置单Reactor多线程<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="配置主从Reactor多线程" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html#配置主从reactor多线程"><!---->配置主从Reactor多线程<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li></ul><!--]--></li><li><!--[--><a aria-label="常见问题" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.html"><!---->常见问题<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li></ul></section></li><li><!--[--><a aria-label="JAVA" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E9%97%AE%E9%A2%98.html"><!---->JAVA<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">Java面试题</span><span class="vp-arrow end"></span></button><!----></section></li><li><!--[--><a aria-label="三、总结" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/%E7%AE%80%E5%8E%86%E5%9F%8B%E7%82%B9.html"><!---->三、总结<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">工具</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">测试开发</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">硬件</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">系统设计</span><span class="vp-arrow end"></span></button><!----></section></li><li><!--[--><a aria-label="面试题" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/Netty.html"><!---->面试题<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li></ul></section></li><li><section class="vp-sidebar-group"><p class="vp-sidebar-heading"><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span><span class="vp-sidebar-title">计算机网络</span><!----></p><ul class="vp-sidebar-links"><li><!--[--><a aria-label="/interview/A2-计算机网络/IP冲突" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/A2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E5%86%B2%E7%AA%81.html"><!---->/interview/A2-计算机网络/IP冲突<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="/interview/A2-计算机网络/UDT和QUIC" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/A2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/UDT%E5%92%8CQUIC.html"><!---->/interview/A2-计算机网络/UDT和QUIC<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="/interview/A2-计算机网络/网络问题" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/A2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98.html"><!---->/interview/A2-计算机网络/网络问题<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="IP" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/A2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP.html"><!---->IP<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="一、HTTP" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/A2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.html"><!---->一、HTTP<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="常见问题" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/A2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Netty.html"><!---->常见问题<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">重学计算机网络</span><span class="vp-arrow end"></span></button><!----></section></li></ul></section></li></ul><!--[--><!----><!--]--></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!--[--><!----><!--]--><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><!---->一、基础知识</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://yuejinzhao.cn" target="_blank" rel="noopener noreferrer">Honyelchak</a></span><span property="author" content="Honyelchak"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2023-12-02T06:45:03.000Z"></span><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 94 分钟</span><meta property="timeRequired" content="PT94M"></span><!----><!----></div><hr></div><div class="toc-place-holder"><aside id="toc"><!--[--><!----><!--]--><div class="toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button></div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#操作系统层面">操作系统层面</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#io读写的基础原理">IO读写的基础原理</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#干掉同步与异步、阻塞与非阻塞">干掉同步与异步、阻塞与非阻塞</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#五种io模型">五种IO模型</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#回顾io">回顾IO</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#回顾bio">回顾BIO</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#核心组件">核心组件</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#channel">Channel</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#selector">Selector</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#buffer">Buffer</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#总结">总结</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#模块组件">模块组件</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#bootstrap、serverbootstrap">Bootstrap、ServerBootstrap</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#future、channelfuture">Future、ChannelFuture</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#服务端netty工作架构">服务端Netty工作架构</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#相关面试题">相关面试题</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#_1、是否保证可靠传输">1、是否保证可靠传输？</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#java-nio">Java NIO</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#netty中的nio">Netty中的NIO</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#pipeline通道">Pipeline通道</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#bytebuf">ByteBuf</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#网络包接收流程">网络包接收流程</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#性能开销">性能开销</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#网络包发送流程">网络包发送流程</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#性能开销-1">性能开销</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#再谈-阻塞-非阻塞-与-同步-异步">再谈(阻塞，非阻塞)与(同步，异步)</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#阻塞与非阻塞-1">阻塞与非阻塞</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#阻塞-1">阻塞</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#非阻塞-1">非阻塞</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#同步与异步-1">同步与异步</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#同步-1">同步</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#异步-1">异步</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#io模型">IO模型</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#阻塞io-bio">阻塞IO（BIO）</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#阻塞读">阻塞读</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#阻塞写">阻塞写</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#阻塞io模型">阻塞IO模型</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#适用场景">适用场景</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#非阻塞io-nio">非阻塞IO（NIO）</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#非阻塞读">非阻塞读</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#非阻塞写">非阻塞写</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#非阻塞io模型">非阻塞IO模型</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#适用场景-1">适用场景</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#io多路复用">IO多路复用</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#select">select</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#api介绍">API介绍</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#性能开销-2">性能开销</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#poll">poll</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#epoll">epoll</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#socket的创建">Socket的创建</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#进程中管理文件列表结构">进程中管理文件列表结构</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#socket内核结构">Socket内核结构</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#阻塞io中用户进程阻塞以及唤醒原理">阻塞IO中用户进程阻塞以及唤醒原理</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#epoll-create创建epoll对象">epoll_create创建epoll对象</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#epoll-ctl向epoll对象中添加监听的socket">epoll_ctl向epoll对象中添加监听的Socket</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#epoll-wait同步阻塞获取io就绪的socket">epoll_wait同步阻塞获取IO就绪的Socket</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#再谈水平触发和边缘触发">再谈水平触发和边缘触发</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#epoll对select-poll的优化总结">epoll对select，poll的优化总结</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#信号驱动io">信号驱动IO</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#io线程模型">IO线程模型</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#reactor">Reactor</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#单reactor单线程">单Reactor单线程</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#单reactor多线程">单Reactor多线程</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#主从reactor多线程">主从Reactor多线程</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#proactor">Proactor</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#reactor与proactor对比">Reactor与Proactor对比</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#netty的io模型">Netty的IO模型</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#配置单reactor单线程">配置单Reactor单线程</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#配置单reactor多线程">配置单Reactor多线程</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#配置主从reactor多线程">配置主从Reactor多线程</a></li><!----><!--]--></ul></li><!--]--></ul><div class="toc-marker" style="top:-1.7rem;"></div></div><!--[--><!----><!--]--></aside></div><!--[--><!----><!--]--><div class="theme-hope-content"><h1 id="一、基础知识" tabindex="-1"><a class="header-anchor" href="#一、基础知识" aria-hidden="true">#</a> 一、基础知识</h1><h2 id="操作系统层面" tabindex="-1"><a class="header-anchor" href="#操作系统层面" aria-hidden="true">#</a> 操作系统层面</h2><h3 id="io读写的基础原理" tabindex="-1"><a class="header-anchor" href="#io读写的基础原理" aria-hidden="true">#</a> IO读写的基础原理</h3><p>为了避免用户进程直接操作内核， 保证内核安全， 操作系统将内存（虚拟内存） 划分为两部分， 一部分是内核空间（Kernel-Space） ， 一部分是用户空间（User-Space） 。 在 Linux系统中， 内核模块运行在内核空间， 对应的进程处于内核态； 而用户程序运行在用户空间，对应的进程处于用户态。</p><p>操作系统的核心是内核， 独立于普通的应用程序， 可以访问受保护的内核空间， 也有访问底层硬件设备的权限。 内核空间总是驻留在内存中， 它是为操作系统的内核保留的。 <code>应用程序是不允许直接在内核空间区域进行读写</code>， <code>也是不容许直接调用内核代码定义的函数的</code>。每个应用程序进程都有一个单独的用户空间， 对应的进程处于用户态， 用户态进程不能访问内核空间中的数据， 也不能直接调用内核函数的，<mark>因此要进行系统调用的时候， 就要将进程切换到内核态才能进行。</mark></p><p>内核态进程可以执行任意命令， 调用系统的一切资源， 而用户态进程只能执行简单的运算， 不能直接调用系统资源。</p><p>现在问题来了： 用户态进程如何执行系统调用呢？</p><p>答案为： 用户态进程必须通过系统接口（System Call） ， 才能向内核发出指令， 完成调用系统资源之类的操作。</p><h4 id="两大命令" tabindex="-1"><a class="header-anchor" href="#两大命令" aria-hidden="true">#</a> 两大命令</h4><p>用户程序进行IO的读写， 依赖于底层的IO读写， 基本上会用到底层的两大系统调用：<code>sys_read</code> &amp; <code>sys_write</code>。</p><ul><li>虽然在不同的操作系统中， sys_read&amp;sys_write两大系统调用的名称和形式可能不完全一样， 但是他们的基本功能是一样的。</li></ul><ol><li><p>上层应用通过操作系统的<code>sys_read</code>系统调用， 是把数据从<u>内核缓冲区</u>复制到应用程序的<u>进程缓冲区</u>；</p></li><li><p>上层应用通过操作系统的<code>sys_write</code>系统调用， 是把数据从应用程序的进程缓冲区复制到操作系统内核缓冲区</p></li></ol><figure><img src="/assets/image-20231003213322072-8rjnH3L1.png" alt="image-20231003213322072" tabindex="0" loading="lazy"><figcaption>image-20231003213322072</figcaption></figure><p>简单来说， 应用程序的IO操作， 实际上不是物理设备级别的读写， 而是缓存的复制。sys_read&amp;sys_write两大系统调用， 都不负责数据在内核缓冲区和物理设备（如磁盘、 网卡等） 之间的交换。 这项底层的读写交换操作， 是由操作系统内核（Kernel） 来完成的。 所以，应用程序中的IO操作， 无论是对Socket的IO操作， 还是对文件的IO操作， 都属于上层应用的开发， 它们的在输入（Input） 和输出（Output） 维度上的执行流程， 都是类似的， 都是在内核缓冲区和进程缓冲区之间的进行数据交换。</p><blockquote><p>内核缓冲区和进程缓冲区的作用？</p><p>是为了减少频繁地与设备之间的物理交换。 计算机的外部物理设备与内存与CPU相比， 有着非常大的差距， 外部设备的直接读写， 涉及操作系统的中断。 发生系统中断时， 需要保存之前的进程数据和状态等信息， 而结束中断之后， 还需要恢复之前的进程数据和状态等信息。 为了减少底层系统的频繁中断所导致的时间损耗、 性能损耗， 于是出现了内核缓冲区 。</p></blockquote><p>内核缓冲区与应用缓冲区在数量上也不同， 在Linux系统中， 操作系统内核<code>只有一个</code>内核缓冲区。 而每个用户程序（进程） 则有自己独立的缓冲区， 叫做用户缓冲区或者进程缓冲区。</p><p><mark>Linux系统中的<strong>用户程序的IO读写程序</strong>， 在大多数情况下， 并没有进行实际的IO操作，而是在用户缓冲区和内核缓冲区之间直接进行数据的交换。</mark></p><figure><img src="/assets/image-20231003214103162-JucvL7iK.png" alt="image-20231003214103162" tabindex="0" loading="lazy"><figcaption>image-20231003214103162</figcaption></figure><figure><img src="/assets/image-20231003214110680---M7eEx6.png" alt="image-20231003214110680" tabindex="0" loading="lazy"><figcaption>image-20231003214110680</figcaption></figure><h3 id="干掉同步与异步、阻塞与非阻塞" tabindex="-1"><a class="header-anchor" href="#干掉同步与异步、阻塞与非阻塞" aria-hidden="true">#</a> 干掉同步与异步、阻塞与非阻塞</h3><p>首先回顾一下<strong>网络数据包的接受流程</strong>：</p><figure><img src="https://picx.zhimg.com/80/v2-6b4f4b9969a88660f4a74a7ff88657df_720w.webp?source=1940ef5c" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ul><li><strong>数据准备阶段：</strong> 在这个阶段，网络数据包到达网卡，通过<code>DMA</code> 的方式将数据包拷贝到内存中，然后经过硬中断，软中断，接着通过内核线程<code>ksoftirqd</code>经过内核协议栈的处理，最终将数据发送到<code>内核Socket</code>的接收缓冲区中。</li><li><strong>数据拷贝阶段：</strong> 当数据到达<code>内核Socket</code>的接收缓冲区中时，此时数据存在于<code>内核空间</code>中，需要将数据<code>拷贝</code>到<code>用户空间</code>中，才能够被应用程序读取。</li></ul><h4 id="阻塞与非阻塞" tabindex="-1"><a class="header-anchor" href="#阻塞与非阻塞" aria-hidden="true">#</a> <strong>阻塞与非阻塞</strong></h4><p>阻塞与非阻塞的区别主要发生在第一阶段：<code>数据准备阶段</code>。</p><p>当应用程序发起<code>系统调用read</code>时，线程从用户态转为内核态，读取内核<code>Socket</code>的接收缓冲区中的网络数据。</p><h5 id="阻塞" tabindex="-1"><a class="header-anchor" href="#阻塞" aria-hidden="true">#</a> <strong>阻塞</strong></h5><p>如果这时内核<code>Socket</code>的接收缓冲区没有数据，那么线程就会一直<code>等待</code>，直到<code>Socket</code>接收缓冲区有数据为止。随后将数据从内核空间拷贝到用户空间，<code>系统调用read</code>返回。</p><figure><img src="https://picx.zhimg.com/80/v2-bc3efc14ed2a97c01f46fcaf0216f710_720w.webp?source=1940ef5c" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>从图中我们可以看出：<strong>阻塞</strong>的特点是在第一阶段和第二阶段<code>都会等待</code>。</p><h5 id="非阻塞" tabindex="-1"><a class="header-anchor" href="#非阻塞" aria-hidden="true">#</a> <strong>非阻塞</strong></h5><p><code>阻塞</code>和<code>非阻塞</code>主要的区分是在第一阶段：<code>数据准备阶段</code>。</p><ul><li>在第一阶段，当<code>Socket</code>的接收缓冲区中没有数据的时候， <ul><li><code>阻塞模式下</code>应用线程<mark>会一直等待。</mark></li><li><code>非阻塞模式下</code>应用线程<mark>不会等待</mark>，<code>系统调用</code>直接返回错误标志<code>EWOULDBLOCK</code>。</li></ul></li><li>当<code>Socket</code>的接收缓冲区中有数据的时候，<code>阻塞</code>和<code>非阻塞</code>的表现是一样的，都会进入第二阶段<code>等待</code>数据从<code>内核空间</code>拷贝到<code>用户空间</code>，然后<code>系统调用返回</code>。</li></ul><figure><img src="https://pic1.zhimg.com/80/v2-82a61df046de31add3c1a68a1c5a7406_720w.webp?source=1940ef5c" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>从上图中，我们可以看出：<strong>非阻塞</strong>的特点是第一阶段<code>不会等待</code>，但是在第二阶段还是会<code>等待</code>。</p><h4 id="同步与异步" tabindex="-1"><a class="header-anchor" href="#同步与异步" aria-hidden="true">#</a> <strong>同步与异步</strong></h4><p><code>同步</code>与<code>异步</code>主要的区别发生在第二阶段：<code>数据拷贝阶段</code>。</p><p>前边我们提到在<code>数据拷贝阶段</code>主要是将数据从<code>内核空间</code>拷贝到<code>用户空间</code>。然后应用程序才可以读取数据。</p><p>当内核<code>Socket</code>的接收缓冲区有数据到达时，进入第二阶段。</p><h5 id="同步" tabindex="-1"><a class="header-anchor" href="#同步" aria-hidden="true">#</a> <strong>同步</strong></h5><p><code>同步模式</code>在数据准备好后，是由<code>用户线程</code>的<code>内核态</code>来执行<code>第二阶段</code>。所以应用程序会在第二阶段发生<code>阻塞</code>，直到数据从<code>内核空间</code>拷贝到<code>用户空间</code>，系统调用才会返回。</p><p>Linux下的 <code>epoll</code>和Mac 下的 <code>kqueue</code>都属于<code>同步 IO</code>。</p><figure><img src="/assets/v2-597111a5a02c723f1e0bef57e30809ef_720w-7U03hxnH.webp" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h5 id="异步" tabindex="-1"><a class="header-anchor" href="#异步" aria-hidden="true">#</a> <strong>异步</strong></h5><p><code>异步模式</code>下是由<code>内核</code>来执行第二阶段的数据拷贝操作，当<code>内核</code>执行完第二阶段，会通知用户线程IO操作已经完成，并将数据回调给用户线程。所以在<code>异步模式</code>下 <code>数据准备阶段</code>和<code>数据拷贝阶段</code>均是由<code>内核</code>来完成，不会对应用程序造成任何阻塞。</p><p>基于以上特征，我们可以看到<code>异步模式</code>需要内核的支持，比较依赖操作系统底层的支持。</p><p>在目前流行的操作系统中，只有Windows 中的 <code>IOCP</code>才真正属于异步 IO，实现的也非常成熟。但Windows很少用来作为服务器使用。</p><p>而常用来作为服务器使用的Linux，<code>异步IO机制</code>实现的不够成熟，与NIO相比性能提升的也不够明显。</p><p>但Linux kernel 在5.1版本由Facebook的大神Jens Axboe引入了新的异步IO库<code>io_uring</code> 改善了原来Linux native AIO的一些性能问题。性能相比<code>Epoll</code>以及之前原生的<code>AIO</code>提高了不少，值得关注。</p><figure><img src="/assets/v2-5b81acbcda49fdee380bcc6eea6ede73_720w-tcbxKvqE.webp" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="五种io模型" tabindex="-1"><a class="header-anchor" href="#五种io模型" aria-hidden="true">#</a> 五种IO模型</h3><h4 id="同步阻塞io-blocking-io" tabindex="-1"><a class="header-anchor" href="#同步阻塞io-blocking-io" aria-hidden="true">#</a> 同步阻塞IO（Blocking IO）</h4><p>首先， 解释一下阻塞与非阻塞。</p><p>也就是说，阻塞和非阻塞描述的是用户线程/进程在触发IO操作后的状态：</p><ul><li>阻塞IO， 指的是需要内核IO操作彻底完成后，才返回到用户空间执行用户程序的操作指令，阻塞一词所指的是用户程序（发起IO请求的进程或者线程）的执行状态是阻塞的。 可以说传统的IO模型都是阻塞IO模型， 并且在Java中， 默认创建的socket都属于阻塞IO模型。</li><li>简单理解， <strong>同步与异步可以看成是发起IO请求的两种方式</strong>。</li><li>同步IO是指<code>用户空间（进程或者线程） 是主动发起IO请求的一方</code>， 系统内核是被动接受方。</li><li>异步IO则反过来， <code>系统内核主动发起IO请求的一方， 用户空间是被动接受方</code>。 所谓同步阻塞IO， 指的是用户空间（或者线程） 主动发起， 需要等待内核IO操作彻底完成后， 才返回到用户空间的IO操作， IO操作过程中， 发起IO请求的用户进程（或者线程）处于阻塞状态。</li></ul><h4 id="同步非阻塞nio-non-blocking-io" tabindex="-1"><a class="header-anchor" href="#同步非阻塞nio-non-blocking-io" aria-hidden="true">#</a> 同步非阻塞NIO（Non-Blocking IO）</h4><p>非阻塞IO， 指的是用户空间的程序不需要等待内核IO操作彻底完成， 可以立即返回用户空间去执行后续的指令， 即发起IO请求的用户进程（或者线程） 处于非阻塞的状态， 与此同时， 内核会立即返回给用户一个IO的状态值。</p><blockquote><p><strong>阻塞和非阻塞的区别是什么呢？</strong> 阻塞是指用户进程（或者线程） 一直在等待， 而不能干别的事情； 非阻塞是指用户进程（或者线程） 拿到内核返回的状态值就返回自己的空间， 可以去干别的事情。 在Java中， 非阻塞IO的socket套接字， 要求被设置为NONBLOCK模式。 <strong>说 明</strong> 这里所说的 NIO（同步非阻塞 IO） 模型， 并非 Java 编程中的 NIO（New IO） 类库。所谓同步非阻塞NIO， 指的是用户进程主动发起， 不需要等待内核IO操作彻底完成之后，就能立即返回到用户空间的IO操作， IO操作过程中， 发起IO请求的用户进程（或者线程）处于非阻塞状态。</p></blockquote><h4 id="io多路复用-io-multiplexing" tabindex="-1"><a class="header-anchor" href="#io多路复用-io-multiplexing" aria-hidden="true">#</a> IO多路复用（IO Multiplexing）</h4><p>为了提高性能， 操作系统引入了一类新的系统调用， 专门用于查询IO文件描述符的（含socket连接） 的就绪状态。 在Linux系统中， 新的系统调用为select/epoll系统调用。 通过该系统调用， 一个用户进程（或者线程） 可以监视多个文件描述符， 一旦某个描述符就绪（一般是内核缓冲区可读/可写） ， 内核能够将文件描述符的就绪状态返回给用户进程（或者线程），用户空间可以根据文件描述符的就绪状态， 进行相应的IO系统调用。IO多路复用（IO Multiplexing） 是高性能Reactor线程模型的基础IO模型， 当然， 此模型是建立在同步非阻塞的模型基础之上的升级版。</p><h4 id="信号驱动io模型" tabindex="-1"><a class="header-anchor" href="#信号驱动io模型" aria-hidden="true">#</a> 信号驱动IO模型</h4><p>在信号驱动IO模型中， 用户线程通过向核心注册IO事件的回调函数， 来避免IO时间查询的阻塞。具体来说， 用户进程预先在内核中设置一个回调函数， 当某个事件发生时， <strong>内核使用信号（SIGIO） 通知进程运行回调函数</strong>。 然后进入IO操作的第二个阶段——执行阶段： 用户线程会继续执行， 在信号回调函数中调用IO读写操作来进行实际的IO请求操作。 信号驱动IO可以看成是一种异步IO， 可以简单理解为系统进行用户函数的回调。 只是，信号驱动IO的异步特性做的不彻底。 为什么呢？ 信号驱动IO仅仅在IO事件的通知阶段是异步的， 而在第二阶段， 也就是在将数据从内核缓冲区复制到用户缓冲区这个过程， 用户进程是阻塞的、 同步的。</p><h4 id="异步io-asynchronous-io" tabindex="-1"><a class="header-anchor" href="#异步io-asynchronous-io" aria-hidden="true">#</a> 异步IO（Asynchronous IO）</h4><p>异步IO， 指的是用户空间与内核空间的调用方式大反转。 用户空间的线程变成被动接受者， 而内核空间成了主动调用者。 在异步IO模型中， 当用户线程收到通知时， 数据已经被内核读取完毕， 并放在了用户缓冲区内， 内核在IO完成后通知用户线程直接使用即可。 异步IO类似于Java中典型的回调模式， 用户进程（或者线程） 向内核空间注册了各种IO事件的回调函数， 由内核去主动调用。 异步IO包含两种：</p><ul><li>不完全异步的信号驱动IO模型</li><li>完全的异步IO模型。</li></ul><figure><img src="/assets/1492928105791_3-VQTndHD1.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h1 id="二、java中的nio" tabindex="-1"><a class="header-anchor" href="#二、java中的nio" aria-hidden="true">#</a> 二、Java中的NIO</h1><h2 id="回顾io" tabindex="-1"><a class="header-anchor" href="#回顾io" aria-hidden="true">#</a> 回顾IO</h2><h2 id="回顾bio" tabindex="-1"><a class="header-anchor" href="#回顾bio" aria-hidden="true">#</a> 回顾BIO</h2><p>JDK早期的版本中的，BIO值得其实就是<code>blocking io</code>。</p><h2 id="核心组件" tabindex="-1"><a class="header-anchor" href="#核心组件" aria-hidden="true">#</a> 核心组件</h2><h3 id="channel" tabindex="-1"><a class="header-anchor" href="#channel" aria-hidden="true">#</a> Channel</h3><h4 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h4><p><mark>本质上，一个Channel就是对底层文件描述符的一个封装</mark></p><p>Java NIO中， <strong>一个socket连接使用一个Channel（通道） 来表示</strong>。从更广泛的层面来说， 一个通道封装了一个底层的文件描述符， 例如硬件设备、 文件、 网络连接等。 所以， 与文件描述符相对应， Java NIO的通道分为很多类型。 但是Java的通道更加的细化， 例如， 对应到不同的网络传输协议类型， 在Java中都有不同的NIO Channel（通道） 相对应。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">SocketChannelImpl</span> <span class="token keyword">extends</span> <span class="token class-name">SocketChannel</span> <span class="token keyword">implements</span> <span class="token class-name">SelChImpl</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">NativeDispatcher</span> nd<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">FileDescriptor</span> fd<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> fdVal<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">SelChImpl</span> <span class="token keyword">extends</span> <span class="token class-name">Channel</span> <span class="token punctuation">{</span>
    <span class="token class-name">FileDescriptor</span> <span class="token function">getFD</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> <span class="token function">getFDVal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">boolean</span> <span class="token function">translateAndUpdateReadyOps</span><span class="token punctuation">(</span><span class="token keyword">int</span> var1<span class="token punctuation">,</span> <span class="token class-name">SelectionKeyImpl</span> var2<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">boolean</span> <span class="token function">translateAndSetReadyOps</span><span class="token punctuation">(</span><span class="token keyword">int</span> var1<span class="token punctuation">,</span> <span class="token class-name">SelectionKeyImpl</span> var2<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">void</span> <span class="token function">translateAndSetInterestOps</span><span class="token punctuation">(</span><span class="token keyword">int</span> var1<span class="token punctuation">,</span> <span class="token class-name">SelectionKeyImpl</span> var2<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> <span class="token function">validOps</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">void</span> <span class="token function">kill</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="主要类型" tabindex="-1"><a class="header-anchor" href="#主要类型" aria-hidden="true">#</a> 主要类型</h4><ul><li><code>FileChannel</code>文件通道， 用于文件的数据读写； <ul><li>特别申明一下， FileChannel为阻塞模式， 不能设置为非阻塞模式</li></ul></li><li><code>SocketChannel</code>套接字通道， 用于Socket套接字TCP连接的数据读写；</li><li><code>ServerSocketChannel</code>服务器套接字通道（或服务器监听通道） ， 允许我们监听TCP连接请求， 为每个监听到的请求， 创建一个SocketChannel套接字通道；</li><li><code>DatagramChannel</code>数据报通道， 用于UDP协议的数据读写。</li></ul><blockquote><p>无论是ServerSocketChannel， 还是SocketChannel， 都支持阻塞和非阻塞两种模式。</p><p>在阻塞模式下， SocketChannel通道的connect连接、 read读、 write写操作， 都是同步的和阻塞式的， 在效率上与Java旧的OIO的面向流的阻塞式读写操作相同。</p></blockquote><h3 id="selector" tabindex="-1"><a class="header-anchor" href="#selector" aria-hidden="true">#</a> Selector</h3><p>选择器的使命是完成IO的多路复用， 其主要工作是通道的注册、 监听、 事件查询。</p><p>一个通道代表一条连接通路， 通过选择器可以同时监控多个通道的IO（输入输出）状况。</p><blockquote><p>在NIO编程中， 一般是一个单线程处理一个选择器， 一个选择器可以监控很多通道。 所以， 通过选择器， 一个单线程可以处理数百、 数千、 数万、 甚至更多的通道。 在极端情况下（数万个连接） ， 只用一个线程就可以处理所有的通道， 这样会大量地减少线程之间上下文切换的开销。</p></blockquote><p>通道和选择器之间的关联， 通过register（注册） 的方式完成。 调用通道的Channel.register（Selector sel， int ops） 方法， 可以将通道实例注册到一个选择器中。 register方法有两个参数： 第一个参数， 指定通道注册到的选择器实例； 第二个参数， 指定选择器要监控的IO事件类型。</p><p>可供选择器监控的通道IO就绪事件类型， 包括以下四种：</p><ol><li>可读： SelectionKey.OP_READ</li><li>可写： SelectionKey.OP_WRITE</li><li>连接： SelectionKey.OP_CONNECT</li><li>接收： SelectionKey.OP_ACCEPT</li></ol><blockquote><p>如果选择器要监控通道的多种事件， 可以用“按位或” 运算符来实现。 例如， 同时监控可读和可写IO事件：</p><p><code>int key = SelectionKey.OP_READ | SelectionKey.OP_WRITE ; </code></p></blockquote><h3 id="buffer" tabindex="-1"><a class="header-anchor" href="#buffer" aria-hidden="true">#</a> Buffer</h3><h4 id="概述-1" tabindex="-1"><a class="header-anchor" href="#概述-1" aria-hidden="true">#</a> 概述</h4><p>缓冲区， <strong>实际上是一个容器， 一个连续数组</strong>。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">ByteBuffer</span>
    <span class="token keyword">extends</span> <span class="token class-name">Buffer</span>
    <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ByteBuffer</span><span class="token punctuation">&gt;</span></span>
<span class="token punctuation">{</span>

    <span class="token comment">// These fields are declared here rather than in Heap-X-Buffer in order to</span>
    <span class="token comment">// reduce the number of virtual method invocations needed to access these</span>
    <span class="token comment">// values, which is especially costly when coding small buffers.</span>
    <span class="token comment">//</span>
    <span class="token keyword">final</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> hb<span class="token punctuation">;</span>                  <span class="token comment">// Non-null only for heap buffers</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> offset<span class="token punctuation">;</span>
    <span class="token keyword">boolean</span> isReadOnly<span class="token punctuation">;</span>                 <span class="token comment">// Valid only for heap buffers</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>Channel提供从文件、 网络读取数据的渠道， 但是读写的数据都必须经过Buffer 。</li><li>NIO的Buffer的内部是一个内存块（数组） ， 此类与普通的内存块（Java数组） 不同的是： <code>NIO Buffer对象， 提供了一组比较有效的方法， 用来进行写入和读取的交替访问</code>。</li></ol><figure><img src="/assets/image-20231004163058960-HzpC97Qm.png" alt="image-20231004163058960" tabindex="0" loading="lazy"><figcaption>image-20231004163058960</figcaption></figure><h4 id="种类" tabindex="-1"><a class="header-anchor" href="#种类" aria-hidden="true">#</a> 种类</h4><p>Buffer类是一个抽象类， 对应于Java的主要数据类型，在NIO中有8种缓冲区类， 分别如下：</p><p>ByteBuffer、 CharBuffer、 DoubleBuffer、 FloatBuffer、 IntBuffer、 LongBuffer、 ShortBuffer、MappedByteBuffer。</p><ol><li>前7种Buffer类型， 覆盖了能在IO中传输的所有的Java基本数据类型。</li><li>第8种类型MappedByteBuffer是<code>专门用于内存映射的一种ByteBuffer类型</code>。 不同的Buffer子类， 其能操作的数据类型能够通过名称进行判断， 比如IntBuffer只能操作Integer类型的对象。实际上， 使用最多的还是ByteBuffer二进制字节缓冲区类型。</li></ol><h4 id="重要的属性" tabindex="-1"><a class="header-anchor" href="#重要的属性" aria-hidden="true">#</a> 重要的属性</h4><p>其中有以下三个重要的成员属性：</p><ul><li>capacity（容量） <ul><li>Buffer类的对象在初始化时， 会按照capacity分配内部数组的内存， 在数组内存分配好之后， <u>大小不会变</u></li></ul></li><li>position（读写位置） <ul><li>位置， 缓冲区中下一个要被读或写的元素的索引</li></ul></li><li>limit（ 读写的限制） <ul><li>上限， 缓冲区中当前的数据量</li></ul></li><li>mark（ 读写位置的临时备份） <ul><li>调用 mark()方法来设置 mark=position， 再调用 reset()可以让 position 恢复到 mark 标记的位置， 即 position=mark</li></ul></li></ul><figure><img src="/assets/image-20231004164901332-gryEfCTn.png" alt="image-20231004164901332" tabindex="0" loading="lazy"><figcaption>image-20231004164901332</figcaption></figure><p>另外一个重要的地方，<strong>Buffer支持rewind(重复读)</strong></p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>与Java OIO相比， Java NIO编程大致的特点如下：</p><ol><li>在NIO中， 服务器接收新连接的工作， 是异步进行的。 不像Java的OIO那样， 服务器监听连接， 是同步的、 阻塞的。 NIO可以通过选择器（也可以说成： 多路复用器） ， 后续不断地轮询选择器的选择键集合， 选择新到来的连接。</li><li>在NIO中， SocketChannel传输通道的读写操作都是异步的。 如果没有可读写的数据， 负责IO通信的线程不会同步等待。 这样， 线程就可以处理其他连接的通道； 不需要像OIO那样， 线程一直阻塞， 等待所负责的连接可用为止。</li><li>在NIO中， 一个选择器线程可以同时处理成千上万的客户端连接， 性能不会随着客户端的增加而线性下降。</li></ol><h1 id="三、netty" tabindex="-1"><a class="header-anchor" href="#三、netty" aria-hidden="true">#</a> 三、Netty</h1><h2 id="模块组件" tabindex="-1"><a class="header-anchor" href="#模块组件" aria-hidden="true">#</a> 模块组件</h2><h3 id="bootstrap、serverbootstrap" tabindex="-1"><a class="header-anchor" href="#bootstrap、serverbootstrap" aria-hidden="true">#</a> Bootstrap、ServerBootstrap</h3><blockquote><p><code>bootstrap</code>一词通常指的就是启动或者引导过程。它是指在程序或系统开始运行之前必须执行的一系列初始化操作。</p><p>像JDK中的类加载器、SpringBoot也都有这个概念。</p></blockquote><p>一个Netty应用通常由一个Bootstrap开始，主要作用是配置整个Netty程序，串联各个组件，Netty中Bootstrap类是客户端程序的启动引导类，ServerBootstrap是服务端启动引导类。</p><h3 id="future、channelfuture" tabindex="-1"><a class="header-anchor" href="#future、channelfuture" aria-hidden="true">#</a> Future、ChannelFuture</h3><p>在Netty中所有的IO操作都是异步的，不能立刻得知消息是否被正确处理，但是可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过Future和ChannelFutures，他们可以注册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事件。</p><h2 id="服务端netty工作架构" tabindex="-1"><a class="header-anchor" href="#服务端netty工作架构" aria-hidden="true">#</a> 服务端Netty工作架构</h2><p>为了及时接受（Accept） 到新连接， 在服务器端，一般有两个独立的反应器(两个反应器相互隔离)：</p><ol><li>一个反应器<mark>负责新连接的监听和接受</mark><ol><li><code>负责新连接的监听和接收的EventLoopGroup轮询组中的反应器（Reactor） </code>， 完成查询通道的新连接IO事件查询， 这些反应器有点像负责招工的包工头， 因此， 该轮询组可以形象地称为“包工头”（Boss） 轮询组。</li></ol></li><li>另一个反应器<mark>负责IO事件轮询和分发</mark><ol><li><code>另一个轮询组中的反应器（Reactor），完成查询所有子通道的IO事件</code>， 并且执行对应的Handler处理器完成IO处理——例如数据的输入和输出（有点儿像搬砖） ， 这个轮询组可以形象地称为“工人”（Worker） 轮询组。</li></ol></li></ol><figure><img src="/assets/image-20231007155521051-uLY72xX8.png" alt="image-20231007155521051" tabindex="0" loading="lazy"><figcaption>image-20231007155521051</figcaption></figure><h2 id="相关面试题" tabindex="-1"><a class="header-anchor" href="#相关面试题" aria-hidden="true">#</a> 相关面试题</h2><h3 id="_1、是否保证可靠传输" tabindex="-1"><a class="header-anchor" href="#_1、是否保证可靠传输" aria-hidden="true">#</a> 1、是否保证可靠传输？</h3><p>Netty本身并不保证可靠传输。</p><p>但可以通过下列方法保证：</p><ol><li><strong>在传输层，使用TCP协议</strong><ol><li>使用TCP协议来提供可靠的数据传输。TCP协议提供了可靠性保证，包括数据的分段、排序、重传等机制。当使用TCP作为传输协议时，底层的TCP协议会负责处理数据的可靠传输，保证数据不会丢失。</li></ol></li><li><strong>在应用层，自定义可靠传输机制</strong><ol><li>在应用层协议中实现消息的确认机制。接收方在接收到消息后，可以发送确认消息给发送方，告知发送方消息已经接收。发送方在接收到确认消息后，可以确认消息已经成功传输，或者在一定时间内未收到确认消息时进行重传。这种确认机制可以在应用层实现，以提供额外的保护，确保消息的可靠传输。</li></ol></li></ol><h1 id="四、reactor模式" tabindex="-1"><a class="header-anchor" href="#四、reactor模式" aria-hidden="true">#</a> 四、Reactor模式</h1><h2 id="java-nio" tabindex="-1"><a class="header-anchor" href="#java-nio" aria-hidden="true">#</a> Java NIO</h2><ol><li>通道注册：</li></ol><h2 id="netty中的nio" tabindex="-1"><a class="header-anchor" href="#netty中的nio" aria-hidden="true">#</a> Netty中的NIO</h2><ol><li>通道注册 <ol><li>Netty封装了NIO的Selector组件和Thread线程实例， 设计了自己的Reactor角色， 名称叫做<code>EventLoop</code>(事件循环)</li><li>并且封装了NIO的Channel组件， 设计了自己的传输通道组件， 名字仍然叫做Channel， 只是所处的包不同。 通道注册， 指的是将Netty的Channel注册到EventLoop上， 对应到底层就是NIO的Channel注册到NIO的Selector上。</li></ol></li><li>查询事件 <ol><li>在Reactor中，一个线程会负责一个反应器，EventLoop和Thread也是这种一对一的模式。 一个反应器负责一个Selector的查询， EventLoop内部Thread不断地轮询， 查询选择器Selector中的IO事件， 并记录在选择键上面 。</li></ol></li><li>事件内部分发、数据读取和发射 <ol><li>这里和经典的Reactor模式有细微的区别： 在经典Reactor模式中事件分发和数据读取是分开的， Reactor负责IO事件的分发， Handler负责 数据的读取； 而在Netty的Reactor模式中， <code>反应器EventLoop</code>把<u>事件分发</u>和<u>数据读取</u>两个操作一起负责了。</li><li>具体来说，EventLoop能访问到通道的Unsafe成员， 当IO事件发生时， 直接通过Unsafe成员完成NIO底层的数据读取。 EventLoop读取到的数据后， 会把数据发射到Channel内部的Pipeline流水线通道。</li></ol></li><li>流水线传播和业务处理 <ol><li>数据在通道的Pipeline流水线上传播，通道的流水线由<code>Handler</code>构成，由Handler业务处理器负责， 处理完成之后， 再把结果传播或者传递到下一个Handler。</li><li>为啥需要Pipeline流水线呢？ <ol><li>主要是由于同一个NIO事件， 可能会有多个业务处理，比如数据的解码、 数据的校验、 业务的处理， 所以<strong>Netty通过责任链模式将多个业务处理器组织起来，成为一个pipeline（流水线）</strong> 。</li><li>Pipeline流水线由通道负责管理， 属于通道的一部分。 数据可以在流水线上传播， 再交给流水线上的Handler来处理。 Handler业务处理器放置的是具体的业务逻辑， 这是Java工程师们需要负责开发的部分。</li></ol></li></ol></li></ol><h3 id="pipeline通道" tabindex="-1"><a class="header-anchor" href="#pipeline通道" aria-hidden="true">#</a> Pipeline通道</h3><p>多个EventLoop线程放在一起， 可以组成一个EventLoopGroup轮询组 。</p><p>在服务器端， 一般有两个独立的反应器， 一个反应器负责新连接的监听和接受， 另一个反应器负责IO事件轮询和分发， 两个反应器相互隔离。</p><p>（1） 负责<code>新连接的监听和接收</code>的EventLoopGroup轮询组中的反应器（Reactor） ， 完成查询通道的新连接IO事件查询， 这些反应器有点像负责招工的包工头， 因此， 该轮询组可以形象地称为“包工头”（Boss） 轮询组。 （2） 另一个轮询组中的反应器（Reactor），完成<code>查询所有子通道的IO事件， 并且执行对应的Handler处理器完成IO处理</code>——例如数据的输入和输出（有点儿像搬砖） ， 这个轮询组可以形象地称为“工人”（Worker） 轮询组。</p><figure><img src="/assets/image-20231004205847815-Y3KgaJG0.png" alt="image-20231004205847815" tabindex="0" loading="lazy"><figcaption>image-20231004205847815</figcaption></figure><figure><img src="/assets/image-20231004210039172-qAjFVF3b.png" alt="image-20231004210039172" tabindex="0" loading="lazy"><figcaption>image-20231004210039172</figcaption></figure><p>在设置反应器轮询组之前， 创建了两个NioEventLoopGroup轮询组， 一个负责处理连接监听IO事件， 名为bossLoopGroup； 另一个负责数据传输事件和处理， 名为workerLoopGroup。在两个轮询组创建完成后， 就可以配置给引导类实例， 它一次性地给引导类配置了两大轮询组。</p><h3 id="bytebuf" tabindex="-1"><a class="header-anchor" href="#bytebuf" aria-hidden="true">#</a> ByteBuf</h3><p>与Java NIO的ByteBuffer相比， ByteBuf的优势如下：</p><ol><li>Pooling (池化机制)， 这点减少了内存的分配和释放， 减少了GC， 提升了效率</li><li>零复制机制(如复合缓冲区类型)， 这点减少了内存复制</li><li>不需要调用flip()方法去切换读/写模式</li><li>可扩展性好</li><li>可以自定义缓冲区类型</li><li>读取和写入索引分开</li><li>方法的链式调用</li><li>可以进行引用计数， 方便重复使用</li></ol><p>ByteBuf是一个字节容器， 内部是一个字节数组。 从逻辑上来分， 字节容器内部可以分为四个部分：</p><figure><img src="/assets/image-20231004212127250-VSt9Uyn0.png" alt="image-20231004212127250" tabindex="0" loading="lazy"><figcaption>image-20231004212127250</figcaption></figure><p>JVM中使用“计数器” （一种GC算法） 来标记对象是否“不可达” 进而收回（注： GC是Garbage Collection的缩写， 即Java中的垃圾回收机制） ， Netty也使用了这种手段来对ByteBuf的引用进行计数， Netty的ByteBuf的内存回收工作是通过引用计数的方式管理的。</p><p>Netty之所以采用“计数器”来追踪ByteBuf的生命周期，</p><ol><li>一是能对Pooled ByteBuf的支持</li><li>二是能够尽快地“发现” 那些可以回收的ByteBuf（非Pooled） ， 以便提升ByteBuf的分配和销毁的效率 。</li></ol><blockquote><p>什么是 Pooled（池化） 的 ByteBuf 缓冲区呢？ 从 Netty4 版本开始， 新增了 ByteBuf的池化机制。 即创建一个缓冲区对象池， 将没有被引用的 ByteBuf 对象， 放入对象缓存池中；当需要时， 则重新从对象缓存池中取出， 而不需要重新创建。</p></blockquote><p>Netty在缓冲区使用完成后， 会调用一次release， 就是释放一次。 例如在Netty流水线上，中间所有的Handler业务处理器处理完ByteBuf之后直接传递给下一个， 由最后一个Handler负责调用其release方法来释放缓冲区的内存空间。</p><p>当ByteBuf的引用计数已经为0， Netty会进行ByteBuf的回收。 分为两种场景：</p><ol><li>如果属于Pooled池化的ByteBuf内存， 回收方法是： 放入可以重新分配的ByteBuf池子， 等待下一次分配；</li><li>Unpooled未池化的ByteBuf缓冲区， 需要细分为两种情况： 如果是堆（Heap） 结构缓冲， 会被JVM的垃圾回收机制回收； 如果是Direct直接内存的类型， 则会调用本地方法释放外部内存（unsafe.freeMemory） 。</li></ol><blockquote><p>除了通过ByteBuf成员方法retain和release管理引用计数之外， Netty还提供了一组件用于增加和减少引用计数的通用静态方法： （1） ReferenceCountUtil.retain(Object)： 增加一次缓冲区引用计数的静态方法， 从而防止该缓冲区被释放； （2） ReferenceCountUtil.release(Object)： 减少一次缓冲区引用计数的静态方法， 如果引用计数为 0， 缓冲区将被释放。</p></blockquote><h1 id="知乎硬核文章" tabindex="-1"><a class="header-anchor" href="#知乎硬核文章" aria-hidden="true">#</a> 知乎硬核文章</h1><p>从今天开始我们来聊聊Netty的那些事儿，我们都知道Netty是一个高性能异步事件驱动的网络框架。</p><p>它的设计异常优雅简洁，扩展性高，稳定性强。拥有非常详细完整的用户文档。</p><p>同时内置了很多非常有用的模块基本上做到了开箱即用，用户只需要编写短短几行代码，就可以快速构建出一个具有<code>高吞吐</code>，<code>低延时</code>，<code>更少的资源消耗</code>，<code>高性能（非必要的内存拷贝最小化）</code>等特征的高并发网络应用程序。</p><p>本文我们来探讨下支持Netty具有<code>高吞吐</code>，<code>低延时</code>特征的基石----netty的<code>网络IO模型</code>。</p><p>由Netty的<code>网络IO模型</code>开始，我们来正式揭开本系列Netty源码解析的序幕：</p><h2 id="网络包接收流程" tabindex="-1"><a class="header-anchor" href="#网络包接收流程" aria-hidden="true">#</a> <strong>网络包接收流程</strong></h2><figure><img src="https://pic1.zhimg.com/80/v2-aa10bd85f52845f4de8ee3b095ffac3e_720w.webp?source=1940ef5c" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ul><li>当<code>网络数据帧</code>通过网络传输到达网卡时，网卡会将网络数据帧通过<code>DMA的方式</code>放到<code>环形缓冲区RingBuffer</code>中。</li></ul><blockquote><p><code>RingBuffer</code>是网卡在启动的时候<code>分配和初始化</code>的<code>环形缓冲队列</code>。当<code>RingBuffer满</code>的时候，新来的数据包就会被<code>丢弃</code>。我们可以通过<code>ifconfig</code>命令查看网卡收发数据包的情况。其中<code>overruns</code>数据项表示当<code>RingBuffer满</code>时，被<code>丢弃的数据包</code>。如果发现出现丢包情况，可以通过<code>ethtool命令</code>来增大RingBuffer长度。</p></blockquote><ul><li>当<code>DMA操作完成</code>时，网卡会向CPU发起一个<code>硬中断</code>，告诉<code>CPU</code>有网络数据到达。CPU调用网卡驱动注册的<code>硬中断响应程序</code>。网卡硬中断响应程序会为网络数据帧创建内核数据结构<code>sk_buffer</code>，并将网络数据帧<code>拷贝</code>到<code>sk_buffer</code>中。然后发起<code>软中断请求</code>，通知<code>内核</code>有新的网络数据帧到达。</li></ul><blockquote><p><code>sk_buff</code>缓冲区，是一个维护网络帧结构的<code>双向链表</code>，链表中的每一个元素都是一个<code>网络帧</code>。虽然 TCP/IP 协议栈分了好几层，但上下不同层之间的传递，实际上只需要操作这个数据结构中的指针，而<code>无需进行数据复制</code>。</p></blockquote><ul><li>内核线程<code>ksoftirqd</code>发现有软中断请求到来，随后调用网卡驱动注册的<code>poll函数</code>，<code>poll函数</code>将<code>sk_buffer</code>中的<code>网络数据包</code>送到内核协议栈中注册的<code>ip_rcv函数</code>中。</li></ul><blockquote><p><code>每个CPU</code>会绑定<code>一个ksoftirqd</code>内核线程<code>专门</code>用来处理<code>软中断响应</code>。2个 CPU 时，就会有 <code>ksoftirqd/0</code> 和 <code>ksoftirqd/1</code>这两个内核线程。</p><p><strong>这里有个事情需要注意下：</strong> 网卡接收到数据后，当<code>DMA拷贝完成</code>时，向CPU发出<code>硬中断</code>，这时<code>哪个CPU</code>上响应了这个<code>硬中断</code>，那么在网卡<code>硬中断响应程序</code>中发出的<code>软中断请求</code>也会在<code>这个CPU绑定的ksoftirqd线程</code>中响应。所以如果发现Linux软中断，CPU消耗都<code>集中在一个核上</code>的话，那么就需要调整硬中断的<code>CPU亲和性</code>，来将硬中断<code>打散</code>到<code>不通的CPU核</code>上去。</p></blockquote><ul><li>在<code>ip_rcv函数</code>中也就是上图中的<code>网络层</code>，<code>取出</code>数据包的<code>IP头</code>，判断该数据包下一跳的走向，如果数据包是发送给本机的，则取出传输层的协议类型（<code>TCP</code>或者<code>UDP</code>)，并<code>去掉</code>数据包的<code>IP头</code>，将数据包交给上图中得<code>传输层</code>处理。</li></ul><blockquote><p>传输层的处理函数：<code>TCP协议</code>对应内核协议栈中注册的<code>tcp_rcv函数</code>，<code>UDP协议</code>对应内核协议栈中注册的<code>udp_rcv函数</code>。</p></blockquote><ul><li>当我们采用的是<code>TCP协议</code>时，数据包到达传输层时，会在内核协议栈中的<code>tcp_rcv函数</code>处理，在tcp_rcv函数中<code>去掉</code>TCP头，根据<code>四元组（源IP，源端口，目的IP，目的端口）</code>查找<code>对应的Socket</code>，如果找到对应的Socket则将网络数据包中的传输数据拷贝到<code>Socket</code>中的<code>接收缓冲区</code>中。如果没有找到，则发送一个<code>目标不可达</code>的<code>icmp</code>包。</li><li>内核在接收网络数据包时所做的工作我们就介绍完了，现在我们把视角放到应用层，当我们程序通过系统调用<code>read</code>读取<code>Socket接收缓冲区</code>中的数据时，如果接收缓冲区中<code>没有数据</code>，那么应用程序就会在系统调用上<code>阻塞</code>，直到Socket接收缓冲区<code>有数据</code>，然后<code>CPU</code>将<code>内核空间</code>（Socket接收缓冲区）的数据<code>拷贝</code>到<code>用户空间</code>，最后系统调用<code>read返回</code>，应用程序<code>读取</code>数据。</li></ul><h2 id="性能开销" tabindex="-1"><a class="header-anchor" href="#性能开销" aria-hidden="true">#</a> <strong>性能开销</strong></h2><p>从内核处理网络数据包接收的整个过程来看，内核帮我们做了非常之多的工作，最终我们的应用程序才能读取到网络数据。</p><p>随着而来的也带来了很多的性能开销，结合前面介绍的网络数据包接收过程我们来看下网络数据包接收的过程中都有哪些性能开销：</p><ul><li>应用程序通过<code>系统调用</code>从<code>用户态</code>转为<code>内核态</code>的开销以及系统调用<code>返回</code>时从<code>内核态</code>转为<code>用户态</code>的开销。</li><li>网络数据从<code>内核空间</code>通过<code>CPU拷贝</code>到<code>用户空间</code>的开销。</li><li>内核线程<code>ksoftirqd</code>响应<code>软中断</code>的开销。</li><li><code>CPU</code>响应<code>硬中断</code>的开销。</li><li><code>DMA拷贝</code>网络数据包到<code>内存</code>中的开销。</li></ul><h2 id="网络包发送流程" tabindex="-1"><a class="header-anchor" href="#网络包发送流程" aria-hidden="true">#</a> <strong>网络包发送流程</strong></h2><figure><img src="https://picx.zhimg.com/80/v2-9147efe7747fea705cfc3acdb1e1f9c4_720w.webp?source=1940ef5c" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ul><li>当我们在应用程序中调用<code>send</code>系统调用发送数据时，由于是系统调用所以线程会发生一次用户态到内核态的转换，在内核中首先根据<code>fd</code>将真正的Socket找出，这个Socket对象中记录着各种协议栈的函数地址，然后构造<code>struct msghdr</code>对象，将用户需要发送的数据全部封装在这个<code>struct msghdr</code>结构体中。</li><li>调用内核协议栈函数<code>inet_sendmsg</code>，发送流程进入内核协议栈处理。在进入到内核协议栈之后，内核会找到Socket上的具体协议的发送函数。</li></ul><blockquote><p>比如：我们使用的是<code>TCP协议</code>，对应的<code>TCP协议</code>发送函数是<code>tcp_sendmsg</code>，如果是<code>UDP协议</code>的话，对应的发送函数为<code>udp_sendmsg</code>。</p></blockquote><ul><li>在<code>TCP协议</code>的发送函数<code>tcp_sendmsg</code>中，创建内核数据结构<code>sk_buffer</code>,将 <code>struct msghdr</code>结构体中的发送数据<code>拷贝</code>到<code>sk_buffer</code>中。调用<code>tcp_write_queue_tail</code>函数获取<code>Socket</code>发送队列中的队尾元素，将新创建的<code>sk_buffer</code>添加到<code>Socket</code>发送队列的尾部。</li></ul><blockquote><p><code>Socket</code>的发送队列是由<code>sk_buffer</code>组成的一个<code>双向链表</code>。</p><p>发送流程走到这里，用户要发送的数据总算是从<code>用户空间</code>拷贝到了<code>内核</code>中，这时虽然发送数据已经<code>拷贝</code>到了内核<code>Socket</code>中的<code>发送队列</code>中，但并不代表内核会开始发送，因为<code>TCP协议</code>的<code>流量控制</code>和<code>拥塞控制</code>，用户要发送的数据包<code>并不一定</code>会立马被发送出去，需要符合<code>TCP协议</code>的发送条件。如果<code>没有达到发送条件</code>，那么本次<code>send</code>系统调用就会直接返回。</p></blockquote><ul><li>如果符合发送条件，则开始调用<code>tcp_write_xmit</code>内核函数。在这个函数中，会循环获取<code>Socket</code>发送队列中待发送的<code>sk_buffer</code>，然后进行<code>拥塞控制</code>以及<code>滑动窗口的管理</code>。</li><li>将从<code>Socket</code>发送队列中获取到的<code>sk_buffer</code>重新<code>拷贝一份</code>，设置<code>sk_buffer副本</code>中的<code>TCP HEADER</code>。</li></ul><blockquote><p><code>sk_buffer</code> 内部其实包含了网络协议中所有的 <code>header</code>。在设置 <code>TCP HEADER</code>的时候，只是把指针指向 <code>sk_buffer</code>的合适位置。后面再设置 <code>IP HEADER</code>的时候，在把指针移动一下就行，避免频繁的内存申请和拷贝，效率很高。</p></blockquote><figure><img src="https://picx.zhimg.com/80/v2-9f1654bfc5715e275cc0ca261fc140b1_720w.webp?source=1940ef5c" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><blockquote><p><strong>为什么不直接使用<code>Socket</code>发送队列中的<code>sk_buffer</code>而是需要拷贝一份呢？</strong> 因为<code>TCP协议</code>是支持<code>丢包重传</code>的，在没有收到对端的<code>ACK</code>之前，这个<code>sk_buffer</code>是不能删除的。内核每次调用网卡发送数据的时候，实际上传递的是<code>sk_buffer</code>的<code>拷贝副本</code>，当网卡把数据发送出去后，<code>sk_buffer</code>拷贝副本会被释放。当收到对端的<code>ACK</code>之后，<code>Socket</code>发送队列中的<code>sk_buffer</code>才会被真正删除。</p></blockquote><ul><li>当设置完<code>TCP头</code>后，内核协议栈<code>传输层</code>的事情就做完了，下面通过调用<code>ip_queue_xmit</code>内核函数，正式来到内核协议栈<code>网络层</code>的处理。 <ul><li>检查<code>Socket</code>中是否有缓存路由表，如果没有的话，则查找路由项，并缓存到<code>Socket</code>中。接着在把路由表设置到<code>sk_buffer</code>中。</li></ul></li></ul><p>通过<code>route</code>命令可以查看本机路由配置。</p><ul><li>将<code>sk_buffer</code>中的指针移动到<code>IP头</code>位置上，设置<code>IP头</code>。</li><li>执行<code>netfilters</code>过滤。过滤通过之后，如果数据大于 <code>MTU</code>的话，则执行分片。</li></ul><p>如果你使用 <code>iptables</code>配置了一些规则，那么这里将检测<code>是否命中</code>规则。 如果你设置了非常<code>复杂的 netfilter 规则</code>，在这个函数里将会导致你的线程 <code>CPU 开销</code>会<code>极大增加</code>。</p><ul><li>内核协议栈<code>网络层</code>的事情处理完后，现在发送流程进入了到了<code>邻居子系统</code>，<code>邻居子系统</code>位于内核协议栈中的<code>网络层</code>和<code>网络接口层</code>之间，用于发送<code>ARP请求</code>获取<code>MAC地址</code>，然后将<code>sk_buffer</code>中的指针移动到<code>MAC头</code>位置，填充<code>MAC头</code>。</li><li>经过<code>邻居子系统</code>的处理，现在<code>sk_buffer</code>中已经封装了一个完整的<code>数据帧</code>，随后内核将<code>sk_buffer</code>交给<code>网络设备子系统</code>进行处理。<code>网络设备子系统</code>主要做以下几项事情： <ul><li>选择发送队列（<code>RingBuffer</code>）。因为网卡拥有多个发送队列，所以在发送前需要选择一个发送队列。</li><li>将<code>sk_buffer</code>添加到发送队列中。</li><li>循环从发送队列（<code>RingBuffer</code>）中取出<code>sk_buffer</code>，调用内核函数<code>sch_direct_xmit</code>发送数据，其中会调用<code>网卡驱动程序</code>来发送数据。</li></ul></li></ul><blockquote><p>以上过程全部是用户线程的内核态在执行，占用的CPU时间是系统态时间(<code>sy</code>)，当分配给用户线程的<code>CPU quota</code>用完的时候，会触发<code>NET_TX_SOFTIRQ</code>类型的软中断，内核线程<code>ksoftirqd</code>会响应这个软中断，并执行<code>NET_TX_SOFTIRQ</code>类型的软中断注册的回调函数<code>net_tx_action</code>，在回调函数中会执行到驱动程序函数 <code>dev_hard_start_xmit</code>来发送数据。</p><p><strong>注意：当触发<code>NET_TX_SOFTIRQ</code>软中断来发送数据时，后边消耗的 CPU 就都显示在 <code>si</code>这里了，不会消耗用户进程的系统态时间（<code>sy</code>）了。</strong></p><p>从这里可以看到网络包的发送过程和接受过程是不同的，在介绍网络包的接受过程时，我们提到是通过触发<code>NET_RX_SOFTIRQ</code>类型的软中断在内核线程<code>ksoftirqd</code>中执行<code>内核网络协议栈</code>接受数据。而在网络数据包的发送过程中是<code>用户线程的内核态</code>在执行<code>内核网络协议栈</code>，只有当线程的<code>CPU quota</code>用尽时，才触发<code>NET_TX_SOFTIRQ</code>软中断来发送数据。</p><p>在整个网络包的发送和接受过程中，<code>NET_TX_SOFTIRQ</code>类型的<a href="https://www.zhihu.com/search?q=%E8%BD%AF%E4%B8%AD%E6%96%AD&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2305464768%7D" target="_blank" rel="noopener noreferrer">软中断<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>只会在发送网络包时并且当用户线程的<code>CPU quota</code>用尽时，才会触发。剩下的接受过程中触发的软中断类型以及发送完数据触发的软中断类型均为<code>NET_RX_SOFTIRQ</code>。 所以这就是你在服务器上查看 <code>/proc/softirqs</code>，一般 <code>NET_RX</code>都要比 <code>NET_TX</code>大很多的的原因。</p></blockquote><ul><li>现在发送流程终于到了网卡真实发送数据的阶段，前边我们讲到无论是用户线程的内核态还是触发<code>NET_TX_SOFTIRQ</code>类型的软中断在发送数据的时候最终会调用到网卡的驱动程序函数<code>dev_hard_start_xmit</code>来发送数据。在网卡驱动程序函数<code>dev_hard_start_xmit</code>中会将<code>sk_buffer</code>映射到网卡可访问的<code>内存 DMA 区域</code>，最终网卡驱动程序通过<code>DMA</code>的方式将<code>数据帧</code>通过物理网卡发送出去。</li><li>当数据发送完毕后，还有最后一项重要的工作，就是清理工作。数据发送完毕后，网卡设备会向<code>CPU</code>发送一个硬中断，<code>CPU</code>调用网卡驱动程序注册的<code>硬中断响应程序</code>，在硬中断响应中触发<code>NET_RX_SOFTIRQ</code>类型的软中断，在软中断的回调函数<code>igb_poll</code>中清理释放 <code>sk_buffer</code>，清理<code>网卡</code>发送队列（<code>RingBuffer</code>），解除 DMA 映射。</li></ul><blockquote><p>无论<code>硬中断</code>是因为<code>有数据要接收</code>，还是说<code>发送完成通知</code>，从硬中断触发的软中断都是 <code>NET_RX_SOFTIRQ</code>。</p><p>这里释放清理的只是<code>sk_buffer</code>的副本，真正的<code>sk_buffer</code>现在还是存放在<code>Socket</code>的发送队列中。前面在<code>传输层</code>处理的时候我们提到过，因为传输层需要<code>保证可靠性</code>，所以 <code>sk_buffer</code>其实还没有删除。它得等收到对方的 ACK 之后才会真正删除。</p></blockquote><h2 id="性能开销-1" tabindex="-1"><a class="header-anchor" href="#性能开销-1" aria-hidden="true">#</a> <strong>性能开销</strong></h2><p>前边我们提到了在网络包接收过程中涉及到的性能开销，现在介绍完了网络包的发送过程，我们来看下在数据包发送过程中的性能开销：</p><ul><li>和接收数据一样，应用程序在调用<code>系统调用send</code>的时候会从<code>用户态</code>转为<code>内核态</code>以及发送完数据后，<code>系统调用</code>返回时从<code>内核态</code>转为<code>用户态</code>的开销。</li><li>用户线程内核态<code>CPU quota</code>用尽时触发<code>NET_TX_SOFTIRQ</code>类型软中断，内核响应软中断的开销。</li><li>网卡发送完数据，向<code>CPU</code>发送硬中断，<code>CPU</code>响应硬中断的开销。以及在硬中断中发送<code>NET_RX_SOFTIRQ</code>软中断执行具体的内存清理动作。内核响应软中断的开销。</li><li>内存拷贝的开销。我们来回顾下在数据包发送的过程中都发生了哪些内存拷贝： <ul><li>在内核协议栈的传输层中，<code>TCP协议</code>对应的发送函数<code>tcp_sendmsg</code>会申请<code>sk_buffer</code>，将用户要发送的数据<code>拷贝</code>到<code>sk_buffer</code>中。</li><li>在发送流程从传输层到网络层的时候，会<code>拷贝</code>一个<code>sk_buffer副本</code>出来，将这个<code>sk_buffer副本</code>向下传递。原始<code>sk_buffer</code>保留在<code>Socket</code>发送队列中，等待网络对端<code>ACK</code>，对端<code>ACK</code>后删除<code>Socket</code>发送队列中的<code>sk_buffer</code>。对端没有发送<code>ACK</code>，则重新从<code>Socket</code>发送队列中发送，实现<code>TCP协议</code>的可靠传输。</li><li>在网络层，如果发现要发送的数据大于<code>MTU</code>，则会进行分片操作，申请额外的<code>sk_buffer</code>，并将原来的sk_buffer<code>拷贝</code>到多个小的sk_buffer中。</li></ul></li></ul><h2 id="再谈-阻塞-非阻塞-与-同步-异步" tabindex="-1"><a class="header-anchor" href="#再谈-阻塞-非阻塞-与-同步-异步" aria-hidden="true">#</a> <strong>再谈(阻塞，非阻塞)与(同步，异步)</strong></h2><p>在我们聊完网络数据的接收和发送过程后，我们来谈下IO中特别容易混淆的概念：<code>阻塞与同步</code>，<code>非阻塞与异步</code>。</p><p>网上各种博文还有各种书籍中有大量的关于这两个概念的解释，但是笔者觉得还是不够形象化，只是对概念的生硬解释，如果硬套概念的话，其实感觉<code>阻塞与同步</code>，<code>非阻塞与异步</code>还是没啥区别，时间长了，还是比较模糊容易混淆。</p><p>所以笔者在这里尝试换一种更加形象化，更加容易理解记忆的方式来清晰地解释下什么是<code>阻塞与非阻塞</code>，什么是<code>同步与异步</code>。</p><p>经过前边对网络数据包接收流程的介绍，在这里我们可以将整个流程总结为两个阶段：</p><figure><img src="/assets/v2-6b4f4b9969a88660f4a74a7ff88657df_720w-CDosHvSZ.webp" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ul><li><strong>数据准备阶段：</strong> 在这个阶段，网络数据包到达网卡，通过<code>DMA</code> 的方式将数据包拷贝到内存中，然后经过硬中断，软中断，接着通过内核线程<code>ksoftirqd</code>经过内核协议栈的处理，最终将数据发送到<code>内核Socket</code>的接收缓冲区中。</li><li><strong>数据拷贝阶段：</strong> 当数据到达<code>内核Socket</code>的接收缓冲区中时，此时数据存在于<code>内核空间</code>中，需要将数据<code>拷贝</code>到<code>用户空间</code>中，才能够被应用程序读取。</li></ul><h2 id="阻塞与非阻塞-1" tabindex="-1"><a class="header-anchor" href="#阻塞与非阻塞-1" aria-hidden="true">#</a> <strong>阻塞与非阻塞</strong></h2><p>阻塞与非阻塞的区别主要发生在第一阶段：<code>数据准备阶段</code>。</p><p>当应用程序发起<code>系统调用read</code>时，线程从用户态转为内核态，读取内核<code>Socket</code>的接收缓冲区中的网络数据。</p><h3 id="阻塞-1" tabindex="-1"><a class="header-anchor" href="#阻塞-1" aria-hidden="true">#</a> <strong>阻塞</strong></h3><p>如果这时内核<code>Socket</code>的接收缓冲区没有数据，那么线程就会一直<code>等待</code>，直到<code>Socket</code>接收缓冲区有数据为止。随后将数据从内核空间拷贝到用户空间，<code>系统调用read</code>返回。</p><figure><img src="/assets/v2-bc3efc14ed2a97c01f46fcaf0216f710_720w-75srX2WC.webp" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>从图中我们可以看出：<strong>阻塞</strong>的特点是在第一阶段和第二阶段<code>都会等待</code>。</p><h3 id="非阻塞-1" tabindex="-1"><a class="header-anchor" href="#非阻塞-1" aria-hidden="true">#</a> <strong>非阻塞</strong></h3><p><code>阻塞</code>和<code>非阻塞</code>主要的区分是在第一阶段：<code>数据准备阶段</code>。</p><ul><li>在第一阶段，当<code>Socket</code>的接收缓冲区中没有数据的时候，<code>阻塞模式下</code>应用线程会一直等待。<code>非阻塞模式下</code>应用线程不会等待，<code>系统调用</code>直接返回错误标志<code>EWOULDBLOCK</code>。</li><li>当<code>Socket</code>的接收缓冲区中有数据的时候，<code>阻塞</code>和<code>非阻塞</code>的表现是一样的，都会进入第二阶段<code>等待</code>数据从<code>内核空间</code>拷贝到<code>用户空间</code>，然后<code>系统调用返回</code>。</li></ul><figure><img src="/assets/v2-82a61df046de31add3c1a68a1c5a7406_720w-xvzyN7mQ.webp" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>从上图中，我们可以看出：<strong>非阻塞</strong>的特点是第一阶段<code>不会等待</code>，但是在第二阶段还是会<code>等待</code>。</p><h2 id="同步与异步-1" tabindex="-1"><a class="header-anchor" href="#同步与异步-1" aria-hidden="true">#</a> <strong>同步与异步</strong></h2><p><code>同步</code>与<code>异步</code>主要的区别发生在第二阶段：<code>数据拷贝阶段</code>。</p><p>前边我们提到在<code>数据拷贝阶段</code>主要是将数据从<code>内核空间</code>拷贝到<code>用户空间</code>。然后应用程序才可以读取数据。</p><p>当内核<code>Socket</code>的接收缓冲区有数据到达时，进入第二阶段。</p><h3 id="同步-1" tabindex="-1"><a class="header-anchor" href="#同步-1" aria-hidden="true">#</a> <strong>同步</strong></h3><p><code>同步模式</code>在数据准备好后，是由<code>用户线程</code>的<code>内核态</code>来执行<code>第二阶段</code>。所以应用程序会在第二阶段发生<code>阻塞</code>，直到数据从<code>内核空间</code>拷贝到<code>用户空间</code>，系统调用才会返回。</p><p>Linux下的 <code>epoll</code>和Mac 下的 <code>kqueue</code>都属于<code>同步 IO</code>。</p><figure><img src="/assets/v2-597111a5a02c723f1e0bef57e30809ef_720w-7U03hxnH.webp" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="异步-1" tabindex="-1"><a class="header-anchor" href="#异步-1" aria-hidden="true">#</a> <strong>异步</strong></h3><p><code>异步模式</code>下是由<code>内核</code>来执行第二阶段的数据拷贝操作，当<code>内核</code>执行完第二阶段，会通知用户线程IO操作已经完成，并将数据回调给用户线程。所以在<code>异步模式</code>下 <code>数据准备阶段</code>和<code>数据拷贝阶段</code>均是由<code>内核</code>来完成，不会对应用程序造成任何阻塞。</p><p>基于以上特征，我们可以看到<code>异步模式</code>需要内核的支持，比较依赖操作系统底层的支持。</p><p>在目前流行的操作系统中，只有Windows 中的 <code>IOCP</code>才真正属于异步 IO，实现的也非常成熟。但Windows很少用来作为服务器使用。</p><p>而常用来作为服务器使用的Linux，<code>异步IO机制</code>实现的不够成熟，与NIO相比性能提升的也不够明显。</p><p>但Linux kernel 在5.1版本由Facebook的大神Jens Axboe引入了新的异步IO库<code>io_uring</code> 改善了原来Linux native AIO的一些性能问题。性能相比<code>Epoll</code>以及之前原生的<code>AIO</code>提高了不少，值得关注。</p><figure><img src="/assets/v2-5b81acbcda49fdee380bcc6eea6ede73_720w-tcbxKvqE.webp" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h2 id="io模型" tabindex="-1"><a class="header-anchor" href="#io模型" aria-hidden="true">#</a> <strong>IO模型</strong></h2><p>在进行网络IO操作时，用什么样的IO模型来读写数据将在很大程度上决定了网络框架的IO性能。所以IO模型的选择是构建一个高性能网络框架的基础。</p><p>在《UNIX 网络编程》一书中介绍了五种IO模型：<code>阻塞IO</code>,<code>非阻塞IO</code>,<code>IO多路复用</code>,<code>信号驱动IO</code>,<code>异步IO</code>，每一种IO模型的出现都是对前一种的升级优化。</p><p>下面我们就来分别介绍下这五种IO模型各自都解决了什么问题，适用于哪些场景，各自的优缺点是什么？</p><h2 id="阻塞io-bio" tabindex="-1"><a class="header-anchor" href="#阻塞io-bio" aria-hidden="true">#</a> <strong>阻塞IO（BIO）</strong></h2><figure><img src="/assets/v2-bc3efc14ed2a97c01f46fcaf0216f710_720w-75srX2WC.webp" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>经过前一小节对<code>阻塞</code>这个概念的介绍，相信大家可以很容易理解<code>阻塞IO</code>的概念和过程。</p><p>既然这小节我们谈的是<code>IO</code>，那么下边我们来看下在<code>阻塞IO</code>模型下，网络数据的读写过程。</p><h3 id="阻塞读" tabindex="-1"><a class="header-anchor" href="#阻塞读" aria-hidden="true">#</a> <strong>阻塞读</strong></h3><p>当用户线程发起<code>read</code>系统调用，用户线程从用户态切换到内核态，在内核中去查看<code>Socket</code>接收缓冲区是否有数据到来。</p><ul><li><code>Socket</code>接收缓冲区中<code>有数据</code>，则用户线程在内核态将内核空间中的数据拷贝到用户空间，系统IO调用返回。</li><li><code>Socket</code>接收缓冲区中<code>无数据</code>，则用户线程让出CPU，进入<code>阻塞状态</code>。当数据到达<code>Socket</code>接收缓冲区后，内核唤醒<code>阻塞状态</code>中的用户线程进入<code>就绪状态</code>，随后经过CPU的调度获取到<code>CPU quota</code>进入<code>运行状态</code>，将内核空间的数据拷贝到用户空间，随后系统调用返回。</li></ul><h3 id="阻塞写" tabindex="-1"><a class="header-anchor" href="#阻塞写" aria-hidden="true">#</a> <strong>阻塞写</strong></h3><p>当用户线程发起<code>send</code>系统调用时，用户线程从用户态切换到内核态，将发送数据从用户空间拷贝到内核空间中的<code>Socket</code>发送缓冲区中。</p><ul><li>当<code>Socket</code>发送缓冲区能够容纳下发送数据时，用户线程会将全部的发送数据写入<code>Socket</code>缓冲区，然后执行在《网络包发送流程》这小节介绍的后续流程，然后返回。</li><li>当<code>Socket</code>发送缓冲区空间不够，无法容纳下全部发送数据时，用户线程让出CPU,进入<code>阻塞状态</code>，直到<code>Socket</code>发送缓冲区能够容纳下全部发送数据时，内核唤醒用户线程，执行后续发送流程。</li></ul><p><code>阻塞IO</code>模型下的写操作做事风格比较硬刚，非得要把全部的发送数据写入发送缓冲区才肯善罢甘休。</p><h2 id="阻塞io模型" tabindex="-1"><a class="header-anchor" href="#阻塞io模型" aria-hidden="true">#</a> <strong>阻塞IO模型</strong></h2><figure><img src="/assets/v2-ef420eb131bc1905146a3050d26b7f68_720w-0FqNNBSi.webp" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>由于<code>阻塞IO</code>的读写特点，所以导致在<code>阻塞IO</code>模型下，每个请求都需要被一个独立的线程处理。一个线程在同一时刻只能与一个连接绑定。来一个请求，服务端就需要创建一个线程用来处理请求。</p><p>当客户端请求的并发量突然增大时，服务端在一瞬间就会创建出大量的线程，而创建线程是需要系统资源开销的，这样一来就会一瞬间占用大量的系统资源。</p><p>如果客户端创建好连接后，但是一直不发数据，通常大部分情况下，网络连接也<code>并不</code>总是有数据可读，那么在空闲的这段时间内，服务端线程就会一直处于<code>阻塞状态</code>，无法干其他的事情。CPU也<code>无法得到充分的发挥</code>，同时还会<code>导致大量线程切换的开销</code>。</p><h2 id="适用场景" tabindex="-1"><a class="header-anchor" href="#适用场景" aria-hidden="true">#</a> <strong>适用场景</strong></h2><p>基于以上<code>阻塞IO模型</code>的特点，该模型只适用于<code>连接数少</code>，<code>并发度低</code>的业务场景。</p><p>比如公司内部的一些管理系统，通常请求数在100个左右，使用<code>阻塞IO模型</code>还是非常适合的。而且性能还不输NIO。</p><p>该模型在C10K之前，是普遍被采用的一种IO模型。</p><h2 id="非阻塞io-nio" tabindex="-1"><a class="header-anchor" href="#非阻塞io-nio" aria-hidden="true">#</a> <strong>非阻塞IO（NIO）</strong></h2><p><code>阻塞IO模型</code>最大的问题就是一个线程只能处理一个连接，如果这个连接上没有数据的话，那么这个线程就只能阻塞在系统IO调用上，不能干其他的事情。这对系统资源来说，是一种极大的浪费。同时大量的线程上下文切换，也是一个巨大的系统开销。</p><p>所以为了解决这个问题，<strong>我们就需要用尽可能少的线程去处理更多的连接。</strong>，<code>网络IO模型的演变</code>也是根据这个需求来一步一步演进的。</p><p>基于这个需求，第一种解决方案<code>非阻塞IO</code>就出现了。我们在上一小节中介绍了<code>非阻塞</code>的概念，现在我们来看下网络读写操作在<code>非阻塞IO</code>下的特点：</p><figure><img src="/assets/v2-82a61df046de31add3c1a68a1c5a7406_720w-xvzyN7mQ.webp" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="非阻塞读" tabindex="-1"><a class="header-anchor" href="#非阻塞读" aria-hidden="true">#</a> <strong>非阻塞读</strong></h3><p>当用户线程发起非阻塞<code>read</code>系统调用时，用户线程从<code>用户态</code>转为<code>内核态</code>，在内核中去查看<code>Socket</code>接收缓冲区是否有数据到来。</p><ul><li><code>Socket</code>接收缓冲区中<code>无数据</code>，系统调用立马返回，并带有一个 <code>EWOULDBLOCK</code> 或 <code>EAGAIN</code>错误，这个阶段用户线程<code>不会阻塞</code>，也<code>不会让出CPU</code>，而是会继续<code>轮训</code>直到<code>Socket</code>接收缓冲区中有数据为止。</li><li><code>Socket</code>接收缓冲区中<code>有数据</code>，用户线程在<code>内核态</code>会将<code>内核空间</code>中的数据拷贝到<code>用户空间</code>，<strong>注意</strong>这个数据拷贝阶段，应用程序是<code>阻塞的</code>，当数据拷贝完成，系统调用返回。</li></ul><h3 id="非阻塞写" tabindex="-1"><a class="header-anchor" href="#非阻塞写" aria-hidden="true">#</a> <strong>非阻塞写</strong></h3><p>前边我们在介绍<code>阻塞写</code>的时候提到<code>阻塞写</code>的风格特别的硬朗，头比较铁非要把全部发送数据一次性都写到<code>Socket</code>的发送缓冲区中才返回，如果发送缓冲区中没有足够的空间容纳，那么就一直阻塞死等，特别的刚。</p><p>相比较而言<code>非阻塞写</code>的特点就比较佛系，当发送缓冲区中没有足够的空间容纳全部发送数据时，<code>非阻塞写</code>的特点是<code>能写多少写多少</code>，写不下了，就立即返回。并将写入到发送缓冲区的字节数返回给应用程序，方便用户线程不断的<code>轮训</code>尝试将<code>剩下的数据</code>写入发送缓冲区中。</p><h2 id="非阻塞io模型" tabindex="-1"><a class="header-anchor" href="#非阻塞io模型" aria-hidden="true">#</a> <strong>非阻塞IO模型</strong></h2><figure><img src="/assets/v2-db7d267fe82e765550690c1cfaa10124_720w-88C3lENE.webp" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>基于以上<code>非阻塞IO</code>的特点，我们就不必像<code>阻塞IO</code>那样为每个请求分配一个线程去处理连接上的读写了。</p><p>我们可以利用<strong>一个线程或者很少的线程</strong>，去<code>不断地轮询</code>每个<code>Socket</code>的接收缓冲区是否有数据到达，如果没有数据，<code>不必阻塞</code>线程，而是接着去<code>轮询</code>下一个<code>Socket</code>接收缓冲区，直到轮询到数据后，处理连接上的读写，或者交给业务线程池去处理，轮询线程则<code>继续轮询</code>其他的<code>Socket</code>接收缓冲区。</p><p>这样一个<code>非阻塞IO模型</code>就实现了我们在本小节开始提出的需求：<strong>我们需要用尽可能少的线程去处理更多的连接</strong></p><h2 id="适用场景-1" tabindex="-1"><a class="header-anchor" href="#适用场景-1" aria-hidden="true">#</a> <strong>适用场景</strong></h2><p>虽然<code>非阻塞IO模型</code>与<code>阻塞IO模型</code>相比，减少了很大一部分的资源消耗和系统开销。</p><p>但是它仍然有很大的性能问题，因为在<code>非阻塞IO模型</code>下，需要用户线程去<code>不断地</code>发起<code>系统调用</code>去轮训<code>Socket</code>接收缓冲区，这就需要用户线程不断地从<code>用户态</code>切换到<code>内核态</code>，<code>内核态</code>切换到<code>用户态</code>。随着并发量的增大，这个上下文切换的开销也是巨大的。</p><p>所以单纯的<code>非阻塞IO</code>模型还是无法适用于高并发的场景。只能适用于<code>C10K</code>以下的场景。</p><h2 id="io多路复用" tabindex="-1"><a class="header-anchor" href="#io多路复用" aria-hidden="true">#</a> <strong>IO多路复用</strong></h2><p>在<code>非阻塞IO</code>这一小节的开头，我们提到<code>网络IO模型</code>的演变都是围绕着---<strong>如何用尽可能少的线程去处理更多的连接</strong>这个核心需求开始展开的。</p><p>本小节我们来谈谈<code>IO多路复用模型</code>，那么什么是<code>多路</code>？，什么又是<code>复用</code>呢？</p><p>我们还是以这个核心需求来对这两个概念展开阐述：</p><ul><li><strong>多路</strong>：我们的核心需求是要用尽可能少的线程来处理尽可能多的连接，这里的<code>多路</code>指的就是我们需要处理的众多连接。</li><li><strong>复用</strong>：核心需求要求我们使用<code>尽可能少的线程</code>，<code>尽可能少的系统开销</code>去处理<code>尽可能多</code>的连接（<code>多路</code>），那么这里的<code>复用</code>指的就是用<code>有限的资源</code>，比如用一个线程或者固定数量的线程去处理众多连接上的读写事件。换句话说，在<code>阻塞IO模型</code>中一个连接就需要分配一个独立的线程去专门处理这个连接上的读写，到了<code>IO多路复用模型</code>中，多个连接可以<code>复用</code>这一个独立的线程去处理这多个连接上的读写。</li></ul><p>好了，<code>IO多路复用模型</code>的概念解释清楚了，那么<strong>问题的关键</strong>是我们如何去实现这个<code>复用</code>，也就是如何让一个独立的线程去处理众多连接上的读写事件呢？</p><p>这个问题其实在<code>非阻塞IO模型</code>中已经给出了它的答案，在<code>非阻塞IO模型</code>中，利用<code>非阻塞</code>的系统IO调用去不断的轮询众多连接的<code>Socket</code>接收缓冲区看是否有数据到来，如果有则处理，如果没有则继续轮询下一个<code>Socket</code>。这样就达到了用一个线程去处理众多连接上的读写事件了。</p><p><strong>但是</strong><code>非阻塞IO模型</code>最大的问题就是需要不断的发起<code>系统调用</code>去轮询各个<code>Socket</code>中的接收缓冲区是否有数据到来，<code>频繁</code>的<code>系统调用</code>随之带来了大量的上下文切换开销。随着并发量的提升，这样也会导致非常严重的性能问题。</p><p><strong>那么如何避免频繁的系统调用同时又可以实现我们的核心需求呢？</strong></p><p>这就需要操作系统的内核来支持这样的操作，我们可以把频繁的轮询操作交给操作系统内核来替我们完成，这样就避免了在<code>用户空间</code>频繁的去使用系统调用来轮询所带来的性能开销。</p><p>正如我们所想，操作系统内核也确实为我们提供了这样的功能实现，下面我们来一起看下操作系统对<code>IO多路复用模型</code>的实现。</p><h2 id="select" tabindex="-1"><a class="header-anchor" href="#select" aria-hidden="true">#</a> <strong>select</strong></h2><p><code>select</code>是操作系统内核提供给我们使用的一个<code>系统调用</code>，它解决了在<code>非阻塞IO模型</code>中需要不断的发起<code>系统IO调用</code>去轮询<code>各个连接上的Socket</code>接收缓冲区所带来的<code>用户空间</code>与<code>内核空间</code>不断切换的<code>系统开销</code>。</p><p><code>select</code>系统调用将<code>轮询</code>的操作交给了<code>内核</code>来帮助我们完成，从而避免了在<code>用户空间</code>不断的发起轮询所带来的的系统性能开销。</p><figure><img src="/assets/v2-6339d5b8dc57fa7f1bdbab9c0733d90b_720w-hj7mukxg.webp" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ul><li>首先用户线程在发起<code>select</code>系统调用的时候会<code>阻塞</code>在<code>select</code>系统调用上。此时，用户线程从<code>用户态</code>切换到了<code>内核态</code>完成了一次<code>上下文切换</code></li><li>用户线程将需要监听的<code>Socket</code>对应的文件描述符<code>fd</code>数组通过<code>select</code>系统调用传递给内核。此时，用户线程将<code>用户空间</code>中的文件描述符<code>fd</code>数组<code>拷贝</code>到<code>内核空间</code>。</li></ul><p>这里的<strong>文件描述符数组</strong>其实是一个<code>BitMap</code>，<code>BitMap</code>下标为<code>文件描述符fd</code>，下标对应的值为：<code>1</code>表示该<code>fd</code>上有读写事件，<code>0</code>表示该<code>fd</code>上没有读写事件。</p><figure><img src="/assets/v2-87037cda610c87f03dc348b6564b726d_720w-JPu3oPWC.webp" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><strong>文件描述符fd</strong>其实就是一个<code>整数值</code>，在Linux中一切皆文件，<code>Socket</code>也是一个文件。描述进程所有信息的数据结构<code>task_struct</code>中有一个属性<code>struct files_struct *files</code>，它最终指向了一个数组，数组里存放了进程打开的所有文件列表，文件信息封装在<code>struct file</code>结构体中，这个数组存放的类型就是 <code>struct file</code>结构体，<code>数组的下标</code>则是我们常说的文件描述符<code>fd</code>。</p><ul><li>当用户线程调用完<code>select</code>后开始进入<code>阻塞状态</code>，<code>内核</code>开始轮询遍历<code>fd</code>数组，查看<code>fd</code>对应的<code>Socket</code>接收缓冲区中是否有数据到来。如果有数据到来，则将<code>fd</code>对应<code>BitMap</code>的值设置为<code>1</code>。如果没有数据到来，则保持值为<code>0</code>。</li></ul><blockquote><p><strong>注意</strong>这里内核会修改原始的<code>fd</code>数组！！</p></blockquote><ul><li>内核遍历一遍<code>fd</code>数组后，如果发现有些<code>fd</code>上有IO数据到来，则将修改后的<code>fd</code>数组返回给用户线程。此时，会将<code>fd</code>数组从<code>内核空间</code>拷贝到<code>用户空间</code>。</li><li>当内核将修改后的<code>fd</code>数组返回给用户线程后，用户线程解除<code>阻塞</code>，由用户线程开始遍历<code>fd</code>数组然后找出<code>fd</code>数组中值为<code>1</code>的<code>Socket</code>文件描述符。最后对这些<code>Socket</code>发起系统调用读取数据。</li></ul><blockquote><p><code>select</code>不会告诉用户线程具体哪些<code>fd</code>上有IO数据到来，只是在<code>IO活跃</code>的<code>fd</code>上打上标记，将打好标记的完整<code>fd</code>数组返回给用户线程，所以用户线程还需要遍历<code>fd</code>数组找出具体哪些<code>fd</code>上有<code>IO数据</code>到来。</p></blockquote><ul><li>由于内核在遍历的过程中已经修改了<code>fd</code>数组，所以在用户线程遍历完<code>fd</code>数组后获取到<code>IO就绪</code>的<code>Socket</code>后，就需要<code>重置</code>fd数组，并重新调用<code>select</code>传入重置后的<code>fd</code>数组，让内核发起新的一轮遍历轮询。</li></ul><h3 id="api介绍" tabindex="-1"><a class="header-anchor" href="#api介绍" aria-hidden="true">#</a> <strong>API介绍</strong></h3><p>当我们熟悉了<code>select</code>的原理后，就很容易理解内核给我们提供的<code>select API</code>了。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code> int select(int maxfdp1,fd_set *readset,fd_set *writeset,fd_set *exceptset,const struct timeval *timeout)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>从<code>select API</code>中我们可以看到，<code>select</code>系统调用是在规定的<code>超时时间内</code>，监听（<code>轮询</code>）用户感兴趣的文件描述符集合上的<code>可读</code>,<code>可写</code>,<code>异常</code>三类事件。</p><ul><li><code>maxfdp1 ：</code> select传递给内核监听的文件描述符集合中数值最大的文件描述符<code>+1</code>，目的是用于限定内核遍历范围。比如：<code>select</code>监听的文件描述符集合为<code>{0,1,2,3,4}</code>，那么<code>maxfdp1</code>的值为<code>5</code>。</li><li><code>fd_set *readset：</code> 对<code>可读事件</code>感兴趣的文件描述符集合。</li><li><code>fd_set *writeset：</code> 对<code>可写事件</code>感兴趣的文件描述符集合。</li><li><code>fd_set *exceptset：</code>对<code>可写事件</code>感兴趣的文件描述符集合。</li></ul><blockquote><p>这里的<code>fd_set</code>就是我们前边提到的<code>文件描述符数组</code>，是一个<code>BitMap</code>结构。</p></blockquote><ul><li><code>const struct timeval *timeout：</code>select系统调用超时时间，在这段时间内，内核如果没有发现有<code>IO就绪</code>的文件描述符，就直接返回。</li></ul><p>上小节提到，在<code>内核</code>遍历完<code>fd</code>数组后，发现有<code>IO就绪</code>的<code>fd</code>，则会将该<code>fd</code>对应的<code>BitMap</code>中的值设置为<code>1</code>，并将修改后的<code>fd</code>数组，返回给用户线程。</p><p>在用户线程中需要重新遍历<code>fd</code>数组，找出<code>IO就绪</code>的<code>fd</code>出来，然后发起真正的读写调用。</p><p>下面介绍下在用户线程中重新遍历<code>fd</code>数组的过程中，我们需要用到的<code>API</code>：</p><ul><li><code>void FD_ZERO(fd_set *fdset)：</code>清空指定的文件描述符集合，即让<code>fd_set</code>中不在包含任何文件描述符。</li><li><code>void FD_SET(int fd, fd_set *fdset)：</code>将一个给定的文件描述符加入集合之中。</li></ul><blockquote><p>每次调用<code>select</code>之前都要通过<code>FD_ZERO</code>和<code>FD_SET</code>重新设置文件描述符，因为文件描述符集合会在<code>内核</code>中<code>被修改</code>。</p></blockquote><ul><li><code>int FD_ISSET(int fd, fd_set *fdset)：</code>检查集合中指定的文件描述符是否可以读写。用户线程<code>遍历</code>文件描述符集合,调用该方法检查相应的文件描述符是否<code>IO就绪</code>。</li><li><code>void FD_CLR(int fd, fd_set *fdset)：</code>将一个给定的文件描述符从集合中删除</li></ul><h3 id="性能开销-2" tabindex="-1"><a class="header-anchor" href="#性能开销-2" aria-hidden="true">#</a> <strong>性能开销</strong></h3><p>虽然<code>select</code>解决了<code>非阻塞IO模型</code>中频繁发起<code>系统调用</code>的问题，但是在整个<code>select</code>工作过程中，我们还是看出了<code>select</code>有些不足的地方。</p><ul><li>在发起<code>select</code>系统调用以及返回时，用户线程各发生了一次<code>用户态</code>到<code>内核态</code>以及<code>内核态</code>到<code>用户态</code>的上下文切换开销。<strong>发生2次上下文<code>切换</code></strong></li><li>在发起<code>select</code>系统调用以及返回时，用户线程在<code>内核态</code>需要将<code>文件描述符集合</code>从用户空间<code>拷贝</code>到内核空间。以及在内核修改完<code>文件描述符集合</code>后，又要将它从内核空间<code>拷贝</code>到用户空间。<strong>发生2次文件描述符集合的<code>拷贝</code></strong></li><li>虽然由原来在<code>用户空间</code>发起轮询<code>优化成了</code>在<code>内核空间</code>发起轮询但<code>select</code>不会告诉用户线程到底是哪些<code>Socket</code>上发生了<code>IO就绪</code>事件，只是对<code>IO就绪</code>的<code>Socket</code>作了标记，用户线程依然要<code>遍历</code>文件描述符集合去查找具体<code>IO就绪</code>的<code>Socket</code>。时间复杂度依然为<code>O(n)</code>。</li></ul><blockquote><p>大部分情况下，网络连接并不总是活跃的，如果<code>select</code>监听了大量的客户端连接，只有少数的连接活跃，然而使用轮询的这种方式会随着连接数的增大，效率会越来越低。</p></blockquote><ul><li><code>内核</code>会对原始的<code>文件描述符集合</code>进行修改。导致每次在用户空间重新发起<code>select</code>调用时，都需要对<code>文件描述符集合</code>进行<code>重置</code>。</li><li><code>BitMap</code>结构的文件描述符集合，长度为固定的<code>1024</code>,所以只能监听<code>0~1023</code>的文件描述符。</li><li><code>select</code>系统调用 不是线程安全的。</li></ul><p>以上<code>select</code>的不足所产生的<code>性能开销</code>都会随着并发量的增大而<code>线性增长</code>。</p><p>很明显<code>select</code>也不能解决<code>C10K</code>问题，只适用于<code>1000</code>个左右的并发连接场景。</p><h2 id="poll" tabindex="-1"><a class="header-anchor" href="#poll" aria-hidden="true">#</a> <strong>poll</strong></h2><p><code>poll</code>相当于是改进版的<code>select</code>，但是工作原理基本和<code>select</code>没有本质的区别。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>int poll(struct pollfd *fds, unsigned int nfds, int timeout)

struct pollfd {
    int   fd;         /* 文件描述符 */
    short events;     /* 需要监听的事件 */
    short revents;    /* 实际发生的事件 由内核修改设置 */
};
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>select</code>中使用的文件描述符集合是采用的固定长度为1024的<code>BitMap</code>结构的<code>fd_set</code>，而<code>poll</code>换成了一个<code>pollfd</code>结构没有固定长度的数组，这样就没有了最大描述符数量的限制（当然还会受到系统文件描述符限制）</p><p><code>poll</code>只是改进了<code>select</code>只能监听<code>1024</code>个文件描述符的数量限制，但是并没有在性能方面做出改进。和<code>select</code>上本质并没有多大差别。</p><ul><li>同样需要在<code>内核空间</code>和<code>用户空间</code>中对文件描述符集合进行<code>轮询</code>，查找出<code>IO就绪</code>的<code>Socket</code>的时间复杂度依然为<code>O(n)</code>。</li><li>同样需要将<code>包含大量文件描述符的集合</code>整体在<code>用户空间</code>和<code>内核空间</code>之间<code>来回复制</code>，<strong>无论这些文件描述符是否就绪</strong>。他们的开销都会随着文件描述符数量的增加而线性增大。</li><li><code>select，poll</code>在每次新增，删除需要监听的socket时，都需要将整个新的<code>socket</code>集合全量传至<code>内核</code>。</li></ul><p><code>poll</code>同样不适用高并发的场景。依然无法解决<code>C10K</code>问题。</p><h2 id="epoll" tabindex="-1"><a class="header-anchor" href="#epoll" aria-hidden="true">#</a> <strong>epoll</strong></h2><p>通过上边对<code>select,poll</code>核心原理的介绍，我们看到<code>select,poll</code>的性能瓶颈主要体现在下面三个地方：</p><ul><li>因为内核不会保存我们要监听的<code>socket</code>集合，所以在每次调用<code>select,poll</code>的时候都需要传入，传出全量的<code>socket</code>文件描述符集合。这导致了大量的文件描述符在<code>用户空间</code>和<code>内核空间</code>频繁的来回复制。</li><li>由于内核不会通知具体<code>IO就绪</code>的<code>socket</code>，只是在这些<code>IO就绪</code>的socket上打好标记，所以当<code>select</code>系统调用返回时，在<code>用户空间</code>还是需要<code>完整遍历</code>一遍<code>socket</code>文件描述符集合来获取具体<code>IO就绪</code>的<code>socket</code>。</li><li>在<code>内核空间</code>中也是通过遍历的方式来得到<code>IO就绪</code>的<code>socket</code>。</li></ul><p>下面我们来看下<code>epoll</code>是如何解决这些问题的。在介绍<code>epoll</code>的核心原理之前，我们需要介绍下理解<code>epoll</code>工作过程所需要的一些核心基础知识。</p><h3 id="socket的创建" tabindex="-1"><a class="header-anchor" href="#socket的创建" aria-hidden="true">#</a> <strong>Socket的创建</strong></h3><p>服务端线程调用<code>accept</code>系统调用后开始<code>阻塞</code>，当有客户端连接上来并完成<code>TCP三次握手</code>后，<code>内核</code>会创建一个对应的<code>Socket</code>作为服务端与客户端通信的<code>内核</code>接口。</p><p>在Linux内核的角度看来，一切皆是文件，<code>Socket</code>也不例外，当内核创建出<code>Socket</code>之后，会将这个<code>Socket</code>放到当前进程所打开的文件列表中管理起来。</p><p>下面我们来看下进程管理这些打开的文件列表相关的内核数据结构是什么样的？在了解完这些数据结构后，我们会更加清晰的理解<code>Socket</code>在内核中所发挥的作用。并且对后面我们理解<code>epoll</code>的创建过程有很大的帮助。</p><h3 id="进程中管理文件列表结构" tabindex="-1"><a class="header-anchor" href="#进程中管理文件列表结构" aria-hidden="true">#</a> <strong>进程中管理文件列表结构</strong></h3><figure><img src="/assets/v2-4da3d511c1efacfdd0f6e1340c14fee9_720w-L6cajjXk.webp" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><code>struct tast_struct</code>是内核中用来表示进程的一个数据结构，它包含了进程的所有信息。本小节我们只列出和文件管理相关的属性。</p><p>其中进程内打开的所有文件是通过一个数组<code>fd_array</code>来进行组织管理，数组的下标即为我们常提到的<code>文件描述符</code>，数组中存放的是对应的文件数据结构<code>struct file</code>。每打开一个文件，内核都会创建一个<code>struct file</code>与之对应，并在<code>fd_array</code>中找到一个空闲位置分配给它，数组中对应的下标，就是我们在<code>用户空间</code>用到的<code>文件描述符</code>。</p><blockquote><p>对于任何一个进程，默认情况下，文件描述符 <code>0</code>表示 <code>stdin 标准输入</code>，文件描述符 <code>1</code>表示<code>stdout 标准输出</code>，文件描述符<code>2</code>表示<code>stderr 标准错误输出</code>。</p></blockquote><p>进程中打开的文件列表<code>fd_array</code>定义在内核数据结构<code>struct files_struct</code>中，在<code>struct fdtable</code>结构中有一个指针<code>struct fd **fd</code>指向<code>fd_array</code>。</p><p><strong>由于本小节讨论的是内核网络系统部分的数据结构</strong>，所以这里拿<code>Socket</code>文件类型来举例说明：</p><p>用于封装文件元信息的内核数据结构<code>struct file</code>中的<code>private_data</code>指针指向具体的<code>Socket</code>结构。</p><p><code>struct file</code>中的<code>file_operations</code>属性定义了文件的操作函数，不同的文件类型，对应的<code>file_operations</code>是不同的，针对<code>Socket</code>文件类型，这里的<code>file_operations</code>指向<code>socket_file_ops</code>。</p><blockquote><p>我们在<code>用户空间</code>对<code>Socket</code>发起的读写等系统调用，进入内核首先会调用的是<code>Socket</code>对应的<code>struct file</code>中指向的<code>socket_file_ops</code>。 <strong>比如</strong>：对<code>Socket</code>发起<code>write</code>写操作，在内核中首先被调用的就是<code>socket_file_ops</code>中定义的<code>sock_write_iter</code>。<code>Socket</code>发起<code>read</code>读操作内核中对应的则是<code>sock_read_iter</code>。</p></blockquote><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>static const struct file_operations socket_file_ops = {
  .owner =  THIS_MODULE,
  .llseek =  no_llseek,
  .read_iter =  sock_read_iter,
  .write_iter =  sock_write_iter,
  .poll =    sock_poll,
  .unlocked_ioctl = sock_ioctl,
  .mmap =    sock_mmap,
  .release =  sock_close,
  .fasync =  sock_fasync,
  .sendpage =  sock_sendpage,
  .splice_write = generic_splice_sendpage,
  .splice_read =  sock_splice_read,
};
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="socket内核结构" tabindex="-1"><a class="header-anchor" href="#socket内核结构" aria-hidden="true">#</a> <strong>Socket内核结构</strong></h3><figure><img src="/assets/v2-98ad60af2db4faaf74ae5140aadc2a6c_720w-vOF18qGP.webp" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>在我们进行网络程序的编写时会首先创建一个<code>Socket</code>，然后基于这个<code>Socket</code>进行<code>bind</code>，<code>listen</code>，我们先将这个<code>Socket</code>称作为<code>监听Socket</code>。</p><ol><li>当我们调用<code>accept</code>后，内核会基于<code>监听Socket</code>创建出来一个新的<code>Socket</code>专门用于与客户端之间的网络通信。并将<code>监听Socket</code>中的<code>Socket操作函数集合</code>（<code>inet_stream_ops</code>）<code>ops</code>赋值到新的<code>Socket</code>的<code>ops</code>属性中。</li></ol><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>const struct proto_ops inet_stream_ops = {
  .bind = inet_bind,
  .connect = inet_stream_connect,
  .accept = inet_accept,
  .poll = tcp_poll,
  .listen = inet_listen,
  .sendmsg = inet_sendmsg,
  .recvmsg = inet_recvmsg,
  ......
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>这里需要注意的是，<code>监听的 socket</code>和真正用来网络通信的 <code>Socket</code>，是两个 Socket，一个叫作<code>监听 Socket</code>，一个叫作<code>已连接的Socket</code>。</p></blockquote><ol><li>接着内核会为<code>已连接的Socket</code>创建<code>struct file</code>并初始化，并把Socket文件操作函数集合（<code>socket_file_ops</code>）赋值给<code>struct file</code>中的<code>f_ops</code>指针。然后将<code>struct socket</code>中的<code>file</code>指针指向这个新分配申请的<code>struct file</code>结构体。</li></ol><blockquote><p>内核会维护两个队列：</p></blockquote><ul><li>一个是已经完成<code>TCP三次握手</code>，连接状态处于<code>established</code>的连接队列。内核中为<code>icsk_accept_queue</code>。</li><li>一个是还没有完成<code>TCP三次握手</code>，连接状态处于<code>syn_rcvd</code>的半连接队列。</li></ul><ol><li>然后调用<code>socket-&gt;ops-&gt;accept</code>，从<code>Socket内核结构图</code>中我们可以看到其实调用的是<code>inet_accept</code>，该函数会在<code>icsk_accept_queue</code>中查找是否有已经建立好的连接，如果有的话，直接从<code>icsk_accept_queue</code>中获取已经创建好的<code>struct sock</code>。并将这个<code>struct sock</code>对象赋值给<code>struct socket</code>中的<code>sock</code>指针。</li></ol><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>struct sock`在`struct socket`中是一个非常核心的内核对象，正是在这里定义了我们在介绍`网络包的接收发送流程`中提到的`接收队列`，`发送队列`，`等待队列`，`数据就绪回调函数指针`，`内核协议栈操作函数集合
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>根据创建<code>Socket</code>时发起的系统调用<code>sock_create</code>中的<code>protocol</code>参数(对于<code>TCP协议</code>这里的参数值为<code>SOCK_STREAM</code>)查找到对于 tcp 定义的操作方法实现集合 <code>inet_stream_ops</code> 和<code>tcp_prot</code>。并把它们分别设置到<code>socket-&gt;ops</code>和<code>sock-&gt;sk_prot</code>上。</li></ul><blockquote><p>这里可以回看下本小节开头的《<a href="https://www.zhihu.com/search?q=Socket%E5%86%85%E6%A0%B8%E7%BB%93%E6%9E%84%E5%9B%BE&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2305464768%7D" target="_blank" rel="noopener noreferrer">Socket内核结构图<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>》捋一下他们之间的关系。</p><p><code>socket</code>相关的操作接口定义在<code>inet_stream_ops</code>函数集合中，负责对上给用户提供接口。而<code>socket</code>与内核协议栈之间的操作接口定义在<code>struct sock</code>中的<code>sk_prot</code>指针上，这里指向<code>tcp_prot</code>协议操作函数集合。</p></blockquote><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>struct proto tcp_prot = {
  .name      = &quot;TCP&quot;,
  .owner      = THIS_MODULE,
  .close      = tcp_close,
  .connect    = tcp_v4_connect,
  .disconnect    = tcp_disconnect,
  .accept      = inet_csk_accept,
  .keepalive    = tcp_set_keepalive,
  .recvmsg    = tcp_recvmsg,
  .sendmsg    = tcp_sendmsg,
  .backlog_rcv    = tcp_v4_do_rcv,
   ......
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>之前提到的对<code>Socket</code>发起的系统IO调用，在内核中首先会调用<code>Socket</code>的文件结构<code>struct file</code>中的<code>file_operations</code>文件操作集合，然后调用<code>struct socket</code>中的<code>ops</code>指向的<code>inet_stream_ops</code>socket操作函数，最终调用到<code>struct sock</code>中<code>sk_prot</code>指针指向的<code>tcp_prot</code>内核协议栈操作函数接口集合。</p></blockquote><figure><img src="/assets/v2-705089a1d31bddab3f774051225bbcbe_720w-oOtmUQw8.webp" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ul><li>将<code>struct sock</code> 对象中的<code>sk_data_ready</code> 函数指针设置为 <code>sock_def_readable</code>，在<code>Socket</code>数据就绪的时候内核会回调该函数。</li><li><code>struct sock</code>中的<code>等待队列</code>中存放的是系统IO调用发生阻塞的<code>进程fd</code>，以及相应的<code>回调函数</code>。<strong>记住这个地方，后边介绍epoll的时候我们还会提到！</strong></li></ul><ol><li>当<code>struct file</code>，<code>struct socket</code>，<code>struct sock</code>这些核心的内核对象创建好之后，最后就是把<code>socket</code>对象对应的<code>struct file</code>放到进程打开的文件列表<code>fd_array</code>中。随后系统调用<code>accept</code>返回<code>socket</code>的文件描述符<code>fd</code>给用户程序。</li></ol><h3 id="阻塞io中用户进程阻塞以及唤醒原理" tabindex="-1"><a class="header-anchor" href="#阻塞io中用户进程阻塞以及唤醒原理" aria-hidden="true">#</a> <strong>阻塞IO中用户进程阻塞以及唤醒原理</strong></h3><p>在前边小节我们介绍<code>阻塞IO</code>的时候提到，当用户进程发起系统IO调用时，这里我们拿<code>read</code>举例，用户进程会在<code>内核态</code>查看对应<code>Socket</code>接收缓冲区是否有数据到来。</p><ul><li><code>Socket</code>接收缓冲区有数据，则拷贝数据到<code>用户空间</code>，系统调用返回。</li><li><code>Socket</code>接收缓冲区没有数据，则用户进程让出<code>CPU</code>进入<code>阻塞状态</code>，当数据到达接收缓冲区时，用户进程会被唤醒，从<code>阻塞状态</code>进入<code>就绪状态</code>，等待CPU调度。</li></ul><p>本小节我们就来看下用户进程是如何<code>阻塞</code>在<code>Socket</code>上，又是如何在<code>Socket</code>上被唤醒的。<strong>理解这个过程很重要，对我们理解epoll的事件通知过程很有帮助</strong></p><ul><li>首先我们在用户进程中对<code>Socket</code>进行<code>read</code>系统调用时，用户进程会从<code>用户态</code>转为<code>内核态</code>。</li><li>在进程的<code>struct task_struct</code>结构找到<code>fd_array</code>，并根据<code>Socket</code>的文件描述符<code>fd</code>找到对应的<code>struct file</code>，调用<code>struct file</code>中的文件操作函数结合<code>file_operations</code>，<code>read</code>系统调用对应的是<code>sock_read_iter</code>。</li><li>在<code>sock_read_iter</code>函数中找到<code>struct file</code>指向的<code>struct socket</code>，并调用<code>socket-&gt;ops-&gt;recvmsg</code>，这里我们知道调用的是<code>inet_stream_ops</code>集合中定义的<code>inet_recvmsg</code>。</li><li>在<code>inet_recvmsg</code>中会找到<code>struct sock</code>，并调用<code>sock-&gt;skprot-&gt;recvmsg</code>,这里调用的是<code>tcp_prot</code>集合中定义的<code>tcp_recvmsg</code>函数。</li></ul><blockquote><p>整个调用过程可以参考上边的《系统IO调用结构图》</p></blockquote><p><strong>熟悉了内核函数调用栈后，我们来看下系统IO调用在<code>tcp_recvmsg</code>内核函数中是如何将用户进程给阻塞掉的</strong></p><figure><img src="/assets/v2-a995fafcdbf85b2386ce6e5d552a8148_720w-ejWf4LP2.webp" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>int tcp_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
  size_t len, int nonblock, int flags, int *addr_len)
{
    .................省略非核心代码...............
   //访问sock对象中定义的接收队列
  skb_queue_walk(&amp;sk-&gt;sk_receive_queue, skb) {

    .................省略非核心代码...............

  //没有收到足够数据，调用sk_wait_data 阻塞当前进程
  sk_wait_data(sk, &amp;timeo);
}

int sk_wait_data(struct sock *sk, long *timeo)
{
 //创建struct sock中等待队列上的元素wait_queue_t
 //将进程描述符和回调函数autoremove_wake_function关联到wait_queue_t中
 DEFINE_WAIT(wait);

 // 调用 sk_sleep 获取 sock 对象下的等待队列的头指针wait_queue_head_t
 // 调用prepare_to_wait将新创建的等待项wait_queue_t插入到等待队列中，并将进程状态设置为可打断 INTERRUPTIBLE
 prepare_to_wait(sk_sleep(sk), &amp;wait, TASK_INTERRUPTIBLE);
 set_bit(SOCK_ASYNC_WAITDATA, &amp;sk-&gt;sk_socket-&gt;flags);

 // 通过调用schedule_timeout让出CPU，然后进行睡眠，导致一次上下文切换
 rc = sk_wait_event(sk, timeo, !skb_queue_empty(&amp;sk-&gt;sk_receive_queue));
 ...
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>首先会在<code>DEFINE_WAIT</code>中创建<code>struct sock</code>中等待队列上的等待类型<code>wait_queue_t</code>。</li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>#define DEFINE_WAIT(name) DEFINE_WAIT_FUNC(name, autoremove_wake_function)

#define DEFINE_WAIT_FUNC(name, function)    \
 wait_queue_t name = {      \
  .private = current,    \
  .func  = function,    \
  .task_list = LIST_HEAD_INIT((name).task_list), \
 }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>等待类型<code>wait_queue_t</code>中的<code>private</code>用来关联<code>阻塞</code>在当前<code>socket</code>上的用户进程<code>fd</code>。<code>func</code>用来关联等待项上注册的回调函数。这里注册的是<code>autoremove_wake_function</code>。</p><ul><li>调用<code>sk_sleep(sk)</code>获取<code>struct sock</code>对象中的等待队列头指针<code>wait_queue_head_t</code>。</li><li>调用<code>prepare_to_wait</code>将新创建的等待项<code>wait_queue_t</code>插入到等待队列中，并将进程设置为可打断 <code>INTERRUPTIBL</code>。</li><li>调用<code>sk_wait_event</code>让出CPU，进程进入睡眠状态。</li></ul><p>用户进程的<code>阻塞过程</code>我们就介绍完了，关键是要理解记住<code>struct sock</code>中定义的等待队列上的等待类型<code>wait_queue_t</code>的结构。后面<code>epoll</code>的介绍中我们还会用到它。</p><p><strong>下面我们接着介绍当数据就绪后，用户进程是如何被唤醒的</strong></p><p>在本文开始介绍《网络包接收过程》这一小节中我们提到：</p><ul><li>当网络数据包到达网卡时，网卡通过<code>DMA</code>的方式将数据放到<code>RingBuffer</code>中。</li><li>然后向CPU发起硬中断，在硬中断响应程序中创建<code>sk_buffer</code>，并将网络数据拷贝至<code>sk_buffer</code>中。</li><li>随后发起软中断，内核线程<code>ksoftirqd</code>响应软中断，调用<code>poll函数</code>将<code>sk_buffer</code>送往内核协议栈做层层协议处理。</li><li>在传输层<code>tcp_rcv 函数</code>中，去掉TCP头，根据<code>四元组（源IP，源端口，目的IP，目的端口）</code>查找对应的<code>Socket</code>。</li><li>最后将<code>sk_buffer</code>放到<code>Socket</code>中的接收队列里。</li></ul><p>上边这些过程是内核接收网络数据的完整过程，下边我们来看下，当数据包接收完毕后，用户进程是如何被唤醒的。</p><figure><img src="/assets/v2-d5cb1c23588163582ec549f20f3dfc9e_720w-Rd1_3ku0.webp" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ul><li>当软中断将<code>sk_buffer</code>放到<code>Socket</code>的接收队列上时，接着就会调用<code>数据就绪函数回调指针sk_data_ready</code>，前边我们提到，这个函数指针在初始化的时候指向了<code>sock_def_readable</code>函数。</li><li>在<code>sock_def_readable</code>函数中会去获取<code>socket-&gt;sock-&gt;sk_wq</code>等待队列。在<code>wake_up_common</code>函数中从等待队列<code>sk_wq</code>中找出<code>一个</code>等待项<code>wait_queue_t</code>，回调注册在该等待项上的<code>func</code>回调函数（<code>wait_queue_t-&gt;func</code>）,创建等待项<code>wait_queue_t</code>是我们提到，这里注册的回调函数是<code>autoremove_wake_function</code>。</li></ul><blockquote><p>即使是有多个进程都阻塞在同一个 socket 上，也只唤醒 1 个进程。其作用是为了避免惊群。</p></blockquote><ul><li>在<code>autoremove_wake_function</code>函数中，根据等待项<code>wait_queue_t</code>上的<code>private</code>关联的<code>阻塞进程fd</code>调用<code>try_to_wake_up</code>唤醒阻塞在该<code>Socket</code>上的进程。</li></ul><blockquote><p>记住<code>wait_queue_t</code>中的<code>func</code>函数指针，在<code>epoll</code>中这里会注册<code>epoll</code>的回调函数。</p></blockquote><p>现在理解<code>epoll</code>所需要的基础知识我们就介绍完了，唠叨了这么多，下面终于正式进入本小节的主题<code>epoll</code>了。</p><h3 id="epoll-create创建epoll对象" tabindex="-1"><a class="header-anchor" href="#epoll-create创建epoll对象" aria-hidden="true">#</a> <strong>epoll_create创建epoll对象</strong></h3><p><code>epoll_create</code>是内核提供给我们创建<code>epoll</code>对象的一个系统调用，当我们在用户进程中调用<code>epoll_create</code>时，内核会为我们创建一个<code>struct eventpoll</code>对象，并且也有相应的<code>struct file</code>与之关联，同样需要把这个<code>struct eventpoll</code>对象所关联的<code>struct file</code>放入进程打开的文件列表<code>fd_array</code>中管理。</p><blockquote><p>熟悉了<code>Socket</code>的创建逻辑，<code>epoll</code>的创建逻辑也就不难理解了。</p><p><code>struct eventpoll</code>对象关联的<code>struct file</code>中的<code>file_operations 指针</code>指向的是<code>eventpoll_fops</code>操作函数集合。</p></blockquote><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>static const struct file_operations eventpoll_fops = {
     .release = ep_eventpoll_release;
     .poll = ep_eventpoll_poll,
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/assets/v2-31ec01cf26bbe9758339f55ac876a33b_720w-vS40sNCb.webp" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>struct eventpoll {

    //等待队列，阻塞在epoll上的进程会放在这里
    wait_queue_head_t wq;

    //就绪队列，IO就绪的socket连接会放在这里
    struct list_head rdllist;

    //红黑树用来管理所有监听的socket连接
    struct rb_root rbr;

    ......
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>wait_queue_head_t wq：</code>epoll中的等待队列，队列里存放的是<code>阻塞</code>在<code>epoll</code>上的用户进程。在<code>IO就绪</code>的时候<code>epoll</code>可以通过这个队列找到这些<code>阻塞</code>的进程并唤醒它们，从而执行<code>IO调用</code>读写<code>Socket</code>上的数据。</li></ul><blockquote><p>这里注意与<code>Socket</code>中的等待队列区分！！！</p></blockquote><ul><li><code>struct list_head rdllist：</code>epoll中的就绪队列，队列里存放的是都是<code>IO就绪</code>的<code>Socket</code>，被唤醒的用户进程可以直接读取这个队列获取<code>IO活跃</code>的<code>Socket</code>。无需再次遍历整个<code>Socket</code>集合。</li></ul><blockquote><p>这里正是<code>epoll</code>比<code>select ，poll</code>高效之处，<code>select ，poll</code>返回的是全部的<code>socket</code>连接，我们需要在<code>用户空间</code>再次遍历找出真正<code>IO活跃</code>的<code>Socket</code>连接。 而<code>epoll</code>只是返回<code>IO活跃</code>的<code>Socket</code>连接。用户进程可以直接进行IO操作。</p></blockquote><ul><li><code>struct rb_root rbr :</code> 由于红黑树在<code>查找</code>，<code>插入</code>，<code>删除</code>等综合性能方面是最优的，所以epoll内部使用一颗红黑树来管理海量的<code>Socket</code>连接。</li></ul><blockquote><p><code>select</code>用<code>数组</code>管理连接，<code>poll</code>用<code>链表</code>管理连接。</p></blockquote><h3 id="epoll-ctl向epoll对象中添加监听的socket" tabindex="-1"><a class="header-anchor" href="#epoll-ctl向epoll对象中添加监听的socket" aria-hidden="true">#</a> <strong>epoll_ctl向epoll对象中添加监听的Socket</strong></h3><p>当我们调用<code>epoll_create</code>在内核中创建出<code>epoll</code>对象<code>struct eventpoll</code>后，我们就可以利用<code>epoll_ctl</code>向<code>epoll</code>中添加我们需要管理的<code>Socket</code>连接了。</p><ol><li>首先要在epoll内核中创建一个表示<code>Socket连接</code>的数据结构<code>struct epitem</code>，而在<code>epoll</code>中为了综合性能的考虑，采用一颗红黑树来管理这些海量<code>socket连接</code>。所以<code>struct epitem</code>是一个红黑树节点。</li></ol><figure><img src="/assets/v2-1a317d1dbe82fa47c9850e8dc2e8f783_720w-TUxoO_Jj.webp" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>struct epitem
{
      //指向所属epoll对象
      struct eventpoll *ep; 
      //注册的感兴趣的事件,也就是用户空间的epoll_event     
      struct epoll_event event; 
      //指向epoll对象中的就绪队列
      struct list_head rdllink;  
      //指向epoll中对应的红黑树节点
      struct rb_node rbn;     
      //指向epitem所表示的socket-&gt;file结构以及对应的fd
      struct epoll_filefd ffd;                  
  }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>这里重点记住<code>struct epitem</code>结构中的<code>rdllink</code>以及<code>epoll_filefd</code>成员，后面我们会用到。</p></blockquote><ol><li>在内核中创建完表示<code>Socket连接</code>的数据结构<code>struct epitem</code>后，我们就需要在<code>Socket</code>中的等待队列上创建等待项<code>wait_queue_t</code>并且注册<code>epoll的回调函数ep_poll_callback</code>。</li></ol><p>通过<code>《阻塞IO中用户进程阻塞以及唤醒原理》</code>小节的铺垫，我想大家已经猜到这一步的意义所在了吧！当时在等待项<code>wait_queue_t</code>中注册的是<code>autoremove_wake_function</code>回调函数。还记得吗？</p><blockquote><p>epoll的回调函数<code>ep_poll_callback</code>正是<code>epoll</code>同步IO事件通知机制的核心所在，也是区别于<code>select，poll</code>采用内核轮询方式的根本性能差异所在。</p></blockquote><figure><img src="/assets/v2-83c27c98dfe73be40091d8efb937d7f3_720w-nBx5YOFU.webp" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><strong>这里又出现了一个新的数据结构<code>struct eppoll_entry</code>，那它的作用是干什么的呢？大家可以结合上图先猜测下它的作用!</strong></p><p>我们知道<code>socket-&gt;sock-&gt;sk_wq</code>等待队列中的类型是<code>wait_queue_t</code>，我们需要在<code>struct epitem</code>所表示的<code>socket</code>的等待队列上注册<code>epoll</code>回调函数<code>ep_poll_callback</code>。</p><p>这样当数据到达<code>socket</code>中的接收队列时，内核会回调<code>sk_data_ready</code>，在<code>阻塞IO中用户进程阻塞以及唤醒原理</code>这一小节中，我们知道这个<code>sk_data_ready</code>函数指针会指向<code>sk_def_readable</code>函数，在<code>sk_def_readable</code>中会回调注册在等待队列里的等待项<code>wait_queue_t -&gt; func</code>回调函数<code>ep_poll_callback</code>。<strong>在<code>ep_poll_callback</code>中需要找到<code>epitem</code></strong>，将<code>IO就绪</code>的<code>epitem</code>放入<code>epoll</code>中的就绪队列中。</p><p>而<code>socket</code>等待队列中类型是<code>wait_queue_t</code>无法关联到<code>epitem</code>。所以就出现了<code>struct eppoll_entry</code>结构体，它的作用就是关联<code>Socket</code>等待队列中的等待项<code>wait_queue_t</code>和<code>epitem</code>。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>struct eppoll_entry { 
   //指向关联的epitem
   struct epitem *base; 

  // 关联监听socket中等待队列中的等待项 (private = null  func = ep_poll_callback)
   wait_queue_t wait;   

   // 监听socket中等待队列头指针
   wait_queue_head_t *whead; 
    .........
  }; 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样在<code>ep_poll_callback</code>回调函数中就可以根据<code>Socket</code>等待队列中的等待项<code>wait</code>，通过<code>container_of宏</code>找到<code>eppoll_entry</code>，继而找到<code>epitem</code>了。</p><blockquote><p><code>container_of</code>在Linux内核中是一个常用的宏，用于从包含在某个结构中的指针获得结构本身的指针，通俗地讲就是通过结构体变量中某个成员的首地址进而获得整个结构体变量的首地址。</p><p>这里需要注意下这次等待项<code>wait_queue_t</code>中的<code>private</code>设置的是<code>null</code>，因为这里<code>Socket</code>是交给<code>epoll</code>来管理的，阻塞在<code>Socket</code>上的进程是也由<code>epoll</code>来唤醒。在等待项<code>wait_queue_t</code>注册的<code>func</code>是<code>ep_poll_callback</code>而不是<code>autoremove_wake_function</code>，<code>阻塞进程</code>并不需要<code>autoremove_wake_function</code>来唤醒，所以这里设置<code>private</code>为<code>null</code></p></blockquote><ol><li>当在<code>Socket</code>的等待队列中创建好等待项<code>wait_queue_t</code>并且注册了<code>epoll</code>的回调函数<code>ep_poll_callback</code>，然后又通过<code>eppoll_entry</code>关联了<code>epitem</code>后。 剩下要做的就是将<code>epitem</code>插入到<code>epoll</code>中的红黑树<code>struct rb_root rbr</code>中。</li></ol><blockquote><p>这里可以看到<code>epoll</code>另一个优化的地方，<code>epoll</code>将所有的<code>socket</code>连接通过内核中的红黑树来集中管理。每次添加或者删除<code>socket连接</code>都是增量添加删除，而不是像<code>select，poll</code>那样每次调用都是全量<code>socket连接</code>集合传入内核。避免了<code>频繁大量</code>的<code>内存拷贝</code>。</p></blockquote><h3 id="epoll-wait同步阻塞获取io就绪的socket" tabindex="-1"><a class="header-anchor" href="#epoll-wait同步阻塞获取io就绪的socket" aria-hidden="true">#</a> <strong>epoll_wait同步阻塞获取IO就绪的Socket</strong></h3><ol><li>用户程序调用<code>epoll_wait</code>后，内核首先会查找epoll中的就绪队列<code>eventpoll-&gt;rdllist</code>是否有<code>IO就绪</code>的<code>epitem</code>。<code>epitem</code>里封装了<code>socket</code>的信息。如果就绪队列中有就绪的<code>epitem</code>，就将<code>就绪的socket</code>信息封装到<code>epoll_event</code>返回。</li><li>如果<code>eventpoll-&gt;rdllist</code>就绪队列中没有<code>IO就绪</code>的<code>epitem</code>，则会创建等待项<code>wait_queue_t</code>，将用户进程的<code>fd</code>关联到<code>wait_queue_t-&gt;private</code>上，并在等待项<code>wait_queue_t-&gt;func</code>上注册回调函数<code>default_wake_function</code>。最后将等待项添加到<code>epoll</code>中的等待队列中。用户进程让出CPU，进入<code>阻塞状态</code>。</li></ol><figure><img src="/assets/v2-28404480280ae5fb32cb892bdb5df228_720w-OqajT02N.webp" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><blockquote><p>这里和<code>阻塞IO模型</code>中的阻塞原理是一样的，只不过在<code>阻塞IO模型</code>中注册到等待项<code>wait_queue_t-&gt;func</code>上的是<code>autoremove_wake_function</code>，并将等待项添加到<code>socket</code>中的等待队列中。这里注册的是<code>default_wake_function</code>，将等待项添加到<code>epoll</code>中的等待队列上。</p></blockquote><figure><img src="/assets/v2-dc10253c2cb03b80b0292d5ad0740c20_720w-02lHnzzu.webp" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ol><li><strong>前边做了那么多的知识铺垫，下面终于到了<code>epoll</code>的整个工作流程了：</strong></li></ol><figure><img src="/assets/v2-4c2b54dac880410ff6764f50c03d5981_720w-vvBxIwTa.webp" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ul><li>当网络数据包在软中断中经过内核协议栈的处理到达<code>socket</code>的接收缓冲区时，紧接着会调用socket的数据就绪回调指针<code>sk_data_ready</code>，回调函数为<code>sock_def_readable</code>。在<code>socket</code>的等待队列中找出等待项，其中等待项中注册的回调函数为<code>ep_poll_callback</code>。</li><li>在回调函数<code>ep_poll_callback</code>中，根据<code>struct eppoll_entry</code>中的<code>struct wait_queue_t wait</code>通过<code>container_of宏</code>找到<code>eppoll_entry</code>对象并通过它的<code>base</code>指针找到封装<code>socket</code>的数据结构<code>struct epitem</code>，并将它加入到<code>epoll</code>中的就绪队列<code>rdllist</code>中。</li><li>随后查看<code>epoll</code>中的等待队列中是否有等待项，也就是说查看是否有进程阻塞在<code>epoll_wait</code>上等待<code>IO就绪</code>的<code>socket</code>。如果没有等待项，则软中断处理完成。</li><li>如果有等待项，则回到注册在等待项中的回调函数<code>default_wake_function</code>,在回调函数中唤醒<code>阻塞进程</code>，并将就绪队列<code>rdllist</code>中的<code>epitem</code>的<code>IO就绪</code>socket信息封装到<code>struct epoll_event</code>中返回。</li><li>用户进程拿到<code>epoll_event</code>获取<code>IO就绪</code>的socket，发起系统IO调用读取数据。</li></ul><h2 id="再谈水平触发和边缘触发" tabindex="-1"><a class="header-anchor" href="#再谈水平触发和边缘触发" aria-hidden="true">#</a> <strong>再谈水平触发和边缘触发</strong></h2><p>网上有大量的关于这两种模式的讲解，大部分讲的比较模糊，感觉只是强行从概念上进行描述，看完让人难以理解。所以在这里，笔者想结合上边<code>epoll</code>的工作过程，再次对这两种模式做下自己的解读，力求清晰的解释出这两种工作模式的异同。</p><p>经过上边对<code>epoll</code>工作过程的详细解读，我们知道，当我们监听的<code>socket</code>上有数据到来时，软中断会执行<code>epoll</code>的回调函数<code>ep_poll_callback</code>,在回调函数中会将<code>epoll</code>中描述<code>socket信息</code>的数据结构<code>epitem</code>插入到<code>epoll</code>中的就绪队列<code>rdllist</code>中。随后用户进程从<code>epoll</code>的等待队列中被唤醒，<code>epoll_wait</code>将<code>IO就绪</code>的<code>socket</code>返回给用户进程，随即<code>epoll_wait</code>会清空<code>rdllist</code>。</p><p><strong>水平触发</strong>和<strong>边缘触发</strong>最关键的<strong>区别</strong>就在于当<code>socket</code>中的接收缓冲区还有数据可读时。<strong><code>epoll_wait</code>是否会清空<code>rdllist</code>。</strong></p><ul><li><strong>水平触发</strong>：在这种模式下，用户线程调用<code>epoll_wait</code>获取到<code>IO就绪</code>的socket后，对<code>Socket</code>进行系统IO调用读取数据，假设<code>socket</code>中的数据只读了一部分没有全部读完，这时再次调用<code>epoll_wait</code>，<code>epoll_wait</code>会检查这些<code>Socket</code>中的接收缓冲区是否还有数据可读，如果还有数据可读，就将<code>socket</code>重新放回<code>rdllist</code>。所以当<code>socket</code>上的IO没有被处理完时，再次调用<code>epoll_wait</code>依然可以获得这些<code>socket</code>，用户进程可以接着处理<code>socket</code>上的IO事件。</li><li><strong>边缘触发：</strong> 在这种模式下，<code>epoll_wait</code>就会直接清空<code>rdllist</code>，不管<code>socket</code>上是否还有数据可读。所以在边缘触发模式下，当你没有来得及处理<code>socket</code>接收缓冲区的剩下可读数据时，再次调用<code>epoll_wait</code>，因为这时<code>rdlist</code>已经被清空了，<code>socket</code>不会再次从<code>epoll_wait</code>中返回，所以用户进程就不会再次获得这个<code>socket</code>了，也就无法在对它进行IO处理了。<strong>除非，这个<code>socket</code>上有新的IO数据到达</strong>，根据<code>epoll</code>的工作过程，该<code>socket</code>会被再次放入<code>rdllist</code>中。</li></ul><blockquote><p>如果你在<code>边缘触发模式</code>下，处理了部分<code>socket</code>上的数据，那么想要处理剩下部分的数据，就只能等到这个<code>socket</code>上再次有网络数据到达。</p></blockquote><p>在<code>Netty</code>中实现的<code>EpollSocketChannel</code>默认的就是<code>边缘触发</code>模式。<code>JDK</code>的<code>NIO</code>默认是<code>水平触发</code>模式。</p><h3 id="epoll对select-poll的优化总结" tabindex="-1"><a class="header-anchor" href="#epoll对select-poll的优化总结" aria-hidden="true">#</a> <strong>epoll对select，poll的优化总结</strong></h3><ul><li><code>epoll</code>在内核中通过<code>红黑树</code>管理海量的连接，所以在调用<code>epoll_wait</code>获取<code>IO就绪</code>的socket时，不需要传入监听的socket文件描述符。从而避免了海量的文件描述符集合在<code>用户空间</code>和<code>内核空间</code>中来回复制。</li></ul><blockquote><p><code>select，poll</code>每次调用时都需要传递全量的文件描述符集合，导致大量频繁的拷贝操作。</p></blockquote><ul><li><code>epoll</code>仅会通知<code>IO就绪</code>的socket。避免了在用户空间遍历的开销。</li></ul><blockquote><p><code>select，poll</code>只会在<code>IO就绪</code>的socket上打好标记，依然是全量返回，所以在用户空间还需要用户程序在一次遍历全量集合找出具体<code>IO就绪</code>的socket。</p></blockquote><ul><li><code>epoll</code>通过在<code>socket</code>的等待队列上注册回调函数<code>ep_poll_callback</code>通知用户程序<code>IO就绪</code>的socket。避免了在内核中轮询的开销。</li></ul><blockquote><p>大部分情况下<code>socket</code>上并不总是<code>IO活跃</code>的，在面对海量连接的情况下，<code>select，poll</code>采用内核轮询的方式获取<code>IO活跃</code>的socket，无疑是性能低下的核心原因。</p></blockquote><p>根据以上<code>epoll</code>的性能优势，它是目前为止各大主流网络框架，以及反向代理中间件使用到的网络IO模型。</p><p>利用<code>epoll</code>多路复用IO模型可以轻松的解决<code>C10K</code>问题。</p><p><code>C100k</code>的解决方案也还是基于<code>C10K</code>的方案，通过<code>epoll</code> 配合线程池，再加上 CPU、内存和网络接口的性能和容量提升。大部分情况下，<code>C100K</code>很自然就可以达到。</p><p>甚至<code>C1000K</code>的解决方法，本质上还是构建在 <code>epoll</code> 的<code>多路复用 I/O 模型</code>上。只不过，除了 I/O 模型之外，还需要从应用程序到 Linux 内核、再到 CPU、内存和网络等各个层次的深度优化，特别是需要借助硬件，来卸载那些原来通过软件处理的大量功能（<code>去掉大量的中断响应开销</code>，<code>以及内核协议栈处理的开销</code>）。</p><h2 id="信号驱动io" tabindex="-1"><a class="header-anchor" href="#信号驱动io" aria-hidden="true">#</a> <strong>信号驱动IO</strong></h2><figure><img src="/assets/v2-d5d614d9829782732a8b5c1b909e5310_720w-qCWzJhED.webp" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>大家对这个装备肯定不会陌生，当我们去一些美食城吃饭的时候，点完餐付了钱，老板会给我们一个信号器。然后我们带着这个信号器可以去找餐桌，或者干些其他的事情。当信号器亮了的时候，这时代表饭餐已经做好，我们可以去窗口取餐了。</p><p>这个典型的生活场景和我们要介绍的<code>信号驱动IO模型</code>就很像。</p><p>在<code>信号驱动IO模型</code>下，用户进程操作通过<code>系统调用 sigaction 函数</code>发起一个 IO 请求，在对应的<code>socket</code>注册一个<code>信号回调</code>，此时<code>不阻塞</code>用户进程，进程会继续工作。当内核数据就绪时，内核就为该进程生成一个 <code>SIGIO 信号</code>，通过信号回调通知进程进行相关 IO 操作。</p><blockquote><p>这里需要注意的是：<code>信号驱动式 IO 模型</code>依然是<code>同步IO</code>，因为它虽然可以在等待数据的时候不被阻塞，也不会频繁的轮询，但是当数据就绪，内核信号通知后，用户进程依然要自己去读取数据，在<code>数据拷贝阶段</code>发生阻塞。</p><p>信号驱动 IO模型 相比于前三种 IO 模型，实现了在等待数据就绪时，进程不被阻塞，主循环可以继续工作，所以<code>理论上</code>性能更佳。</p></blockquote><p>但是实际上，使用<code>TCP协议</code>通信时，<code>信号驱动IO模型</code>几乎<code>不会被采用</code>。原因如下：</p><ul><li>信号IO 在大量 IO 操作时可能会因为信号队列溢出导致没法通知</li><li><code>SIGIO 信号</code>是一种 Unix 信号，信号没有附加信息，如果一个信号源有多种产生信号的原因，信号接收者就无法确定究竟发生了什么。而 TCP socket 生产的信号事件有七种之多，这样应用程序收到 SIGIO，根本无从区分处理。</li></ul><p>但<code>信号驱动IO模型</code>可以用在 <code>UDP</code>通信上，因为UDP 只有<code>一个数据请求事件</code>，这也就意味着在正常情况下 UDP 进程只要捕获 SIGIO 信号，就调用 <code>read 系统调用</code>读取到达的数据。如果出现异常，就返回一个异常错误。</p><hr><p>这里插句题外话，大家觉不觉得<code>阻塞IO模型</code>在生活中的例子就像是我们在食堂排队打饭。你自己需要排队去打饭同时打饭师傅在配菜的过程中你需要等待。</p><figure><img src="data:image/webp;base64,UklGRkAPAABXRUJQVlA4IDQPAACQSwCdASrcAKMAPpE+mkilo6ihK3M8WRASCUA6ADoSezef198uvbc373jFvd39I+b3/k+vrcXYpX65dCldjHQ+e6/bvmadddwjQR228AvJrs4wBfXXzZvmfNf7FdEPh7/X/+h7BH84/vH/c9o//Q8xX1lwLPRcQJYtcyqx1fPsnq0nMFohlLFofuK4hq2vki7tBFYBRmImgZ5/OVEBmL0hKH9fadtIDp9QO+Eo3uCCS3DogNpmAkkGL8JfE3BBjJ2D6NzVW48xSQtO3dcJe9jcVfbhOs2LdgenNG3i/y5f9cAGaKOMLe8vTVyskZZKJPjav8HZFw9sjXyKvWqr5v0xdQEjExThgzgYT8g+bNUgAPFHEut+kpNYOumztpMfNgH0Ks9XzHPszcbOwFe8s+ET6tf/M5WSlLUVGvmwpSCdszijjXpLkkgYzPjn8Qg3MOcUdVPqlEhVEQKz/V43Ilv/Jq5cbtHCVhG2UHeyJEj41pTf5LCg6ZG1X08q8B2m+eVC5EjyfIcStS4ci3nDKon7XgnH9JAZcVztIU4xw65j0VMBAZNOQZK6Hw/fAMeWimKOVONdfvB9lXSzL7zP1v0j8muHmnImiZ9BbhF1MuGlAyKn5aX95hvY7ytjMPO60uLKy845XYQcU4/Qr9lU63tP+NCTTmUsVx8oWcx5hT37g++Ox0YxLmxHi8LUFgxtvgpd7jnJDl2IJd4ltfkRfEs5BQljBbhre7B15W2yjEpYEOhfHw1c6JrvDghc12R6+MsPUFFIys5REw04M2uAWPMh1fhG4h0uKJWXk5Z4rDeZfc9FTLoAAP7+wDn/t/irhbhB8wBNXY78v6sf7F0LfXJikZPCsn0OOGP5MN/lIq6WvJyKWb7PbP/jS3V/CE297S+NCtBsptx+No7f+SWwefRDRP0n/cFfw/39rBlUDji2tLY8ntiGYWaOzhO9DptquZKS5cS7Nd6dZ3cQVsERgeSFn5F1woer46FgLNGKCyscWzyilmliqNQHJ232uMy5P+Ai/UbKcNa+vrIi3aZaVbY1bu1kwOBv4l9ie/x0EAMiKr9m1GOZHfOZzD3EC1tGOXaDApvcuQsksVa++8EwDJFRgkysWKZUGboIXqjNP2sff1cf7RS/ROZXckAWWwC+nBOSfgIrXOGPMc2UDm6ycQ3jsNSLx/gnqSB2OZho894jWgGam5hYTqcywET/yxkzvQG57eMd27a8oEIO1oBw7r9lYeMEToL/F0r4kWapp2mjhWVpbOOX0qrYyTsAYcT1s69tsGukl0btPxBo4Xvnaqic4q9tZM9XmhmWLgpX4aYZflH09rQJuGTSR4FGSaDK0O8uHeFIRjF0H3Dc+fwXgZs6BIdprH0PdbRbtmWvR+0HGDdrE7Y5/rYdxxsDESdiPYVDvYRzTtzFeGY3k9Fe0FUs72RXEjckLa4XqBNo8gM+tulQrSYXeAInyiOM2AUeB2fcoBjGjb76EsJWDUMd4Z1BNDna8jS+JrsNgUT/mQo3tWa9SAfBo8DbTq9A6WB/wk1IN2C0cCbJyPN5lr5/hTKuuGlT2tzotfv7jReG3kWx+qduo50UjfvPUZIx432w6TAf3FsWXa4L1seyjuSCC1dudECGTvRNOFmUXREjgKTiSZS0TH8vsUjXUJIiGPh1ytB0SVsElBHCObXTYggQynhMsEubkXLELTBWaZL2K0zshvp99CZ4X/thIR4snjWosTUR4JmDUAapTvZF4n4aD0iM1sJbt7J0rv/g+4QJ3MJtIkAc4J2MnTKJtSQErpeY0PkXab1uS2sPUvZQcp2rRgVIsJAsWR2DmuvNECJAwHuJe4Stu3s127HNTT3AN+qqhv8UE/V4PYYxp9gSYOCMQQkjzgxtengtsRj6IaVey5b0D4ztAYtksEZPI1cJL6dtGRpP/kOM6QQ82o5EW1CvkH8hn3+NpMb4C9O9vRBCWmRcrcD3ICNCUgLy7iQKa6k1RYANHE+V6+rpIRamUQ/FCLJLz3HXV4O76+1Qg6+gNvtvbDhUvdxlU8Mvry0YVZCblbXrBW2T3QK6l9i4BNRh254pOmIzY0gXh0q8lCHFEn73zppDi2R1ZUhnwXFk0G9/5MZBDdGYjwTfK5uRqqYemUDQjfxIPCAf+yFlSSjq5wVOAiPMOkPhyXk+MKEDIpeDMKvF24w1RajxeEPWqcMtEhU44CtM+AMaPuGiUv8XkHE8i5g4ayOlfQSvt2EL3g0l3eRsD03fZq6zx4hdVq5EXwSVRCledy0+UQPjY/2G2I0BAQAnKsYxg6N/k4oz8uO0zURk/RH+XwW9GbOo2ATH5CeV30/YNj2F+Wh57hC3NC9FXV5n3v2QWNlraRklYAGqQ2fC6o+BO9OupjJr3zE2P4Ql3MeabxheF3SV0XNXbKj7ZDvPLCwDpvUu1NllpYpMudaDfA9yD7bPRki0cdGFk65RTex21H4r+pGy2tpLpIfg8Ad9EYi/y/lwiGdSBO4DiajH8slV6/M3dXX/sQUT9dpyErZ3vsms8dxk8d4eTKCFqXHZTZ3ZSNrWx4LTGpNqOcyA0cPMzMfdwk9x2ADRyjS3u/3WVa16Sy+8Jg3+EW9medlu2x5GEyNUX5dzZoRzPzgUcgT73G7zRriQgcCdbMuD7rFx864g1cm7YTsYXpSmH49p+Ynyi9c4Kec6b+AVX9GUH1JNQrW4Qb/H9PX2YwXzWPT5v3QQtWXc+KbsZ79z5eP+9y+M2erjoyEkaFtu6bnAvYDXGwJ383OJgGenAhNNNAkCYnwLFV9+469zKltRgr6RUcldjJsczJfmxBy/N63MIzxEXbe3wBXgBhOOqvnrC6IIy45NQT9L5gTc7hHmhjiEtPXMfB2EtbDwUlfQfp3yMwVwAECXxl/xhVAZl0Oecin6FuoqYoSUnr1Nnj3/ntVYV6/SeXKYCOc32f3mzKtrz9+eSSmRR0PxTCY3gnYtJTRRoSrvA75cxsUKDPa1E+FBABFiKNOIdIeq5QpNfBq6Gkrg/M/pH+bPqLb2T6pbtqC/7aiJ3vWQnS/zpGNTptpZ3Xbj6EVdnS7M8tb3Ck7seTaESgS5x10GLrPtZ6mB6oLm/+736DU3cdiAFLyUllXPxgvMJSRMmBeFibMf8Ig6RknuYu+ekfEVIPA8wuAprxwmfNzt254X3YWOZ6sw47LCG2DBXoJDlFqk5rVTYVKNG3Gpu4cDTfForEWk4fjwsITcurdk79WcT+3o2irL+woCMepxr9i3zyFM+rwYNNAJc1RgJmrPq+sswJj/lWAnTwM1i30+FwWKuyEa0DbgqpaQe+ctu0j0JLPfnyLSivwQJNrFI1chYTw7a92U0o2S+D2uYnX6rDf4F74FQf/M8VcerZmhLhAks7Rgld/ud4S773xLTkJLiGfUn5F7c94K+0qAKE1RUcGL0Q9L7tGTX7zT+KdUgvcf1ydS6qziZbsNvU+PV7W5FDWrc7cBhRHfCLKi5j8V3NXjm6tWN0Ja3Su+c7O3qSqQiIxiXAtWMAbn2yLynim+QOZdIXUDAOTy8iZ81lR9AI0CO8llapqzh5nD7ijz1R0xV3kym/HOonASfQqXPMlFzvU3+N/DXQBz2n+MPCYYHQVEUQw5da3IO1Ibx9wfBHmAxj/v7kuXSflZkNfDxzjaJaOAUb+ciErDN5hKI3ROu9Wb9HEP94HYFS7Mux9Dgunjjiga7X1CbcNcVhA7nOLDHN4ayDWV+Ej6FC5ApQtwI+UNHPoQ1GbsWdATLrjN8arsbwLYXj+g+P29DWhOMQJ8u/UkF4sgBTR2Y/gQ4kuMCuLk/fbWehX9C8mnjh64aVMBUwozjhZfJD/d9wElNkuJb8STOp2WPVfMcN86LK6HIIlhDRaR9Q7niqB47wjJpQ7wDVPY0M4W7Rzn7RVMw0KqV9DPWm1fP6p30FF9s8T/JWpVAWKput5/J+mCNYDHqMk0aU2lXMJO5VON9/ch2m6Nm3SHZABUkrG981bG1Kdob8jGpMkcRZpEnX7q1pQ074wYOyv8iS5shrTiXCN/mYjR7YOg1sjZHZKQ4WGaf259cAbZ814vQTJ7rzn5GA+w9fE2pAACeYqkQ9h5Jzwfwn4kFOlZa8E/LfpKvV/OSMWE76y5or/4tDQpSwmw/E53Ngo2ohcywRxuUZ3F5GP7faeDhSIXY2QtrWZ3Dzj+flpU6e+rFCA9dqIN6AK1w20UKkYd0fgTSGgGzMtTJ+vh9agJ2nF+J4pC0JZXiH1O32ATHLkLVEcFMKEbyysVA4wFJVbwdfrP1Uih3j7S9J1csVdmPyn6zc2IDwwPeQ52HFHIuZiWCzqDLyLnQ8Uy2wzVgbr5Ubx9qvtXbNjyk62JLox4L8TlZ9WSU7efZMTriyRcyXiknNrwW+/h7Zg0CScuhl+6bASaUlMlgwiXYWIcqVuOK4e5P/Cn0jGmbl6Drgvq2Wwar0XfB1/S//fcNeWMbdXHivZQErgnKFkRLDvR5ugbtt3KL5Il5c2gdC9t8ekIAoTniuxVh2ehjaYMzFjvZvsLVgAmV9OUU1qC1ZThxObp+xq6V1uwNHKXRkiwl3gWBnMk4+soO/dYGlcpeJ9KGG7DGDUwlpZKY6hSEChbTzMvBuIvIVwd07vQGNAfh4hdg+X/Q7pcvts0cvnSKiPhcaFgnZA87Q3zUQHnU5x+9mI1IjbmmHr4DpGcAN9HYIbqiqeC13uOo7aIL3DX8QKJ9gYWN3EoH+BH4hhOrHbH6TeWXv03TfQECpCQlcwDtU9/mFMZFVta7d2bkzcJEFQMgD1SKo1U0a+oRJo49RiXVFTnSHUHtQY0HvdPjc+0rVBVjFUP9hQhF9SvOIJcAveyIGD7vJc3nI6j7UPoJZ1sEqYVFjCRR2XqlUydftTWoMC7CI1NWpQEoDil1xpoZEXmXVtW4ksVBAwgFPMSaPYuQ6DBqMckXHYM3MzTm8KCx3sAfAmycvsH+qmaVmhOE1H9a3hPa8L0gmRh8ooOi77/oUT3NNB5LgDgMD0uQK7SbXnTXHBjjHMnvW6RGqGgDou93OCZzcUDX4V99FNQsYEYSV1u/fb5KnsoHYb3Ipmst7zdcm3p+V5jxBdSmwRYAJiifWMRHzSkwQsBx4OC9AI8hi621ide3S3ndUL9uO08mM8wuHEybkD6tU7MMgwFZ+9WuPrpiInoA0QAAAAAAAAA" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><code>IO多路复用模型</code>就像是我们在饭店门口排队等待叫号。叫号器就好比<code>select,poll,epoll</code>可以统一管理全部顾客的<code>吃饭就绪</code>事件，客户好比是<code>socket</code>连接，谁可以去吃饭了，叫号器就通知谁。</p><figure><img src="/assets/v2-c51da49cd8a9f02c762d2c2b0f5c2881_720w-gg7FTTSH.webp" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>##异步IO（AIO）</p><p>以上介绍的四种<code>IO模型</code>均为<code>同步IO</code>，它们都会阻塞在第二阶段<code>数据拷贝阶段</code>。</p><p>通过在前边小节《同步与异步》中的介绍，相信大家很容易就会理解<code>异步IO模型</code>，在<code>异步IO模型</code>下，IO操作在<code>数据准备阶段</code>和<code>数据拷贝阶段</code>均是由内核来完成，不会对应用程序造成任何阻塞。应用进程只需要在<code>指定的数组</code>中引用数据即可。</p><p><code>异步 IO</code> 与<code>信号驱动 IO</code> 的主要区别在于：<code>信号驱动 IO</code> 由内核通知何时可以<code>开始一个 IO 操作</code>，而<code>异步 IO</code>由内核通知 <code>IO 操作何时已经完成</code>。</p><p>举个生活中的例子：<code>异步IO模型</code>就像我们去一个高档饭店里的包间吃饭，我们只需要坐在包间里面，点完餐（<code>类比异步IO调用</code>）之后，我们就什么也不需要管，该喝酒喝酒，该聊天聊天，饭餐做好后服务员（<code>类比内核</code>）会自己给我们送到包间（<code>类比用户空间</code>）来。整个过程没有任何阻塞。</p><figure><img src="/assets/v2-a7a99882e9a0ed2366785970c1109d7c_720w-8fC9zGfA.webp" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><code>异步IO</code>的系统调用需要操作系统内核来支持，目前只有<code>Window</code>中的<code>IOCP</code>实现了非常成熟的<code>异步IO机制</code>。</p><p>而<code>Linux</code>系统对<code>异步IO机制</code>实现的不够成熟，且与<code>NIO</code>的性能相比提升也不明显。</p><blockquote><p>但Linux kernel 在5.1版本由Facebook的大神Jens Axboe引入了新的异步IO库<code>io_uring</code> 改善了原来Linux native AIO的一些性能问题。性能相比<code>Epoll</code>以及之前原生的<code>AIO</code>提高了不少，值得关注。</p></blockquote><p>再加上<code>信号驱动IO模型</code>不适用<code>TCP协议</code>，所以目前大部分采用的还是<code>IO多路复用模型</code>。</p><h2 id="io线程模型" tabindex="-1"><a class="header-anchor" href="#io线程模型" aria-hidden="true">#</a> <strong>IO线程模型</strong></h2><p>在前边内容的介绍中，我们详述了网络数据包的接收和发送过程，并通过介绍5种<code>IO模型</code>了解了内核是如何读取网络数据并通知给用户线程的。</p><p>前边的内容都是以<code>内核空间</code>的视角来剖析网络数据的收发模型，本小节我们站在<code>用户空间</code>的视角来看下如果对网络数据进行收发。</p><p>相对<code>内核</code>来讲，<code>用户空间的IO线程模型</code>相对就简单一些。这些<code>用户空间</code>的<code>IO线程模型</code>都是在讨论当多线程一起配合工作时谁负责接收连接，谁负责响应IO 读写、谁负责计算、谁负责发送和接收，仅仅是用户IO线程的不同分工模式罢了。</p><h2 id="reactor" tabindex="-1"><a class="header-anchor" href="#reactor" aria-hidden="true">#</a> <strong>Reactor</strong></h2><p><code>Reactor</code>是利用<code>NIO</code>对<code>IO线程</code>进行不同的分工：</p><ul><li>使用前边我们提到的<code>IO多路复用模型</code>比如<code>select,poll,epoll,kqueue</code>,进行IO事件的注册和监听。</li><li>将监听到<code>就绪的IO事件</code>分发<code>dispatch</code>到各个具体的处理<code>Handler</code>中进行相应的<code>IO事件处理</code>。</li></ul><p>通过<code>IO多路复用技术</code>就可以不断的监听<code>IO事件</code>，不断的分发<code>dispatch</code>，就像一个<code>反应堆</code>一样，看起来像不断的产生<code>IO事件</code>，因此我们称这种模式为<code>Reactor</code>模型。</p><p>下面我们来看下<code>Reactor模型</code>的三种分类：</p><h3 id="单reactor单线程" tabindex="-1"><a class="header-anchor" href="#单reactor单线程" aria-hidden="true">#</a> <strong>单Reactor单线程</strong></h3><figure><img src="/assets/v2-42a837f93a132ff54a14f87f7c6c91c4_720w-HRvIOAgw.webp" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><code>Reactor模型</code>是依赖<code>IO多路复用技术</code>实现监听<code>IO事件</code>，从而源源不断的产生<code>IO就绪事件</code>，在Linux系统下我们使用<code>epoll</code>来进行<code>IO多路复用</code>，我们以Linux系统为例：</p><ul><li>单<code>Reactor</code>意味着只有一个<code>epoll</code>对象，用来监听所有的事件，比如<code>连接事件</code>，<code>读写事件</code>。</li><li><code>单线程</code>意味着只有一个线程来执行<code>epoll_wait</code>获取<code>IO就绪</code>的<code>Socket</code>，然后对这些就绪的<code>Socket</code>执行读写，以及后边的业务处理也依然是这个线程。</li></ul><p><code>单Reactor单线程</code>模型就好比我们开了一个很小很小的小饭馆，作为老板的我们需要一个人干所有的事情，包括：迎接顾客（<code>accept事件</code>），为顾客介绍菜单等待顾客点菜(<code>IO请求</code>)，做菜（<code>业务处理</code>），上菜（<code>IO响应</code>），送客（<code>断开连接</code>）。</p><h3 id="单reactor多线程" tabindex="-1"><a class="header-anchor" href="#单reactor多线程" aria-hidden="true">#</a> <strong>单Reactor多线程</strong></h3><p>随着客人的增多（<code>并发请求</code>），显然饭馆里的事情只有我们一个人干（<code>单线程</code>）肯定是忙不过来的，这时候我们就需要多招聘一些员工（<code>多线程</code>）来帮着一起干上述的事情。</p><p>于是就有了<code>单Reactor多线程</code>模型：</p><figure><img src="/assets/v2-27c611f3c9857cbb612a22a73965150a_720w-xcbIIkz6.webp" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ul><li>这种模式下，也是只有一个<code>epoll</code>对象来监听所有的<code>IO事件</code>，一个线程来调用<code>epoll_wait</code>获取<code>IO就绪</code>的<code>Socket</code>。</li><li>但是当<code>IO就绪事件</code>产生时，这些<code>IO事件</code>对应处理的业务<code>Handler</code>，我们是通过线程池来执行。这样相比<code>单Reactor单线程</code>模型提高了执行效率，充分发挥了多核CPU的优势。</li></ul><h3 id="主从reactor多线程" tabindex="-1"><a class="header-anchor" href="#主从reactor多线程" aria-hidden="true">#</a> <strong>主从Reactor多线程</strong></h3><p>做任何事情都要区分<code>事情的优先级</code>，我们应该<code>优先高效</code>的去做<code>优先级更高</code>的事情，而不是一股脑不分优先级的全部去做。</p><p>当我们的小饭馆客人越来越多（<code>并发量越来越大</code>），我们就需要扩大饭店的规模，在这个过程中我们发现，<code>迎接客人</code>是饭店最重要的工作，我们要先把客人迎接进来，不能让客人一看人多就走掉，只要客人进来了，哪怕菜做的慢一点也没关系。</p><p>于是，<code>主从Reactor多线程</code>模型就产生了：</p><figure><img src="/assets/v2-e8c4166e6bbc494825c5a83d86dd54ad_720w-fjjNtH_I.webp" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ul><li>我们由原来的<code>单Reactor</code>变为了<code>多Reactor</code>。<code>主Reactor</code>用来优先<code>专门</code>做优先级最高的事情，也就是迎接客人（<code>处理连接事件</code>），对应的处理<code>Handler</code>就是图中的<code>acceptor</code>。</li><li>当创建好连接，建立好对应的<code>socket</code>后，在<code>acceptor</code>中将要监听的<code>read事件</code>注册到<code>从Reactor</code>中，由<code>从Reactor</code>来监听<code>socket</code>上的<code>读写</code>事件。</li><li>最终将读写的业务逻辑处理交给线程池处理。</li></ul><blockquote><p><strong>注意</strong>：这里向<code>从Reactor</code>注册的只是<code>read事件</code>，并没有注册<code>write事件</code>，因为<code>read事件</code>是由<code>epoll内核</code>触发的，而<code>write事件</code>则是由用户业务线程触发的（<code>什么时候发送数据是由具体业务线程决定的</code>），所以<code>write事件</code>理应是由<code>用户业务线程</code>去注册。</p><p>用户线程注册<code>write事件</code>的时机是只有当用户发送的数据<code>无法一次性</code>全部写入<code>buffer</code>时，才会去注册<code>write事件</code>，等待<code>buffer重新可写</code>时，继续写入剩下的发送数据、如果用户线程可以一股脑的将发送数据全部写入<code>buffer</code>，那么也就无需注册<code>write事件</code>到<code>从Reactor</code>中。</p></blockquote><p><code>主从Reactor多线程</code>模型是现在大部分主流网络框架中采用的一种<code>IO线程模型</code>。我们本系列的主题<code>Netty</code>就是用的这种模型。</p><h2 id="proactor" tabindex="-1"><a class="header-anchor" href="#proactor" aria-hidden="true">#</a> <strong>Proactor</strong></h2><p><code>Proactor</code>是基于<code>AIO</code>对<code>IO线程</code>进行分工的一种模型。前边我们介绍了<code>异步IO模型</code>，它是操作系统内核支持的一种全异步编程模型，在<code>数据准备阶段</code>和<code>数据拷贝阶段</code>全程无阻塞。</p><p><code>ProactorIO线程模型</code>将<code>IO事件的监听</code>，<code>IO操作的执行</code>，<code>IO结果的dispatch</code>统统交给<code>内核</code>来做。</p><figure><img src="/assets/v2-e2cca98c30ece048d8c2abc8367762c6_720w-K5892gW9.webp" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><strong><code>Proactor模型</code>组件介绍：</strong></p><ul><li><code>completion handler</code> 为用户程序定义的异步IO操作回调函数，在异步IO操作完成时会被内核回调并通知IO结果。</li><li><code>Completion Event Queue</code> 异步IO操作完成后，会产生对应的<code>IO完成事件</code>，将<code>IO完成事件</code>放入该队列中。</li><li><code>Asynchronous Operation Processor</code> 负责<code>异步IO</code>的执行。执行完成后产生<code>IO完成事件</code>放入<code>Completion Event Queue</code> 队列中。</li><li><code>Proactor</code> 是一个事件循环派发器，负责从<code>Completion Event Queue</code>中获取<code>IO完成事件</code>，并回调与<code>IO完成事件</code>关联的<code>completion handler</code>。</li><li><code>Initiator</code> 初始化异步操作（<code>asynchronous operation</code>）并通过<code>Asynchronous Operation Processor</code>将<code>completion handler</code>和<code>proactor</code>注册到内核。</li></ul><p><strong><code>Proactor模型</code>执行过程：</strong></p><ul><li>用户线程发起<code>aio_read</code>，并告诉<code>内核</code>用户空间中的读缓冲区地址，以便<code>内核</code>完成<code>IO操作</code>将结果放入<code>用户空间</code>的读缓冲区，用户线程直接可以读取结果（<code>无任何阻塞</code>）。</li><li><code>Initiator</code> 初始化<code>aio_read</code>异步读取操作（<code>asynchronous operation</code>）,并将<code>completion handler</code>注册到内核。</li></ul><blockquote><p>在<code>Proactor</code>中我们关心的<code>IO完成事件</code>：内核已经帮我们读好数据并放入我们指定的读缓冲区，用户线程可以直接读取。 在<code>Reactor</code>中我们关心的是<code>IO就绪事件</code>：数据已经到来，但是需要用户线程自己去读取。</p></blockquote><ul><li>此时用户线程就可以做其他事情了，无需等待IO结果。而内核与此同时开始异步执行IO操作。当<code>IO操作</code>完成时会产生一个<code>completion event</code>事件，将这个<code>IO完成事件</code>放入<code>completion event queue</code>中。</li><li><code>Proactor</code>从<code>completion event queue</code>中取出<code>completion event</code>，并回调与<code>IO完成事件</code>关联的<code>completion handler</code>。</li><li>在<code>completion handler</code>中完成业务逻辑处理。</li></ul><h2 id="reactor与proactor对比" tabindex="-1"><a class="header-anchor" href="#reactor与proactor对比" aria-hidden="true">#</a> <strong>Reactor与Proactor对比</strong></h2><ul><li><code>Reactor</code>是基于<code>NIO</code>实现的一种<code>IO线程模型</code>，<code>Proactor</code>是基于<code>AIO</code> 实现的<code>IO线程模型</code>。</li><li><code>Reactor</code>关心的是<code>IO就绪事件</code>，<code>Proactor</code>关心的是<code>IO完成事件</code>。</li><li>在<code>Proactor</code>中，用户程序需要向内核传递<code>用户空间的读缓冲区地址</code>。<code>Reactor</code>则不需要。这也就导致了在<code>Proactor</code>中每个并发操作都要求有独立的缓存区，在内存上有一定的开销。</li><li><code>Proactor</code> 的实现逻辑复杂，编码成本较 <code>Reactor</code>要高很多。</li><li><code>Proactor</code> 在处理<code>高耗时 IO</code>时的性能要高于 <code>Reactor</code>，但对于<code>低耗时 IO</code>的执行效率提升<code>并不明显</code>。</li></ul><h2 id="netty的io模型" tabindex="-1"><a class="header-anchor" href="#netty的io模型" aria-hidden="true">#</a> <strong>Netty的IO模型</strong></h2><p>在我们介绍完<code>网络数据包在内核中的收发过程</code>以及五种<code>IO模型</code>和两种<code>IO线程模型</code>后，现在我们来看下<code>netty</code>中的IO模型是什么样的。</p><p>在我们介绍<code>Reactor IO线程模型</code>的时候提到有三种<code>Reactor模型</code>：<code>单Reactor单线程</code>，<code>单Reactor多线程</code>，<code>主从Reactor多线程</code>。</p><p>这三种<code>Reactor模型</code>在<code>netty</code>中都是支持的，但是我们常用的是<code>主从Reactor多线程模型</code>。</p><p>而我们之前介绍的三种<code>Reactor</code>只是一种模型，是一种设计思想。实际上各种网络框架在实现中并不是严格按照模型来实现的，会有一些小的不同，但大体设计思想上是一样的。</p><p>下面我们来看下<code>netty</code>中的<code>主从Reactor多线程模型</code>是什么样子的？</p><figure><img src="/assets/v2-820ea2248f6e101953ba486fe50cdfba_720w-DCy8K5gY.webp" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ul><li><code>Reactor</code>在<code>netty</code>中是以<code>group</code>的形式出现的，<code>netty</code>中将<code>Reactor</code>分为两组，一组是<code>MainReactorGroup</code>也就是我们在编码中常常看到的<code>EventLoopGroup bossGroup</code>,另一组是<code>SubReactorGroup</code>也就是我们在编码中常常看到的<code>EventLoopGroup workerGroup</code>。</li><li><code>MainReactorGroup</code>中通常只有一个<code>Reactor</code>，专门负责做最重要的事情，也就是监听连接<code>accept</code>事件。当有连接事件产生时，在对应的处理<code>handler acceptor</code>中创建初始化相应的<code>NioSocketChannel</code>（代表一个<code>Socket连接</code>）。然后以<code>负载均衡</code>的方式在<code>SubReactorGroup</code>中选取一个<code>Reactor</code>，注册上去，监听<code>Read事件</code>。</li></ul><blockquote><p><code>MainReactorGroup</code>中只有一个<code>Reactor</code>的原因是，通常我们服务端程序只会<code>绑定监听</code>一个端口，如果要<code>绑定监听</code>多个端口，就会配置多个<code>Reactor</code>。</p></blockquote><ul><li><code>SubReactorGroup</code>中有多个<code>Reactor</code>，具体<code>Reactor</code>的个数可以由系统参数 <code>-D io.netty.eventLoopThreads</code>指定。默认的<code>Reactor</code>的个数为<code>CPU核数 * 2</code>。<code>SubReactorGroup</code>中的<code>Reactor</code>主要负责监听<code>读写事件</code>，每一个<code>Reactor</code>负责监听一组<code>socket连接</code>。将全量的连接<code>分摊</code>在多个<code>Reactor</code>中。</li><li>一个<code>Reactor</code>分配一个<code>IO线程</code>，这个<code>IO线程</code>负责从<code>Reactor</code>中获取<code>IO就绪事件</code>，执行<code>IO调用获取IO数据</code>，执行<code>PipeLine</code>。</li></ul><blockquote><p><code>Socket连接</code>在创建后就被<code>固定的分配</code>给一个<code>Reactor</code>，所以一个<code>Socket连接</code>也只会被一个固定的<code>IO线程</code>执行，每个<code>Socket连接</code>分配一个独立的<code>PipeLine</code>实例，用来编排这个<code>Socket连接</code>上的<code>IO处理逻辑</code>。这种<code>无锁串行化</code>的设计的目的是为了防止多线程并发执行同一个socket连接上的<code>IO逻辑处理</code>，防止出现<code>线程安全问题</code>。同时使系统吞吐量达到最大化</p><p>由于每个<code>Reactor</code>中只有一个<code>IO线程</code>，这个<code>IO线程</code>既要执行<code>IO活跃Socket连接</code>对应的<code>PipeLine</code>中的<code>ChannelHandler</code>，又要从<code>Reactor</code>中获取<code>IO就绪事件</code>，执行<code>IO调用</code>。所以<code>PipeLine</code>中<code>ChannelHandler</code>中执行的逻辑不能耗时太长，尽量将耗时的业务逻辑处理放入单独的业务线程池中处理，否则会影响其他连接的<code>IO读写</code>，从而近一步影响整个服务程序的<code>IO吞吐</code>。</p></blockquote><ul><li>当<code>IO请求</code>在业务线程中完成相应的业务逻辑处理后，在业务线程中利用持有的<code>ChannelHandlerContext</code>引用将响应数据在<code>PipeLine</code>中反向传播，最终写回给客户端。</li></ul><p><code>netty</code>中的<code>IO模型</code>我们介绍完了，下面我们来简单介绍下在<code>netty</code>中是如何支持前边提到的三种<code>Reactor模型</code>的。</p><h3 id="配置单reactor单线程" tabindex="-1"><a class="header-anchor" href="#配置单reactor单线程" aria-hidden="true">#</a> <strong>配置单Reactor单线程</strong></h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>EventLoopGroup eventGroup = new NioEventLoopGroup(1);
ServerBootstrap serverBootstrap = new ServerBootstrap(); 
serverBootstrap.group(eventGroup);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="配置单reactor多线程" tabindex="-1"><a class="header-anchor" href="#配置单reactor多线程" aria-hidden="true">#</a> <strong>配置单Reactor多线程</strong></h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>EventLoopGroup eventGroup = new NioEventLoopGroup();
ServerBootstrap serverBootstrap = new ServerBootstrap(); 
serverBootstrap.group(eventGroup);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="配置主从reactor多线程" tabindex="-1"><a class="header-anchor" href="#配置主从reactor多线程" aria-hidden="true">#</a> <strong>配置主从Reactor多线程</strong></h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>EventLoopGroup bossGroup = new NioEventLoopGroup(1); 
EventLoopGroup workerGroup = new NioEventLoopGroup();
ServerBootstrap serverBootstrap = new ServerBootstrap(); 
serverBootstrap.group(bossGroup, workerGroup);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div><!--[--><!----><!--]--><footer class="page-meta"><!----><div class="meta-item git-info"><div class="update-time"><span class="label">上次编辑于: </span><!----></div><div class="contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: 554417388@qq.com">honyelchak</span><!--]--><!--]--></div></div></footer><nav class="vp-page-nav"><a aria-label="/interview/A8-中间件/nginx" class="vp-link nav-link prev nav-link prev" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx.html"><div class="hint"><span class="arrow start"></span>上一页</div><div class="link"><!---->/interview/A8-中间件/nginx</div></a><a aria-label="常见问题" class="vp-link nav-link next nav-link next" href="/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.html"><div class="hint">下一页<span class="arrow end"></span></div><div class="link">常见问题<!----></div></a></nav><!----><!--[--><!----><!--]--><!--]--></main><!--]--><footer class="vp-footer-wrapper"><!----><div class="vp-copyright">Copyright © 2023 Honyelchak</div></footer></div><!--]--><!----><!----><!--]--></div>
    <script type="module" src="/assets/app-_dQeDwys.js" defer></script>
  </body>
</html>
