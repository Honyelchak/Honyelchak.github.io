<!doctype html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.0" />
    <meta name="theme" content="VuePress Theme Hope 2.0.0-rc.1" />
    <style>
      html {
        background: var(--bg-color, #fff);
      }

      html[data-theme="dark"] {
        background: var(--bg-color, #1d1e1f);
      }

      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <meta property="og:url" content="https://yuejinzhao.cn/interview/A4-Java/Java%E9%9B%86%E5%90%88.html"><meta property="og:site_name" content="Honyelchak's Blog"><meta property="og:description" content="Java容器概述 容器主要包括Collection和Map两种，Collection存储着对象的集合，而Map存储着键值对的映射表。 Collection img 1. Set TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。 注意，她是实现了SortedSet接口，所以有序。 **底层实现调用TreeMap的构造方法，**key为set中的值，Value为object对象。 // Dummy value to associate with an Object in the backing Map private static final Object PRESENT = new Object(); 添加、删除、包含等操作时间复杂度O(logN) HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。 元素都存到HashMap键值对的Key上面，而Value时有一个统一的值private static final Object PRESENT = new Object();，(定义一个虚拟的Object对象作为HashMap的value，将此对象定义为static final。) 实际底层会初始化一个空的HashMap，并使用默认初始容量为16和加载因子0.75。max((old*0.75)+1),16) 添加、删除、查找效率都是O（1） LinkedHashSet：具有 HashSet 的查找效率，并且内部使用双向链表维护元素的插入顺序。 继承了HashSet的构造方法，该方法是包访问权限，外部不能访问。 HashSet(int initialCapacity, float loadFactor, boolean dummy) { map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor); } 添加、删除、查找效率都是O（1）"><meta property="og:type" content="article"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2023-12-02T09:42:10.000Z"><meta property="article:author" content="Honyelchak"><meta property="article:modified_time" content="2023-12-02T09:42:10.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"","image":[""],"dateModified":"2023-12-02T09:42:10.000Z","author":[{"@type":"Person","name":"Honyelchak","url":"https://yuejinzhao.cn"}]}</script><title>Honyelchak's Blog</title><meta name="description" content="Java容器概述 容器主要包括Collection和Map两种，Collection存储着对象的集合，而Map存储着键值对的映射表。 Collection img 1. Set TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。 注意，她是实现了SortedSet接口，所以有序。 **底层实现调用TreeMap的构造方法，**key为set中的值，Value为object对象。 // Dummy value to associate with an Object in the backing Map private static final Object PRESENT = new Object(); 添加、删除、包含等操作时间复杂度O(logN) HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。 元素都存到HashMap键值对的Key上面，而Value时有一个统一的值private static final Object PRESENT = new Object();，(定义一个虚拟的Object对象作为HashMap的value，将此对象定义为static final。) 实际底层会初始化一个空的HashMap，并使用默认初始容量为16和加载因子0.75。max((old*0.75)+1),16) 添加、删除、查找效率都是O（1） LinkedHashSet：具有 HashSet 的查找效率，并且内部使用双向链表维护元素的插入顺序。 继承了HashSet的构造方法，该方法是包访问权限，外部不能访问。 HashSet(int initialCapacity, float loadFactor, boolean dummy) { map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor); } 添加、删除、查找效率都是O（1）">
    <link rel="preload" href="/assets/style-s-J8-r2b.css" as="style"><link rel="stylesheet" href="/assets/style-s-J8-r2b.css">
    <link rel="modulepreload" href="/assets/app-XffPLay1.js"><link rel="modulepreload" href="/assets/Java集合.html-bFAuWw1F.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper-x3n3nnut.js"><link rel="modulepreload" href="/assets/Java集合.html-yrDYFwRv.js">
    <link rel="prefetch" href="/assets/index.html-TJyD3cLk.js" as="script"><link rel="prefetch" href="/assets/intro.html-1OPW3V7h.js" as="script"><link rel="prefetch" href="/assets/project.html-1c2u4iC9.js" as="script"><link rel="prefetch" href="/assets/slides.html-lVESjsnf.js" as="script"><link rel="prefetch" href="/assets/cherry.html-nS81mElm.js" as="script"><link rel="prefetch" href="/assets/index.html-4H3YBJgo.js" as="script"><link rel="prefetch" href="/assets/disable.html-dU7RYcGn.js" as="script"><link rel="prefetch" href="/assets/encrypt.html-khbb8xwB.js" as="script"><link rel="prefetch" href="/assets/markdown.html-Yx5_DxvR.js" as="script"><link rel="prefetch" href="/assets/page.html-OnIm-J2S.js" as="script"><link rel="prefetch" href="/assets/Git.html-oNpdMzPA.js" as="script"><link rel="prefetch" href="/assets/JavaWeb.html-oc6THKuy.js" as="script"><link rel="prefetch" href="/assets/Java复习汇总.html-FEkRgJDv.js" as="script"><link rel="prefetch" href="/assets/LeetCode.html-wZBUP_Cp.js" as="script"><link rel="prefetch" href="/assets/Mybatis.html-rQMkYXsT.js" as="script"><link rel="prefetch" href="/assets/Netty.html-UvLeulHs.js" as="script"><link rel="prefetch" href="/assets/Untitled.html-wpkW5Hz-.js" as="script"><link rel="prefetch" href="/assets/个人剖析.html-Qux-C6vI.js" as="script"><link rel="prefetch" href="/assets/奇奇怪怪的问题.html-R2AxlnQN.js" as="script"><link rel="prefetch" href="/assets/数据结构.html-AaLXwRzK.js" as="script"><link rel="prefetch" href="/assets/斗智斗勇.html-jr6x8I8D.js" as="script"><link rel="prefetch" href="/assets/简历埋点.html-IhryRitK.js" as="script"><link rel="prefetch" href="/assets/dragonfruit.html-REUIcmkv.js" as="script"><link rel="prefetch" href="/assets/strawberry.html-13YPqcHt.js" as="script"><link rel="prefetch" href="/assets/tomato.html-NhdZoPTn.js" as="script"><link rel="prefetch" href="/assets/前缀和题单.html-R6MndNAg.js" as="script"><link rel="prefetch" href="/assets/原则.html-JA6wxwpp.js" as="script"><link rel="prefetch" href="/assets/小知识点.html-fagpbEUh.js" as="script"><link rel="prefetch" href="/assets/由数据范围反推算法复杂度以及算法内容.html-xpUkKYl-.js" as="script"><link rel="prefetch" href="/assets/面试常考算法模板.html-i0XZjljp.js" as="script"><link rel="prefetch" href="/assets/DP.html-WiFxcle4.js" as="script"><link rel="prefetch" href="/assets/LIS.html-h-dqg6Hf.js" as="script"><link rel="prefetch" href="/assets/区间DP.html-xTd8Gfqw.js" as="script"><link rel="prefetch" href="/assets/数位DP.html-22nQiboi.js" as="script"><link rel="prefetch" href="/assets/数字三角形模型.html-Hd6I0qCy.js" as="script"><link rel="prefetch" href="/assets/斜率优化DP.html-lma1t9G6.js" as="script"><link rel="prefetch" href="/assets/树形DP.html-rHCeZz09.js" as="script"><link rel="prefetch" href="/assets/状态压缩DP.html-SLYf7WbL.js" as="script"><link rel="prefetch" href="/assets/状态机.html-LLzfw_7m.js" as="script"><link rel="prefetch" href="/assets/二分.html-QNEhReAH.js" as="script"><link rel="prefetch" href="/assets/位运算.html-2eHDuHWH.js" as="script"><link rel="prefetch" href="/assets/前缀和.html-6mcJEeIr.js" as="script"><link rel="prefetch" href="/assets/快速幂.html-EdHQND9b.js" as="script"><link rel="prefetch" href="/assets/离散化.html-SrTvrZlI.js" as="script"><link rel="prefetch" href="/assets/BFS.html-zULDF6Cv.js" as="script"><link rel="prefetch" href="/assets/DFS.html-Zyq1Alr7.js" as="script"><link rel="prefetch" href="/assets/单调栈.html-m2BDrvPz.js" as="script"><link rel="prefetch" href="/assets/并查集.html-XgWBTZ1x.js" as="script"><link rel="prefetch" href="/assets/树状数组.html-LDW52PBO.js" as="script"><link rel="prefetch" href="/assets/线段树.html-mWchzgBB.js" as="script"><link rel="prefetch" href="/assets/STL.html-ph9XXeW4.js" as="script"><link rel="prefetch" href="/assets/基础算法.html-Vih4xw3c.js" as="script"><link rel="prefetch" href="/assets/搜索与图论.html-qOdq5f8p.js" as="script"><link rel="prefetch" href="/assets/数据结构.html-KpibRNSM.js" as="script"><link rel="prefetch" href="/assets/贪心.html-1uHjL1bO.js" as="script"><link rel="prefetch" href="/assets/CPU.html-nRszTbKA.js" as="script"><link rel="prefetch" href="/assets/Linux常用命令及线上项目调优.html-xJNWFxx_.js" as="script"><link rel="prefetch" href="/assets/操作系统.html-j-jahRCL.js" as="script"><link rel="prefetch" href="/assets/IP.html-ooHZS7Ra.js" as="script"><link rel="prefetch" href="/assets/IP冲突.html-yrytBUBs.js" as="script"><link rel="prefetch" href="/assets/Netty.html-SbVYJtub.js" as="script"><link rel="prefetch" href="/assets/UDT和QUIC.html-zBnAWslA.js" as="script"><link rel="prefetch" href="/assets/网络问题.html-iokrm3Ka.js" as="script"><link rel="prefetch" href="/assets/计算机网络.html-51AKb3zX.js" as="script"><link rel="prefetch" href="/assets/MVCC多版本并发控制.html-6oHzKDEC.js" as="script"><link rel="prefetch" href="/assets/MySQL数据库性能优化.html-SWW1Elbi.js" as="script"><link rel="prefetch" href="/assets/MySQL相关指令.html-w15QIOSt.js" as="script"><link rel="prefetch" href="/assets/SQL.html-Men8iY6P.js" as="script"><link rel="prefetch" href="/assets/SQL优化.html-9YVl9_PD.js" as="script"><link rel="prefetch" href="/assets/mysql的加锁情况.html-lQuvXxK7.js" as="script"><link rel="prefetch" href="/assets/手撕SQL.html-I1oi0HDI.js" as="script"><link rel="prefetch" href="/assets/金三银四Mysql面试突击班.html-lXCakC7i.js" as="script"><link rel="prefetch" href="/assets/锁.html-iL1ZA_qB.js" as="script"><link rel="prefetch" href="/assets/IO.html-vaADi92u.js" as="script"><link rel="prefetch" href="/assets/Java8新特性.html-uXOwhN5b.js" as="script"><link rel="prefetch" href="/assets/Java基础.html-cd-t6WYR.js" as="script"><link rel="prefetch" href="/assets/Java疑难点.html-A39ZJ9uH.js" as="script"><link rel="prefetch" href="/assets/Streams.html-OlVuTBBp.js" as="script"><link rel="prefetch" href="/assets/查漏补缺.html-aQg5QtiM.js" as="script"><link rel="prefetch" href="/assets/SpringBoot.html-RfMG4wQo.js" as="script"><link rel="prefetch" href="/assets/SpringBoot配置文件.html-gblPkDkU.js" as="script"><link rel="prefetch" href="/assets/SpringMVC.html-edpw_Lqq.js" as="script"><link rel="prefetch" href="/assets/Spring启动过程.html-Fb0gjLIE.js" as="script"><link rel="prefetch" href="/assets/Spring框架.html-iUnC64L5.js" as="script"><link rel="prefetch" href="/assets/Spring框架面试题.html-A-6vPun2.js" as="script"><link rel="prefetch" href="/assets/Spring源码阅读.html-64253mtH.js" as="script"><link rel="prefetch" href="/assets/Spring面试题(1).html-XSPzLdxS.js" as="script"><link rel="prefetch" href="/assets/Spring面试题.html-gPZhge76.js" as="script"><link rel="prefetch" href="/assets/奇奇怪怪的Spring问题.html-UijzzvQ2.js" as="script"><link rel="prefetch" href="/assets/循坏依赖专题.html-s9pUwxWS.js" as="script"><link rel="prefetch" href="/assets/手写一个Spring框架.html-LGw0GIVU.js" as="script"><link rel="prefetch" href="/assets/设计模式专题.html-AXq-b0LV.js" as="script"><link rel="prefetch" href="/assets/12306项目分析.html-29vrC0KF.js" as="script"><link rel="prefetch" href="/assets/12306项目查漏补缺.html-nIqK_YML.js" as="script"><link rel="prefetch" href="/assets/QPS20W接口测试.html-qgDvHIgZ.js" as="script"><link rel="prefetch" href="/assets/分布式雪花算法.html-2QXODQGV.js" as="script"><link rel="prefetch" href="/assets/单机20W并发的接口设计.html-zgC7QT4Y.js" as="script"><link rel="prefetch" href="/assets/项目相关.html-gsRLX_K0.js" as="script"><link rel="prefetch" href="/assets/基本理论.html-hG_H3x4V.js" as="script"><link rel="prefetch" href="/assets/Netty.html-4dzw_auG.js" as="script"><link rel="prefetch" href="/assets/nginx.html-MAoy_qLU.js" as="script"><link rel="prefetch" href="/assets/消息队列.html-fVGKtE-R.js" as="script"><link rel="prefetch" href="/assets/2019常见面试题.html-8XyYraer.js" as="script"><link rel="prefetch" href="/assets/Java面试题(答案).html-v1wiLhXn.js" as="script"><link rel="prefetch" href="/assets/Java面试题.html-uBWc-U87.js" as="script"><link rel="prefetch" href="/assets/面试常问的问题.html-1uWz3eOz.js" as="script"><link rel="prefetch" href="/assets/网络.html--mrgvBP1.js" as="script"><link rel="prefetch" href="/assets/测试安全问题.html-8OCb_kvc.js" as="script"><link rel="prefetch" href="/assets/RISC-V.html-5Cl8EY3X.js" as="script"><link rel="prefetch" href="/assets/秒杀.html-8mH6jTUa.js" as="script"><link rel="prefetch" href="/assets/1.html-l7LwHYr5.js" as="script"><link rel="prefetch" href="/assets/2.html-iDGX3PdD.js" as="script"><link rel="prefetch" href="/assets/3.html-xxZpy1PR.js" as="script"><link rel="prefetch" href="/assets/4.html-KVfWHQvA.js" as="script"><link rel="prefetch" href="/assets/1.html-2P9V0Zzm.js" as="script"><link rel="prefetch" href="/assets/2.html-zjevKTJb.js" as="script"><link rel="prefetch" href="/assets/3.html-KmAMgI8v.js" as="script"><link rel="prefetch" href="/assets/4.html-dKO_Yw-C.js" as="script"><link rel="prefetch" href="/assets/Floyd.html-18LX8b2q.js" as="script"><link rel="prefetch" href="/assets/综述.html-HIG0Tx1T.js" as="script"><link rel="prefetch" href="/assets/基本理论.html-UC_YVBxj.js" as="script"><link rel="prefetch" href="/assets/次小生成树.html-xXEOF_Je.js" as="script"><link rel="prefetch" href="/assets/网络.html-MIXrv6fO.js" as="script"><link rel="prefetch" href="/assets/Redis.html-jY6OUvTt.js" as="script"><link rel="prefetch" href="/assets/Redis削峰.html-hcDk-sZ4.js" as="script"><link rel="prefetch" href="/assets/redis配置文件.html-awJcFh1H.js" as="script"><link rel="prefetch" href="/assets/缓存和数据库双写一致性.html-ftB7L-E1.js" as="script"><link rel="prefetch" href="/assets/缓存更新策略.html-Ws8dPBI1.js" as="script"><link rel="prefetch" href="/assets/ReentrantLock中的lockInterruptibly和lock.html-8jVpnec5.js" as="script"><link rel="prefetch" href="/assets/多线程题目.html-LA_QYezZ.js" as="script"><link rel="prefetch" href="/assets/多线程高并发笔记.html-Irdva4SV.js" as="script"><link rel="prefetch" href="/assets/并发.html-_Un2zYtv.js" as="script"><link rel="prefetch" href="/assets/线程池.html-uyUy7hhG.js" as="script"><link rel="prefetch" href="/assets/JVM.html-CYW6uuHo.js" as="script"><link rel="prefetch" href="/assets/JVM上.html-icNsX-58.js" as="script"><link rel="prefetch" href="/assets/JVM下.html-KjBqO_ew.js" as="script"><link rel="prefetch" href="/assets/JVM中.html-dmvqAVCm.js" as="script"><link rel="prefetch" href="/assets/JVM面试 (copy).html-n1-HiW0B.js" as="script"><link rel="prefetch" href="/assets/JVM面试.html-sxIWVtxC.js" as="script"><link rel="prefetch" href="/assets/404.html-tlyei_5h.js" as="script"><link rel="prefetch" href="/assets/index.html-5JTjs8mG.js" as="script"><link rel="prefetch" href="/assets/index.html--YxBfJSp.js" as="script"><link rel="prefetch" href="/assets/index.html-71JEMejL.js" as="script"><link rel="prefetch" href="/assets/index.html-ITzakDtH.js" as="script"><link rel="prefetch" href="/assets/index.html-fjktaOAH.js" as="script"><link rel="prefetch" href="/assets/index.html-ysR9goIb.js" as="script"><link rel="prefetch" href="/assets/index.html-DJ7Ym7Iq.js" as="script"><link rel="prefetch" href="/assets/index.html-tyJNw07b.js" as="script"><link rel="prefetch" href="/assets/index.html-d7UHyMoy.js" as="script"><link rel="prefetch" href="/assets/index.html-tBkkuQ9X.js" as="script"><link rel="prefetch" href="/assets/index.html-oYedy5bF.js" as="script"><link rel="prefetch" href="/assets/index.html-WqtN1zQQ.js" as="script"><link rel="prefetch" href="/assets/index.html-o-IVSgtO.js" as="script"><link rel="prefetch" href="/assets/index.html-1E9AP5fk.js" as="script"><link rel="prefetch" href="/assets/index.html-me3FmHfA.js" as="script"><link rel="prefetch" href="/assets/index.html-nZyBrfgS.js" as="script"><link rel="prefetch" href="/assets/index.html-Ca2m7Cu4.js" as="script"><link rel="prefetch" href="/assets/index.html-gjy07egy.js" as="script"><link rel="prefetch" href="/assets/index.html-pMhppvm1.js" as="script"><link rel="prefetch" href="/assets/index.html-a4Ze5x_t.js" as="script"><link rel="prefetch" href="/assets/index.html-TAN0vn8L.js" as="script"><link rel="prefetch" href="/assets/index.html-nGmkbY1x.js" as="script"><link rel="prefetch" href="/assets/index.html-312PX0oj.js" as="script"><link rel="prefetch" href="/assets/index.html-ObEgcdx_.js" as="script"><link rel="prefetch" href="/assets/index.html-DcRl1Zu4.js" as="script"><link rel="prefetch" href="/assets/index.html-RYgsJuRz.js" as="script"><link rel="prefetch" href="/assets/index.html-0hP2H4N-.js" as="script"><link rel="prefetch" href="/assets/index.html-jSgb6ZKH.js" as="script"><link rel="prefetch" href="/assets/index.html-mP0vS9o6.js" as="script"><link rel="prefetch" href="/assets/index.html-9U3Hmi6I.js" as="script"><link rel="prefetch" href="/assets/index.html-Lx5ri6mA.js" as="script"><link rel="prefetch" href="/assets/index.html-V0HSX5Sw.js" as="script"><link rel="prefetch" href="/assets/index.html--RD3L-9a.js" as="script"><link rel="prefetch" href="/assets/index.html-TLF0Maaf.js" as="script"><link rel="prefetch" href="/assets/index.html-7B1umk9D.js" as="script"><link rel="prefetch" href="/assets/index.html-LDS5hg0b.js" as="script"><link rel="prefetch" href="/assets/index.html-03f83TYL.js" as="script"><link rel="prefetch" href="/assets/index.html-Vm7CMeJ9.js" as="script"><link rel="prefetch" href="/assets/index.html-PxwaX4D5.js" as="script"><link rel="prefetch" href="/assets/index.html-GD-sGv9o.js" as="script"><link rel="prefetch" href="/assets/index.html-7fHiBdve.js" as="script"><link rel="prefetch" href="/assets/index.html-uaVWCPeu.js" as="script"><link rel="prefetch" href="/assets/index.html-9Qhj3LDt.js" as="script"><link rel="prefetch" href="/assets/index.html-1pEV0-DQ.js" as="script"><link rel="prefetch" href="/assets/index.html-HG-dF-LV.js" as="script"><link rel="prefetch" href="/assets/index.html-Awfi2Oy0.js" as="script"><link rel="prefetch" href="/assets/index.html-kjfsO1qY.js" as="script"><link rel="prefetch" href="/assets/index.html-m-ubR1oj.js" as="script"><link rel="prefetch" href="/assets/index.html-zti7c-jn.js" as="script"><link rel="prefetch" href="/assets/index.html-yLAg9VY_.js" as="script"><link rel="prefetch" href="/assets/index.html-FUeLVl_L.js" as="script"><link rel="prefetch" href="/assets/index.html-OqUPM_6t.js" as="script"><link rel="prefetch" href="/assets/index.html-FvD6AmyZ.js" as="script"><link rel="prefetch" href="/assets/index.html-IzKBN8uZ.js" as="script"><link rel="prefetch" href="/assets/index.html-hx-a2twd.js" as="script"><link rel="prefetch" href="/assets/index.html-BQhJTnsp.js" as="script"><link rel="prefetch" href="/assets/index.html-4T1nTBMu.js" as="script"><link rel="prefetch" href="/assets/index.html-ScVKcEtW.js" as="script"><link rel="prefetch" href="/assets/intro.html-Btr7dcz9.js" as="script"><link rel="prefetch" href="/assets/project.html-DuOxnou1.js" as="script"><link rel="prefetch" href="/assets/slides.html-OITLZHwS.js" as="script"><link rel="prefetch" href="/assets/cherry.html-hHHnzJm2.js" as="script"><link rel="prefetch" href="/assets/index.html-JAfnEwX3.js" as="script"><link rel="prefetch" href="/assets/disable.html-JrA5mQF2.js" as="script"><link rel="prefetch" href="/assets/encrypt.html-HKbA9Uo4.js" as="script"><link rel="prefetch" href="/assets/markdown.html-b7igiOkV.js" as="script"><link rel="prefetch" href="/assets/page.html-M2kx6ttv.js" as="script"><link rel="prefetch" href="/assets/Git.html-wvhvR0Lf.js" as="script"><link rel="prefetch" href="/assets/JavaWeb.html-ttHy5Pg6.js" as="script"><link rel="prefetch" href="/assets/Java复习汇总.html-pwvgwqKs.js" as="script"><link rel="prefetch" href="/assets/LeetCode.html-GOcY2gJ8.js" as="script"><link rel="prefetch" href="/assets/Mybatis.html-mmQ68U55.js" as="script"><link rel="prefetch" href="/assets/Netty.html-IAa_dYvA.js" as="script"><link rel="prefetch" href="/assets/Untitled.html-xvPFXzK6.js" as="script"><link rel="prefetch" href="/assets/个人剖析.html-sob8ZsoV.js" as="script"><link rel="prefetch" href="/assets/奇奇怪怪的问题.html-JnJR51-g.js" as="script"><link rel="prefetch" href="/assets/数据结构.html-L51DapCO.js" as="script"><link rel="prefetch" href="/assets/斗智斗勇.html-XfoEqthS.js" as="script"><link rel="prefetch" href="/assets/简历埋点.html-aQQoZFki.js" as="script"><link rel="prefetch" href="/assets/dragonfruit.html-HgcPNqW6.js" as="script"><link rel="prefetch" href="/assets/strawberry.html-dgSMM10r.js" as="script"><link rel="prefetch" href="/assets/tomato.html-jIk57h5K.js" as="script"><link rel="prefetch" href="/assets/前缀和题单.html-I8w2Js7p.js" as="script"><link rel="prefetch" href="/assets/原则.html-qQqK7wQL.js" as="script"><link rel="prefetch" href="/assets/小知识点.html-cr4knv7F.js" as="script"><link rel="prefetch" href="/assets/由数据范围反推算法复杂度以及算法内容.html-ga38vikl.js" as="script"><link rel="prefetch" href="/assets/面试常考算法模板.html-x_2V_Bo4.js" as="script"><link rel="prefetch" href="/assets/DP.html-rFZxEoxz.js" as="script"><link rel="prefetch" href="/assets/LIS.html-eubOQP2u.js" as="script"><link rel="prefetch" href="/assets/区间DP.html-ihIWPKLS.js" as="script"><link rel="prefetch" href="/assets/数位DP.html-9xtzL4fQ.js" as="script"><link rel="prefetch" href="/assets/数字三角形模型.html-4Rdo0--X.js" as="script"><link rel="prefetch" href="/assets/斜率优化DP.html-89YC1DMN.js" as="script"><link rel="prefetch" href="/assets/树形DP.html-EaKhk3Or.js" as="script"><link rel="prefetch" href="/assets/状态压缩DP.html-3eYsKd0n.js" as="script"><link rel="prefetch" href="/assets/状态机.html-Q2hyQ3ZW.js" as="script"><link rel="prefetch" href="/assets/二分.html-K3kWc0Bz.js" as="script"><link rel="prefetch" href="/assets/位运算.html-2rCAmOdJ.js" as="script"><link rel="prefetch" href="/assets/前缀和.html-9bQdn1MM.js" as="script"><link rel="prefetch" href="/assets/快速幂.html-2iKXmh7V.js" as="script"><link rel="prefetch" href="/assets/离散化.html-qNVKTvtR.js" as="script"><link rel="prefetch" href="/assets/BFS.html-invZZBny.js" as="script"><link rel="prefetch" href="/assets/DFS.html-bAMp6S7n.js" as="script"><link rel="prefetch" href="/assets/单调栈.html-gEWRFc_g.js" as="script"><link rel="prefetch" href="/assets/并查集.html-2xowWMWD.js" as="script"><link rel="prefetch" href="/assets/树状数组.html-o6mgxJiW.js" as="script"><link rel="prefetch" href="/assets/线段树.html-jFZm5XsR.js" as="script"><link rel="prefetch" href="/assets/STL.html-9M0M6tnx.js" as="script"><link rel="prefetch" href="/assets/基础算法.html-DO793I0x.js" as="script"><link rel="prefetch" href="/assets/搜索与图论.html-XysCBKLq.js" as="script"><link rel="prefetch" href="/assets/数据结构.html-UsGTKgI7.js" as="script"><link rel="prefetch" href="/assets/贪心.html-qKWhbgX5.js" as="script"><link rel="prefetch" href="/assets/CPU.html-M336sDLn.js" as="script"><link rel="prefetch" href="/assets/Linux常用命令及线上项目调优.html-Zhf5vBEK.js" as="script"><link rel="prefetch" href="/assets/操作系统.html-1xODakNM.js" as="script"><link rel="prefetch" href="/assets/IP.html-HCtdFAn3.js" as="script"><link rel="prefetch" href="/assets/IP冲突.html-jEE9vWFf.js" as="script"><link rel="prefetch" href="/assets/Netty.html-ad_orNmX.js" as="script"><link rel="prefetch" href="/assets/UDT和QUIC.html--KwxgePH.js" as="script"><link rel="prefetch" href="/assets/网络问题.html-mwCGcx4r.js" as="script"><link rel="prefetch" href="/assets/计算机网络.html-xQViSYm-.js" as="script"><link rel="prefetch" href="/assets/MVCC多版本并发控制.html-kQoPyD2u.js" as="script"><link rel="prefetch" href="/assets/MySQL数据库性能优化.html-QnaQOpyL.js" as="script"><link rel="prefetch" href="/assets/MySQL相关指令.html-UxnFRjnJ.js" as="script"><link rel="prefetch" href="/assets/SQL.html-Wu1_kO4a.js" as="script"><link rel="prefetch" href="/assets/SQL优化.html-Vn-iepPw.js" as="script"><link rel="prefetch" href="/assets/mysql的加锁情况.html-Q1TAZHkB.js" as="script"><link rel="prefetch" href="/assets/手撕SQL.html-R5BLWwW2.js" as="script"><link rel="prefetch" href="/assets/金三银四Mysql面试突击班.html-c5aIxm-7.js" as="script"><link rel="prefetch" href="/assets/锁.html-nRH691v0.js" as="script"><link rel="prefetch" href="/assets/IO.html-1j_7QfbT.js" as="script"><link rel="prefetch" href="/assets/Java8新特性.html-nNeqSpRc.js" as="script"><link rel="prefetch" href="/assets/Java基础.html-vywmIluC.js" as="script"><link rel="prefetch" href="/assets/Java疑难点.html-SuvhnZqA.js" as="script"><link rel="prefetch" href="/assets/Streams.html-oVycu5oy.js" as="script"><link rel="prefetch" href="/assets/查漏补缺.html-VwoQsGta.js" as="script"><link rel="prefetch" href="/assets/SpringBoot.html-Zmx1nCq5.js" as="script"><link rel="prefetch" href="/assets/SpringBoot配置文件.html-VZbLvHp2.js" as="script"><link rel="prefetch" href="/assets/SpringMVC.html-Erf_vbdY.js" as="script"><link rel="prefetch" href="/assets/Spring启动过程.html--YYtoP_c.js" as="script"><link rel="prefetch" href="/assets/Spring框架.html-pVRBSDnk.js" as="script"><link rel="prefetch" href="/assets/Spring框架面试题.html-GZjYbscR.js" as="script"><link rel="prefetch" href="/assets/Spring源码阅读.html-enmTCr2j.js" as="script"><link rel="prefetch" href="/assets/Spring面试题(1).html-h44klZbV.js" as="script"><link rel="prefetch" href="/assets/Spring面试题.html-S-t4SA6X.js" as="script"><link rel="prefetch" href="/assets/奇奇怪怪的Spring问题.html-SsRgU8TZ.js" as="script"><link rel="prefetch" href="/assets/循坏依赖专题.html-7ZgWjM6J.js" as="script"><link rel="prefetch" href="/assets/手写一个Spring框架.html-m7o2oO7r.js" as="script"><link rel="prefetch" href="/assets/设计模式专题.html-38ezceov.js" as="script"><link rel="prefetch" href="/assets/12306项目分析.html--rXfCM4f.js" as="script"><link rel="prefetch" href="/assets/12306项目查漏补缺.html-Hd4tc_Ri.js" as="script"><link rel="prefetch" href="/assets/QPS20W接口测试.html-NQ8YI84M.js" as="script"><link rel="prefetch" href="/assets/分布式雪花算法.html-D1IICyV_.js" as="script"><link rel="prefetch" href="/assets/单机20W并发的接口设计.html-iqt5kPf2.js" as="script"><link rel="prefetch" href="/assets/项目相关.html-d5ksScE4.js" as="script"><link rel="prefetch" href="/assets/基本理论.html-UaIC3yDk.js" as="script"><link rel="prefetch" href="/assets/Netty.html-H2P_r0Ma.js" as="script"><link rel="prefetch" href="/assets/nginx.html-OEwYwf0A.js" as="script"><link rel="prefetch" href="/assets/消息队列.html--HjWy6zQ.js" as="script"><link rel="prefetch" href="/assets/2019常见面试题.html-lDghE0eR.js" as="script"><link rel="prefetch" href="/assets/Java面试题(答案).html-Q-04q967.js" as="script"><link rel="prefetch" href="/assets/Java面试题.html-glz9mdrL.js" as="script"><link rel="prefetch" href="/assets/面试常问的问题.html-PafeLn-m.js" as="script"><link rel="prefetch" href="/assets/网络.html-LKzgEq3y.js" as="script"><link rel="prefetch" href="/assets/测试安全问题.html-McKSqurk.js" as="script"><link rel="prefetch" href="/assets/RISC-V.html-fPI6NEaG.js" as="script"><link rel="prefetch" href="/assets/秒杀.html-YRR16x5n.js" as="script"><link rel="prefetch" href="/assets/1.html-_OvMJj-V.js" as="script"><link rel="prefetch" href="/assets/2.html-xM2hkmqH.js" as="script"><link rel="prefetch" href="/assets/3.html-W09Fsjls.js" as="script"><link rel="prefetch" href="/assets/4.html-15gB866O.js" as="script"><link rel="prefetch" href="/assets/1.html-hqXgjQrc.js" as="script"><link rel="prefetch" href="/assets/2.html-KMK4dJ5A.js" as="script"><link rel="prefetch" href="/assets/3.html-cP5czuMP.js" as="script"><link rel="prefetch" href="/assets/4.html-1QDIEuwL.js" as="script"><link rel="prefetch" href="/assets/Floyd.html-YULvdW-B.js" as="script"><link rel="prefetch" href="/assets/综述.html-YRMKewZn.js" as="script"><link rel="prefetch" href="/assets/基本理论.html-JDdh1Mgp.js" as="script"><link rel="prefetch" href="/assets/次小生成树.html-l97RZ3cT.js" as="script"><link rel="prefetch" href="/assets/网络.html-PmqpBcmq.js" as="script"><link rel="prefetch" href="/assets/Redis.html-C4Yt6-G2.js" as="script"><link rel="prefetch" href="/assets/Redis削峰.html-lvw2OGaD.js" as="script"><link rel="prefetch" href="/assets/redis配置文件.html-7GLt3Uc7.js" as="script"><link rel="prefetch" href="/assets/缓存和数据库双写一致性.html-_sHlKiGP.js" as="script"><link rel="prefetch" href="/assets/缓存更新策略.html-5IzFK9hS.js" as="script"><link rel="prefetch" href="/assets/ReentrantLock中的lockInterruptibly和lock.html-2E0gHsqp.js" as="script"><link rel="prefetch" href="/assets/多线程题目.html-u_molY2F.js" as="script"><link rel="prefetch" href="/assets/多线程高并发笔记.html-34fq-82S.js" as="script"><link rel="prefetch" href="/assets/并发.html--APHSJAh.js" as="script"><link rel="prefetch" href="/assets/线程池.html-fDYQ5nfu.js" as="script"><link rel="prefetch" href="/assets/JVM.html-k6d3mI2I.js" as="script"><link rel="prefetch" href="/assets/JVM上.html-vC8XNKwb.js" as="script"><link rel="prefetch" href="/assets/JVM下.html-8nXGOdoh.js" as="script"><link rel="prefetch" href="/assets/JVM中.html-1Dz_z616.js" as="script"><link rel="prefetch" href="/assets/JVM面试 (copy).html-hwvTdnp4.js" as="script"><link rel="prefetch" href="/assets/JVM面试.html-yljCdw7h.js" as="script"><link rel="prefetch" href="/assets/404.html-AWy8BI--.js" as="script"><link rel="prefetch" href="/assets/index.html-sashHiHF.js" as="script"><link rel="prefetch" href="/assets/index.html-QSMwz7QO.js" as="script"><link rel="prefetch" href="/assets/index.html-PJL4_tzt.js" as="script"><link rel="prefetch" href="/assets/index.html-Gkz_JwEw.js" as="script"><link rel="prefetch" href="/assets/index.html-58guhE7J.js" as="script"><link rel="prefetch" href="/assets/index.html-9YbpnVA4.js" as="script"><link rel="prefetch" href="/assets/index.html-czlKj0Zr.js" as="script"><link rel="prefetch" href="/assets/index.html-AJRamph6.js" as="script"><link rel="prefetch" href="/assets/index.html-ywbOm9QI.js" as="script"><link rel="prefetch" href="/assets/index.html-aHNXP55h.js" as="script"><link rel="prefetch" href="/assets/index.html-XcIxMXAs.js" as="script"><link rel="prefetch" href="/assets/index.html-u1cyhmf4.js" as="script"><link rel="prefetch" href="/assets/index.html-7Yj49K-y.js" as="script"><link rel="prefetch" href="/assets/index.html-ZCZ6is2g.js" as="script"><link rel="prefetch" href="/assets/index.html-aFiDvbRU.js" as="script"><link rel="prefetch" href="/assets/index.html-hg7kIuh8.js" as="script"><link rel="prefetch" href="/assets/index.html-4JsrXbri.js" as="script"><link rel="prefetch" href="/assets/index.html-i1utpa4g.js" as="script"><link rel="prefetch" href="/assets/index.html-QRSxa_bE.js" as="script"><link rel="prefetch" href="/assets/index.html-sEEZK4G7.js" as="script"><link rel="prefetch" href="/assets/index.html-YHezO8jk.js" as="script"><link rel="prefetch" href="/assets/index.html-XZ1d1gO1.js" as="script"><link rel="prefetch" href="/assets/index.html-Y5oYPIp5.js" as="script"><link rel="prefetch" href="/assets/index.html-n5JCljK0.js" as="script"><link rel="prefetch" href="/assets/index.html-T44oxkUT.js" as="script"><link rel="prefetch" href="/assets/index.html-8W4hA5UA.js" as="script"><link rel="prefetch" href="/assets/index.html-CjGRrE0u.js" as="script"><link rel="prefetch" href="/assets/index.html-aeG39R_v.js" as="script"><link rel="prefetch" href="/assets/index.html-yTLugmJ4.js" as="script"><link rel="prefetch" href="/assets/index.html-EGovxLnv.js" as="script"><link rel="prefetch" href="/assets/index.html-3opZS5R2.js" as="script"><link rel="prefetch" href="/assets/index.html-M1N4Zhs9.js" as="script"><link rel="prefetch" href="/assets/index.html-BmFevEn9.js" as="script"><link rel="prefetch" href="/assets/index.html-pQnccxTs.js" as="script"><link rel="prefetch" href="/assets/index.html-xB1Vd7E6.js" as="script"><link rel="prefetch" href="/assets/index.html-28LweaLz.js" as="script"><link rel="prefetch" href="/assets/index.html-9Htwab8S.js" as="script"><link rel="prefetch" href="/assets/index.html-dNHDoUmg.js" as="script"><link rel="prefetch" href="/assets/index.html-8NgYR66B.js" as="script"><link rel="prefetch" href="/assets/index.html-ZgQs62Bt.js" as="script"><link rel="prefetch" href="/assets/index.html-AUmcuKO9.js" as="script"><link rel="prefetch" href="/assets/index.html-U71hPNfm.js" as="script"><link rel="prefetch" href="/assets/index.html-Y3NZyEhj.js" as="script"><link rel="prefetch" href="/assets/index.html-QXkbx2AF.js" as="script"><link rel="prefetch" href="/assets/index.html-8Vy6Lpkd.js" as="script"><link rel="prefetch" href="/assets/index.html-bL_1BmA2.js" as="script"><link rel="prefetch" href="/assets/index.html-g3IcpnEM.js" as="script"><link rel="prefetch" href="/assets/index.html-KtKVjpQW.js" as="script"><link rel="prefetch" href="/assets/index.html-51K2xU5B.js" as="script"><link rel="prefetch" href="/assets/index.html-eNP2VUVx.js" as="script"><link rel="prefetch" href="/assets/index.html-dfEi_JeF.js" as="script"><link rel="prefetch" href="/assets/index.html-z1wsx_yT.js" as="script"><link rel="prefetch" href="/assets/index.html-ag4k4aMX.js" as="script"><link rel="prefetch" href="/assets/index.html-39RmMxXb.js" as="script"><link rel="prefetch" href="/assets/index.html-mUdmB4ay.js" as="script"><link rel="prefetch" href="/assets/index.html-BBUHwiSm.js" as="script"><link rel="prefetch" href="/assets/index.html-Jdd3NFuy.js" as="script"><link rel="prefetch" href="/assets/photoswipe.esm-i2ohwMnJ.js" as="script"><link rel="prefetch" href="/assets/SearchResult-jRD7-0iK.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container has-toc"><!--[--><header id="navbar" class="vp-navbar"><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><!--[--><a class="vp-link vp-brand vp-brand" href="/"><img class="vp-nav-logo" src="/icon.png" alt="Honyelchak&#39;s Blog"><!----><span class="vp-site-name hide-in-pad">Honyelchak&#39;s Blog</span></a><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-center"><!--[--><!----><!--]--><!--[--><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-end"><!--[--><!----><!--]--><!--[--><!--[--><button type="button" class="search-pro-button" role="search" aria-label="搜索"><svg xmlns="http://www.w3.org/2000/svg" class="icon search-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="search icon"><path d="M192 480a256 256 0 1 1 512 0 256 256 0 0 1-512 0m631.776 362.496-143.2-143.168A318.464 318.464 0 0 0 768 480c0-176.736-143.264-320-320-320S128 303.264 128 480s143.264 320 320 320a318.016 318.016 0 0 0 184.16-58.592l146.336 146.368c12.512 12.48 32.768 12.48 45.28 0 12.48-12.512 12.48-32.768 0-45.28"></path></svg><div class="search-pro-placeholder">搜索</div><div class="search-pro-key-hints"><kbd class="search-pro-key">Ctrl</kbd><kbd class="search-pro-key">K</kbd></div></button><!--]--><!----><div class="nav-item hide-in-mobile"><button type="button" id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><nav class="vp-nav-links"><div class="nav-item hide-in-mobile"><a aria-label="主页" class="vp-link nav-link nav-link" href="/"><span class="font-icon icon fa-fw fa-sm fas fa-home" style=""></span>主页<!----></a></div><div class="nav-item hide-in-mobile"><a aria-label="Java学习" class="vp-link nav-link active nav-link active" href="/interview.html"><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span>Java学习<!----></a></div><div class="nav-item hide-in-mobile"><a aria-label="算法学习" class="vp-link nav-link nav-link" href="/algorithm.html"><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span>算法学习<!----></a></div><div class="nav-item hide-in-mobile"><a aria-label="课程学习" class="vp-link nav-link nav-link" href="/course.html"><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span>课程学习<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button type="button" class="dropdown-title" aria-label="项目"><span class="title"><span class="font-icon icon fa-fw fa-sm fas fa-circle-info" style=""></span>项目</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>教程</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a aria-label="/zh/cookbook/markdown/" class="vp-link nav-link nav-link" href="/zh/cookbook/markdown/"><!---->/zh/cookbook/markdown/<!----></a></li><li class="dropdown-subitem"><a aria-label="/zh/cookbook/vuepress/" class="vp-link nav-link nav-link" href="/zh/cookbook/vuepress/"><!---->/zh/cookbook/vuepress/<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>项目</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a aria-label="/zh/changelog" class="vp-link nav-link nav-link" href="/zh/changelog.html"><!---->/zh/changelog<!----></a></li><li class="dropdown-subitem"><a aria-label="/zh/migration/" class="vp-link nav-link nav-link" href="/zh/migration/"><!---->/zh/migration/<!----></a></li><li class="dropdown-subitem"><a aria-label="/zh/related" class="vp-link nav-link nav-link" href="/zh/related.html"><!---->/zh/related<!----></a></li><li class="dropdown-subitem"><a aria-label="/zh/contribution" class="vp-link nav-link nav-link" href="/zh/contribution.html"><!---->/zh/contribution<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><a aria-label="关于我" class="vp-link nav-link nav-link" href="/project.html"><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span>关于我<!----></a></div></nav><!--]--><!--[--><!----><!--]--><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar"><!--[--><!----><!--]--><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><p class="vp-sidebar-heading clickable active"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span><a aria-label="操作系统" class="vp-link nav-link vp-sidebar-title nav-link vp-sidebar-title" href="/interview/A1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><!---->操作系统<!----></a><!----></p><ul class="vp-sidebar-links"><li><!--[--><a aria-label="/interview/Git" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/Git.html"><!---->/interview/Git<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="/interview/JavaWeb" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/JavaWeb.html"><!---->/interview/JavaWeb<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="/interview/Java复习汇总" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/Java%E5%A4%8D%E4%B9%A0%E6%B1%87%E6%80%BB.html"><!---->/interview/Java复习汇总<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="/interview/Mybatis" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/Mybatis.html"><!---->/interview/Mybatis<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="/interview/Untitled" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/Untitled.html"><!---->/interview/Untitled<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="/interview/个人剖析" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/%E4%B8%AA%E4%BA%BA%E5%89%96%E6%9E%90.html"><!---->/interview/个人剖析<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="/interview/数据结构" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html"><!---->/interview/数据结构<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="/interview/斗智斗勇" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/%E6%96%97%E6%99%BA%E6%96%97%E5%8B%87.html"><!---->/interview/斗智斗勇<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="2 算法" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/LeetCode.html"><!---->2 算法<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">A1 操作系统</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">A2 计算机网络</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">A3 数据库</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable active" type="button"><!----><span class="vp-sidebar-title">A4 Java</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><!--[--><a aria-label="/interview/A4-Java/IO" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/A4-Java/IO.html"><!---->/interview/A4-Java/IO<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="/interview/A4-Java/Java基础" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/A4-Java/Java%E5%9F%BA%E7%A1%80.html"><!---->/interview/A4-Java/Java基础<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="/interview/A4-Java/Java集合" class="vp-link nav-link active vp-sidebar-link vp-sidebar-page active nav-link active vp-sidebar-link vp-sidebar-page active" href="/interview/A4-Java/Java%E9%9B%86%E5%90%88.html"><!---->/interview/A4-Java/Java集合<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="Java容器概述" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A4-Java/Java%E9%9B%86%E5%90%88.html#java容器概述"><!---->Java容器概述<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Collection" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A4-Java/Java%E9%9B%86%E5%90%88.html#collection"><!---->Collection<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="1. Set" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A4-Java/Java%E9%9B%86%E5%90%88.html#_1-set"><!---->1. Set<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="2. List" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A4-Java/Java%E9%9B%86%E5%90%88.html#_2-list"><!---->2. List<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="3. Queue" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A4-Java/Java%E9%9B%86%E5%90%88.html#_3-queue"><!---->3. Queue<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Map" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A4-Java/Java%E9%9B%86%E5%90%88.html#map"><!---->Map<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="1. HashMap" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A4-Java/Java%E9%9B%86%E5%90%88.html#_1-hashmap"><!---->1. HashMap<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="2. ConcurrentHashMap" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A4-Java/Java%E9%9B%86%E5%90%88.html#_2-concurrenthashmap"><!---->2. ConcurrentHashMap<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="3. LinkedHashMap" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A4-Java/Java%E9%9B%86%E5%90%88.html#_3-linkedhashmap"><!---->3. LinkedHashMap<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="4. TreeMap" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A4-Java/Java%E9%9B%86%E5%90%88.html#_4-treemap"><!---->4. TreeMap<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="5. HashTable与HashMap的区别" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A4-Java/Java%E9%9B%86%E5%90%88.html#_5-hashtable与hashmap的区别"><!---->5. HashTable与HashMap的区别<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="6. 解决哈希冲突的方法" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A4-Java/Java%E9%9B%86%E5%90%88.html#_6-解决哈希冲突的方法"><!---->6. 解决哈希冲突的方法<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Vector真的同步吗？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A4-Java/Java%E9%9B%86%E5%90%88.html#vector真的同步吗"><!---->Vector真的同步吗？<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="替代方案" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A4-Java/Java%E9%9B%86%E5%90%88.html#替代方案"><!---->替代方案<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="快速失败(fail-fast)和安全失败(fail-safe)" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A4-Java/Java%E9%9B%86%E5%90%88.html#快速失败-fail-fast-和安全失败-fail-safe"><!---->快速失败(fail-fast)和安全失败(fail-safe)<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="List集合的三种遍历方式、效率如何？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A4-Java/Java%E9%9B%86%E5%90%88.html#list集合的三种遍历方式、效率如何"><!---->List集合的三种遍历方式、效率如何？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Map集合的几种遍历方式" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A4-Java/Java%E9%9B%86%E5%90%88.html#map集合的几种遍历方式"><!---->Map集合的几种遍历方式<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="如何实现数组和List之间的转换" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A4-Java/Java%E9%9B%86%E5%90%88.html#如何实现数组和list之间的转换"><!---->如何实现数组和List之间的转换<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="如何确保一个集合不能被修改" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A4-Java/Java%E9%9B%86%E5%90%88.html#如何确保一个集合不能被修改"><!---->如何确保一个集合不能被修改<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="如何获取线程安全容器" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A4-Java/Java%E9%9B%86%E5%90%88.html#如何获取线程安全容器"><!---->如何获取线程安全容器<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="使用JUC下的集合类" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A4-Java/Java%E9%9B%86%E5%90%88.html#使用juc下的集合类"><!---->使用JUC下的集合类<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="使用Collections工具类" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A4-Java/Java%E9%9B%86%E5%90%88.html#使用collections工具类"><!---->使用Collections工具类<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="常见的几个集合类" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A4-Java/Java%E9%9B%86%E5%90%88.html#常见的几个集合类"><!---->常见的几个集合类<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="迭代器 Itertor 是什么" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A4-Java/Java%E9%9B%86%E5%90%88.html#迭代器-itertor-是什么"><!---->迭代器 Itertor 是什么<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="迭代器模式" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A4-Java/Java%E9%9B%86%E5%90%88.html#迭代器模式"><!---->迭代器模式<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Iterable与Iterator" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A4-Java/Java%E9%9B%86%E5%90%88.html#iterable与iterator"><!---->Iterable与Iterator<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="foreach和Iterator的关系：" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A4-Java/Java%E9%9B%86%E5%90%88.html#foreach和iterator的关系"><!---->foreach和Iterator的关系：<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="使用for循环还是迭代器Iterator？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A4-Java/Java%E9%9B%86%E5%90%88.html#使用for循环还是迭代器iterator"><!---->使用for循环还是迭代器Iterator？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Iterator、ListIterator" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A4-Java/Java%E9%9B%86%E5%90%88.html#iterator、listiterator"><!---->Iterator、ListIterator<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="为什么基本类型不能做为HashMap的键值？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A4-Java/Java%E9%9B%86%E5%90%88.html#为什么基本类型不能做为hashmap的键值"><!---->为什么基本类型不能做为HashMap的键值？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Array 、Arrays的关系" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A4-Java/Java%E9%9B%86%E5%90%88.html#array-、arrays的关系"><!---->Array 、Arrays的关系<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="同步容器 与 并发容器" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A4-Java/Java%E9%9B%86%E5%90%88.html#同步容器-与-并发容器"><!---->同步容器 与 并发容器<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="同步容器" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A4-Java/Java%E9%9B%86%E5%90%88.html#同步容器"><!---->同步容器<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="并发容器" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A4-Java/Java%E9%9B%86%E5%90%88.html#并发容器"><!---->并发容器<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li></ul><!--]--></li><li><!--[--><a aria-label="/interview/A4-Java/Streams" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/A4-Java/Streams.html"><!---->/interview/A4-Java/Streams<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="1. 基础" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/A4-Java/Java%E7%96%91%E9%9A%BE%E7%82%B9.html"><!---->1. 基础<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">J U C</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">J V M</span><span class="vp-arrow end"></span></button><!----></section></li><li><!--[--><a aria-label="基础语法" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/A4-Java/%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA.html"><!---->基础语法<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="面试题" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/A4-Java/Java8%E6%96%B0%E7%89%B9%E6%80%A7.html"><!---->面试题<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li></ul></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">A5 Spring</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">A6 高并发相关</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">A7 分布式</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">A8 中间件</span><span class="vp-arrow end"></span></button><!----></section></li><li><!--[--><a aria-label="JAVA" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E9%97%AE%E9%A2%98.html"><!---->JAVA<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">Java面试题</span><span class="vp-arrow end"></span></button><!----></section></li><li><!--[--><a aria-label="三、总结" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/%E7%AE%80%E5%8E%86%E5%9F%8B%E7%82%B9.html"><!---->三、总结<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">工具</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">测试开发</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">硬件</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">系统设计</span><span class="vp-arrow end"></span></button><!----></section></li><li><!--[--><a aria-label="面试题" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/Netty.html"><!---->面试题<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li></ul></section></li><li><section class="vp-sidebar-group"><p class="vp-sidebar-heading"><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span><span class="vp-sidebar-title">计算机网络</span><!----></p><ul class="vp-sidebar-links"><li><!--[--><a aria-label="/interview/A2-计算机网络/IP冲突" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/A2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E5%86%B2%E7%AA%81.html"><!---->/interview/A2-计算机网络/IP冲突<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="/interview/A2-计算机网络/UDT和QUIC" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/A2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/UDT%E5%92%8CQUIC.html"><!---->/interview/A2-计算机网络/UDT和QUIC<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="/interview/A2-计算机网络/网络问题" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/A2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98.html"><!---->/interview/A2-计算机网络/网络问题<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="IP" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/A2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP.html"><!---->IP<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="一、HTTP" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/A2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.html"><!---->一、HTTP<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="常见问题" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/A2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Netty.html"><!---->常见问题<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">重学计算机网络</span><span class="vp-arrow end"></span></button><!----></section></li></ul></section></li></ul><!--[--><!----><!--]--></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!--[--><!----><!--]--><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><!----></h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://yuejinzhao.cn" target="_blank" rel="noopener noreferrer">Honyelchak</a></span><span property="author" content="Honyelchak"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2023-12-02T06:45:03.000Z"></span><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 32 分钟</span><meta property="timeRequired" content="PT32M"></span><!----><!----></div><hr></div><div class="toc-place-holder"><aside id="toc"><!--[--><!----><!--]--><div class="toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button></div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#java容器概述">Java容器概述</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#collection">Collection</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#_1-set">1. Set</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#_2-list">2. List</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#_3-queue">3. Queue</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#map">Map</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#_1-hashmap">1. HashMap</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#_2-concurrenthashmap">2. ConcurrentHashMap</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#_3-linkedhashmap">3. LinkedHashMap</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#_4-treemap">4. TreeMap</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#_5-hashtable与hashmap的区别">5. HashTable与HashMap的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#_6-解决哈希冲突的方法">6. 解决哈希冲突的方法</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#vector真的同步吗">Vector真的同步吗？</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#替代方案">替代方案</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#快速失败-fail-fast-和安全失败-fail-safe">快速失败(fail-fast)和安全失败(fail-safe)</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#list集合的三种遍历方式、效率如何">List集合的三种遍历方式、效率如何？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#map集合的几种遍历方式">Map集合的几种遍历方式</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#如何实现数组和list之间的转换">如何实现数组和List之间的转换</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#如何确保一个集合不能被修改">如何确保一个集合不能被修改</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#如何获取线程安全容器">如何获取线程安全容器</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#使用juc下的集合类">使用JUC下的集合类</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#使用collections工具类">使用Collections工具类</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#常见的几个集合类">常见的几个集合类</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#迭代器-itertor-是什么">迭代器 Itertor 是什么</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#迭代器模式">迭代器模式</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#iterable与iterator">Iterable与Iterator</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#foreach和iterator的关系">foreach和Iterator的关系：</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#使用for循环还是迭代器iterator">使用for循环还是迭代器Iterator？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#iterator、listiterator">Iterator、ListIterator</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#为什么基本类型不能做为hashmap的键值">为什么基本类型不能做为HashMap的键值？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#array-、arrays的关系">Array 、Arrays的关系</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#同步容器-与-并发容器">同步容器 与 并发容器</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#同步容器">同步容器</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#并发容器">并发容器</a></li><!----><!--]--></ul></li><!--]--></ul><div class="toc-marker" style="top:-1.7rem;"></div></div><!--[--><!----><!--]--></aside></div><!--[--><!----><!--]--><div class="theme-hope-content"><h2 id="java容器概述" tabindex="-1"><a class="header-anchor" href="#java容器概述" aria-hidden="true">#</a> Java容器概述</h2><p>容器主要包括<code>Collection</code>和<code>Map</code>两种，Collection存储着对象的集合，而Map存储着键值对的映射表。</p><h2 id="collection" tabindex="-1"><a class="header-anchor" href="#collection" aria-hidden="true">#</a> Collection</h2><figure><img src="/assets/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383232303934383038342e706e67-QnvgxC4h.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="_1-set" tabindex="-1"><a class="header-anchor" href="#_1-set" aria-hidden="true">#</a> 1. Set</h3><ul><li><p><code>TreeSet</code>：基于<mark>红黑树</mark>实现，支持<strong>有序性</strong>操作，例如根据一个范围查找元素的操作。<strong>但是查找效率不如 HashSet</strong>，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。</p><ul><li><p>注意，她是实现了<code>SortedSet</code>接口，所以有序。</p></li><li><p>**底层实现调用<code>TreeMap</code>的构造方法，**key为set中的值，Value为object对象。</p><ul><li><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// Dummy value to associate with an Object in the backing Map</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> <span class="token constant">PRESENT</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p>添加、删除、包含等操作时间复杂度<code>O(logN)</code></p></li></ul></li><li><p><strong>HashSet</strong>：基于<mark>哈希表</mark>实现，支持快速查找，但不支持有序性操作。<strong>并且失去了元素的插入顺序信息</strong>，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。</p><ul><li><strong>元素都存到HashMap键值对的Key上面，而Value时有一个统一的值<code>private static final Object PRESENT = new Object();</code></strong>，(定义一个虚拟的Object对象作为HashMap的value，将此对象定义为static final。)</li><li>实际底层会初始化一个空的HashMap，并使用默认初始容量为<strong>16</strong>和加载因子<strong>0.75</strong>。<code>max((old*0.75)+1),16)</code></li><li>添加、删除、查找效率都是<code>O（1）</code></li></ul></li><li><p><strong>LinkedHashSet</strong>：具有 HashSet 的查找效率，并且<strong>内部使用双向链表维护元素的插入顺序</strong>。</p><ul><li><p>继承了<code>HashSet</code>的构造方法，该方法是包访问权限，外部不能访问。</p></li><li><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">HashSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">,</span> <span class="token keyword">boolean</span> dummy<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>添加、删除、查找效率都是O（1）</code></p></li></ul></li></ul><h3 id="_2-list" tabindex="-1"><a class="header-anchor" href="#_2-list" aria-hidden="true">#</a> 2. List</h3><ul><li><p><strong>ArrayList</strong>：基于<strong>动态数组</strong>实现，支持随机访问(下标)。</p><ul><li><p>默认容量是10(第一次添加元素的时候)，再次扩容则扩容到当前容量的1.5倍</p><ul><li>扩容操作需要调用 <code>Arrays.copyOf()</code> 把原数组整个复制到新数组中，这个<strong>操作代价很高</strong>，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。</li></ul></li><li><p>继承<code>Abstract类</code>,实现了<code>RandomAccess</code>接口(实现该接口的list支持快速随机访问)</p></li><li><p><code>Collections.synchronizedList()</code>实现线程安全。</p></li><li><p><code>modCount</code> 用来记录 ArrayList 结构发生变化的次数。结构发生变化是<code>指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小</code>，仅仅只是设置元素的值不算结构发生变化。</p><p>在进行<strong>序列化或者迭代</strong>等操作时，<strong>需要比较操作前后 modCount 是否改变</strong>，如果改变了需要抛出 ConcurrentModificationException。代码参考上节序列化中的 writeObject() 方法。</p></li></ul></li><li><p><strong>Vector</strong>：和 ArrayList 类似，但它是线程安全的。</p><ul><li>大多数方法都是用了<code>synchronized</code></li><li>默认初始容量为10, 每次扩容会增加一倍</li><li>Stack继承了Vector</li></ul></li><li><p><strong>LinkedList</strong>：基于<strong>双向链表</strong>实现，<strong>只能顺序访问</strong>，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。</p><ul><li>插入和删除容易，查找和修改难。(ArrayList与其相反)。</li></ul></li></ul><h4 id="arrayslist" tabindex="-1"><a class="header-anchor" href="#arrayslist" aria-hidden="true">#</a> ArraysList</h4><h5 id="自动扩容" tabindex="-1"><a class="header-anchor" href="#自动扩容" aria-hidden="true">#</a> 自动扩容</h5><p>每当向数组中添加元素时，都会去检查添加后元素的个数是否会超出当前数组的长度。如果超出，数组会进行自动扩容，以满足添加数据的需求。</p><p>数组扩容通过<code>ensureCapacity(int minCapacity)</code>方法实现。也可以通过手动增加<code>ArrayList</code>实例的容量，以减少递增式再分配的数量。</p><p>数组进行扩容时，会将老数组中的元素重新拷贝一份到新的数组中，<strong>每次数组容量的增长是其原容量的1.5倍。这种操作的代价是很高的。</strong></p><p>因此在实际使用时，我们应该尽量避免数组容量的扩张。当我们可预知要保存的元素的多少时，要在构造ArrayList实例时，就指定其容量，以避免数组扩容的发生。或者根据实际需求，通过调用ensureCapacity方法来手动增加ArrayList实例的容量。</p><h5 id="arraylist-和-linkedlist-的区别是什么" tabindex="-1"><a class="header-anchor" href="#arraylist-和-linkedlist-的区别是什么" aria-hidden="true">#</a> ArrayList 和 LinkedList 的区别是什么？</h5><ul><li>数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。</li><li>随机访问效率：<code>ArrayList 比 LinkedList 在随机访问的时候效率要高</code>，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</li><li>增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。</li><li>内存空间占用：<code>LinkedList 比 ArrayList 更占内存</code>，因为 LinkedList 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。</li><li>线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</li></ul><p>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</p><h3 id="_3-queue" tabindex="-1"><a class="header-anchor" href="#_3-queue" aria-hidden="true">#</a> 3. Queue</h3><ul><li><strong>PriorityQueue</strong>：基于堆结构实现，可以用它来实现优先队列。</li><li>Deque <ul><li><strong>LinkedList</strong>：<strong>可以用它来实现双向队列</strong>。</li><li><strong>ArrayDeque</strong></li></ul></li></ul><h2 id="map" tabindex="-1"><a class="header-anchor" href="#map" aria-hidden="true">#</a> Map</h2><blockquote><p>常用的哈希表为了解决哈希冲突，实现方式有以下两种：<strong>链表法</strong>和<strong>开放地址法</strong>。</p><p>开放地址法就是遇到冲突时，采用某种探测方法寻找下一个槽位。</p></blockquote><figure><img src="/assets/image-20210407145915992-wxl97pPm.png" alt="image-20210407145915992" tabindex="0" loading="lazy"><figcaption>image-20210407145915992</figcaption></figure><ul><li>TreeMap：基于<strong>红黑树</strong>实现。 <ul><li><code>extends AbstractMap</code></li><li><code>containsKey()、get()、put()、remove()的时间复杂度是log(n)</code></li><li>TreeMap是非同步的</li></ul></li><li>HashMap：基于<strong>哈希表</strong>实现。 <ul><li>源码中有<strong>静态内部类</strong><code>entry</code>。</li><li>初始长度为<strong>16</strong>(需要是2的次幂)，默认负载因子<code>DEFAULT_LOAD_FACTOR</code>是0.75</li><li>懒加载机制，<code>只有在第一次put数据的时候才会创建hash表</code>。</li><li>利用单链表解决哈希冲突问题，容量不足会自动扩容</li></ul></li><li>HashTable：和 HashMap 类似，<strong>但它是线程安全的</strong>，这意味着同一时刻多个线程同时写入 HashTable 不会导致数据不一致。它是遗留类，不应该去使用它，而是使用 ConcurrentHashMap 来支持线程安全，ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。</li><li>LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。</li></ul><h3 id="_1-hashmap" tabindex="-1"><a class="header-anchor" href="#_1-hashmap" aria-hidden="true">#</a> 1. HashMap</h3><p>内部包含了一个 Entry 类型的数组 table。Entry 存储着键值对。它包含了四个字段，从 next 字段我们可以看出 Entry 是一个链表。即数组中的每个位置被当成一个桶，一个桶存放一个链表。HashMap 使用拉链法来解决冲突，同一个链表中存放哈希值和散列桶取模运算结果相同的 Entry。</p><figure><img src="/assets/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383233353235383634332e706e67-FKAA6eek.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h4 id="插入-头插法" tabindex="-1"><a class="header-anchor" href="#插入-头插法" aria-hidden="true">#</a> 插入(头插法)</h4><ul><li>查找时分为两步 <ol><li><p>计算key值的hash值</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> h<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为什么需要<code>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>,<strong>这段代码将高位、低位的信息混合在了一起，打乱 hashCode 真正参与运算的低 16 位</strong></p><p>具体来讲：如果两个不同的对象的哈希码只有高位信息不同，那么它们在HashMap中的位置可能是相邻的，从而导致哈希冲突。通过将高位信息与低位信息混合在一起，可以减少这种情况的发生，从而降低哈希冲突的概率。</p></li><li><p>判断Node数组是否为空，如果为空的话，需要先进行初始化(懒加载)</p></li><li><p>根据<code>(n - 1) &amp; hash</code>计算桶的下标</p><ol><li>它通过h &amp; (table.length -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是<strong>HashMap在速度上的优化</strong>。当length总是2的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。</li></ol></li><li><p>如果该桶为空，那么就创建Node，放入桶里。</p></li><li><p>否则先判断该节点的key是否和桶里的头节点的key相同，相同的话就直接更新value</p></li><li><p>如果上边的都不成立，那么就判断是否为红黑树节点，若是，就调用红黑树的插入方式</p></li><li><p>如果是链表，那就遍历链表，看是否有与该key相同的节点，如果有，直接更新value，如果没有就插入，并判断插入后是否需要转红黑树。</p></li><li><p>最后判断hashmap中的元素数量是否大于threshold阈值，如果大于的话，就需要扩容。</p></li></ol></li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code> <span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span>
                   <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token comment">//1、判断当 table 为 null 或者 tab 的长度为 0 时，即 table 尚未初始化，此时通过 resize() 方法得到初始化的 table</span>
            n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
<span class="token comment">//1.1、此处通过（n - 1） &amp; hash 计算出的值作为 tab 的下标 i，并另 p 表示 tab[i]，也就是该链表第一个节点的位置。并判断 p 是否为 null</span>
            tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//1.1.1、当 p 为 null 时，表明 tab[i] 上没有任何元素，那么接下来就 new 第一个 Node 节点，调用 newNode 方法返回新节点赋值给 tab[i]</span>
        <span class="token keyword">else</span> <span class="token punctuation">{</span>
<span class="token comment">//2.1 下面进入 p 不为 null 的情况，有三种情况：p 为链表节点；p 为红黑树节点；p 是链表节点但长度为临界长度 TREEIFY_THRESHOLD，再插入任何元素就要变成红黑树了。</span>
            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span> <span class="token class-name">K</span> k<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
                <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">//2.1.1HashMap 中判断 key 相同的条件是 key 的 hash 相同，并且符合 equals 方法。这里判断了 p.key 是否和插入的 key 相等，如果相等，则将 p 的引用赋给 e</span>
 
                e <span class="token operator">=</span> p<span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>
<span class="token comment">//2.1.2 现在开始了第一种情况，p 是红黑树节点，那么肯定插入后仍然是红黑树节点，所以我们直接强制转型 p 后调用 TreeNode.putTreeVal 方法，返回的引用赋给 e</span>
                e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token punctuation">{</span>
<span class="token comment">//2.1.3 接下里就是 p 为链表节点的情形，也就是上述说的另外两类情况：插入后还是链表 / 插入后转红黑树。另外，上行转型代码也说明了 TreeNode 是 Node 的一个子类</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token comment">// 我们需要一个计数器来计算当前链表的元素个数，并遍历链表，binCount 就是这个计数器</span>
 
                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">&gt;=</span> <span class="token constant">TREEIFY_THRESHOLD</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> 
<span class="token comment">// 插入成功后，要判断是否需要转换为红黑树，因为插入后链表长度加 1，而 binCount 并不包含新节点，所以判断时要将临界阈值减 1</span>
                            <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 当新长度满足转换条件时，调用 treeifyBin 方法，将该链表转换为红黑树</span>
                        <span class="token keyword">break</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
                        <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                        <span class="token keyword">break</span><span class="token punctuation">;</span>
                    p <span class="token operator">=</span> e<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// existing mapping for key</span>
                <span class="token class-name">V</span> oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                    e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
                <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token operator">++</span>modCount<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">&gt;</span> threshold<span class="token punctuation">)</span>
            <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="扩容-基本原理" tabindex="-1"><a class="header-anchor" href="#扩容-基本原理" aria-hidden="true">#</a> 扩容-基本原理</h4><p>设 HashMap 的 table 长度为 M，需要存储的键值对数量为 N，如果哈希函数满足均匀性的要求，那么每条链表的长度大约为 N/M，因此查找的复杂度为 O(N/M)。</p><p>为了让查找的成本降低，<strong>应该使 N/M 尽可能小</strong>，因此需要保证 M 尽可能大，也就是说 table 要尽可能大。HashMap <strong>采用动态扩容来根据当前的 N 值来调整 M 值</strong>，使得空间效率和时间效率都能得到保证。</p><p>扩容使用<code>resize()</code> 实现，需要注意的是，扩容操作同样需要把 <code>oldTable</code> 的所有键值对重新插入 newTable 中，因此这一步是很费时的。</p><p>JDK8中HashMap的扩容相比JDK7时多了两个优化：</p><ol><li><p><strong>优化一：不需要重新计算hash</strong></p><ul><li><p>在JDK7时，数组扩容之后，需要对所有的键值重新计算hash，并插入到newTable中。但是通过分析，可以得出一个阶段，我们使用2次幂进行扩容，<code>元素的位置要么不变，要么就是原位置再次移动2次幂的位置(new = old &lt;&lt; 1)</code>。</p></li><li><p>所以在JDK8中，我们不用像之前那样重新计算hash，只需要看看原来的hash对应的那个bit(新增的那个)是1还是0，如果是0的话索引就不变，否则就变成<code>原索引 + oldCap</code></p><figure><img src="/assets/4d8022db-Vsja2ljJ.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><figure><img src="/assets/d773f86e-16A_Brt9.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure></li></ul></li><li><p><strong>优化二：扩容之后，链表中的元素不会倒置。</strong></p></li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTab <span class="token operator">=</span> table<span class="token punctuation">;</span>
        <span class="token keyword">int</span> oldCap <span class="token operator">=</span> <span class="token punctuation">(</span>oldTab <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> oldTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token keyword">int</span> oldThr <span class="token operator">=</span> threshold<span class="token punctuation">;</span>
        <span class="token keyword">int</span> newCap<span class="token punctuation">,</span> newThr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 超过最大值就不再扩充了，随便你碰撞吧 2^30</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">&gt;=</span> <span class="token constant">MAXIMUM_CAPACITY</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                threshold <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> oldTab<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 没超过最大值，就扩充为原来的两倍</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newCap <span class="token operator">=</span> oldCap <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token constant">MAXIMUM_CAPACITY</span> <span class="token operator">&amp;&amp;</span>
                     oldCap <span class="token operator">&gt;=</span> <span class="token constant">DEFAULT_INITIAL_CAPACITY</span><span class="token punctuation">)</span>
                newThr <span class="token operator">=</span> oldThr <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// double threshold</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldThr <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// initial capacity was placed in threshold</span>
            newCap <span class="token operator">=</span> oldThr<span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token punctuation">{</span>               <span class="token comment">// zero initial threshold signifies using defaults</span>
            newCap <span class="token operator">=</span> <span class="token constant">DEFAULT_INITIAL_CAPACITY</span><span class="token punctuation">;</span>
            newThr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token constant">DEFAULT_LOAD_FACTOR</span> <span class="token operator">*</span> <span class="token constant">DEFAULT_INITIAL_CAPACITY</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    	<span class="token comment">// 计算新的threshold</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>newThr <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">float</span> ft <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>newCap <span class="token operator">*</span> loadFactor<span class="token punctuation">;</span>
            newThr <span class="token operator">=</span> <span class="token punctuation">(</span>newCap <span class="token operator">&lt;</span> <span class="token constant">MAXIMUM_CAPACITY</span> <span class="token operator">&amp;&amp;</span> ft <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token constant">MAXIMUM_CAPACITY</span> <span class="token operator">?</span>
                      <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ft <span class="token operator">:</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        threshold <span class="token operator">=</span> newThr<span class="token punctuation">;</span>
        <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">&quot;rawtypes&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;unchecked&quot;</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTab <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>newCap<span class="token punctuation">]</span><span class="token punctuation">;</span>
        table <span class="token operator">=</span> newTab<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldTab <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 把每个bucket都移动到新的buckets中</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> oldCap<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span>
                <span class="token comment">// 桶不为空</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 避免内存泄漏</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// 链表上只有一个元素</span>
                        newTab<span class="token punctuation">[</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newCap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>
                        <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> newTab<span class="token punctuation">,</span> j<span class="token punctuation">,</span> oldCap<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// preserve order</span>
                        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> loHead <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> loTail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> hiHead <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> hiTail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">;</span>
                        <span class="token keyword">do</span> <span class="token punctuation">{</span>
                            next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment">// 获取到下一个元素</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> oldCap<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果新增的那一位为0，那么位置不变</span>
                                <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// 尾插法</span>
                                    loHead <span class="token operator">=</span> e<span class="token punctuation">;</span>
                                <span class="token keyword">else</span>
                                    loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>
                                loTail <span class="token operator">=</span> e<span class="token punctuation">;</span>
                            <span class="token punctuation">}</span>
                            <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 如果新增的那一位为1，那么位置变为(原位置 + oldCap)</span>
                                <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// 尾插法</span>
                                    hiHead <span class="token operator">=</span> e<span class="token punctuation">;</span>
                                <span class="token keyword">else</span>
                                    hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>
                                hiTail <span class="token operator">=</span> e<span class="token punctuation">;</span>
                            <span class="token punctuation">}</span>
                        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                            loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                            newTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                            hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                            newTab<span class="token punctuation">[</span>j <span class="token operator">+</span> oldCap<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> newTab<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="扩容-重新计算下标" tabindex="-1"><a class="header-anchor" href="#扩容-重新计算下标" aria-hidden="true">#</a> 扩容--重新计算下标</h4><blockquote><p>取余运算符为“%”。但在以前，CPU采用如下方法计算余数（注意，该方法<strong>只对2的N次方数</strong>系有效）： X &amp; (2^N - 1)</p></blockquote><p>因为上边所说的对2的N次方数可以采用位运算进行取余，所以capacity需要满足是2的n次方。</p><p>假设原数组长度 capacity 为 16，扩容之后 new capacity 为 32：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>capacity     : 00010000
new capacity : 00100000
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>对于一个 Key，它的哈希值 hash 在第 5 位：</p><ul><li>为 0，那么 hash%00010000 = hash%00100000，桶位置和原来一致；</li><li>为 1，hash%00010000 = hash%00100000 + 16，桶位置是原位置 + 16。</li></ul><p>**PS：**如果在初始化时，传入的容量值不是2的n次方，它可以自动的将传入的容量转为2的n次方</p><h4 id="桶下标如何计算" tabindex="-1"><a class="header-anchor" href="#桶下标如何计算" aria-hidden="true">#</a> 桶下标如何计算</h4><p>先算出hash，然后(n - 1) &amp; hash</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> h<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>计算key的hashCode()并将散列的高位（异或）散列的低位。由于该表使用两个掩码的幂，因此仅在当前掩码上方的位上变化的哈希集将始终发生冲突。（在已知的例子中有一组在小表格中保持连续整数的浮点键。）</p><p>因此我们应用了一种向下扩展高位影响的变换。在速度、实用性和位扩展质量之间存在一种折衷。因为许多常见的散列集已经被合理地分布（因此不能从散播中受益），而且因为我们使用树来处理容器中的大量冲突，所以我们只是以最便宜的方式对一些移位的位进行异或，以减少系统损失，以及合并最高位的影响，否则由于表边界，这些最高位将永远不会用于索引计算。</p></blockquote><h4 id="链表转红黑树" tabindex="-1"><a class="header-anchor" href="#链表转红黑树" aria-hidden="true">#</a> 链表转红黑树</h4><p>从 JDK 1.8 开始，一个桶存储的链表长度<strong>大于等于 8</strong> , 并且数组长度大于64 时会将链表转换为红黑树。</p><p>1、hashMap并不是在链表元素个数大于8就一定会转换为红黑树，而是先考虑扩容，扩容达到默认限制后才转换。 2、hashMap的红黑树不一定小于6的时候才会转换为链表，而是只有在resize的时候才会根据 UNTREEIFY_THRESHOLD 进行转换。</p><h4 id="与-hashtable-的比较" tabindex="-1"><a class="header-anchor" href="#与-hashtable-的比较" aria-hidden="true">#</a> 与 Hashtable 的比较</h4><ul><li><p>HashMap是HashTable的轻量级实现(非线程安全的实现)</p></li><li><p>HashMap继承AbstractMap，HashTable继承Dictionary(现已荒废)</p></li><li><p>Hashtable 使用 <strong>synchronized</strong> 来进行同步。</p></li><li><p>HashMap 可以插入键为 null 的 Entry(<strong>HashTable不可以</strong>)。</p><ul><li>null放到0号位置。</li></ul></li><li><p>HashMap 的迭代器是 <code>fail-fast</code> 迭代器。</p></li><li><p>HashMap <code>不能保证随着时间的推移 Map 中的元素次序是不变的</code>。</p></li></ul><h4 id="与threadlocalmap比较" tabindex="-1"><a class="header-anchor" href="#与threadlocalmap比较" aria-hidden="true">#</a> 与ThreadLocalMap比较</h4><ul><li><p>HashMap 的数据结构是<code>数组+链表</code>, ThreadLocalMap的数据结构仅仅是<code>数组</code></p></li><li><p>HashMap 是通过<code>链地址法</code>解决hash冲突的问题,ThreadLocalMap 是通过<code>开放地址法</code>来解决hash 冲突的问题</p></li><li><p>HashMap 里面的<code>Entry内部类</code>的引用都是强引用, ThreadLocalMap里面的Entry 内部类中的key 是弱引用，value 是强引用</p></li></ul><p>Ps：Thread中有一个ThreadLocalMap，ThreadLocalMap中存放的是Entry数组，Entry是键值对<code>&lt;ThreadLocal, Object&gt;</code></p><h4 id="链地址法和开放地址法的优缺点" tabindex="-1"><a class="header-anchor" href="#链地址法和开放地址法的优缺点" aria-hidden="true">#</a> 链地址法和开放地址法的优缺点</h4><p>开放地址法：</p><ol><li>容易产生堆积问题，不适于大规模的数据存储。</li><li>散列函数的设计对冲突会有很大的影响，插入时可能会出现多次冲突的现象。</li><li>删除的元素是多个冲突元素中的一个，需要对后面的元素作处理，实现较复杂。</li></ol><p>链地址法：</p><ol><li>处理冲突简单，且无堆积现象，平均查找长度短。</li><li>链表中的结点是动态申请的，适合构造表不能确定长度的情况。</li><li>删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。</li><li>指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间。</li></ol><blockquote><p><strong>为什么ThreadLocalMap 采用开放地址法来解决哈希冲突?</strong></p><ul><li><p>ThreadLocal 中看到一个属性 HASH_INCREMENT = <code>0x61c88647</code> ，0x61c88647 是一个神奇的数字，让哈希码能均匀的分布在2的N次方的数组里, 即 Entry[] table，关于这个神奇的数字google 有很多解析，这里就不重复说了</p><ul><li>每次实例化ThreadLocal，那么就会生成不同的<code>threadLocalHashCode</code>,从而将Entry均匀的分布到数组table中。</li><li>生成hashcode的方法：<code>nextHashCode.getAndAdd(HASH_INCREMENT)</code>，nextHashCode是静态原子类，从0开始的。</li></ul></li><li><p>ThreadLocal 往往存放的数据量不会特别大（而且key 是弱引用又会被垃圾回收，及时让数据量更小），这个时候开放地址法简单的结构会显得更省空间，同时数组的查询效率也是非常高，加上第一点的保障，冲突概率也低。</p></li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>expungeStaleEntry方法是用来清楚无用的entry的
1. 从指定位置往下扫描entry数组，知道entry为null
1.1 如果遇到当前key被回收的entry，就执行删除，
1.2 否则重新计算hash，将其放在正确的位置上。

set方法：
1. 首先计算在entry数组中对应的位置，如果当前entry不为空，那就往下扫描：
2. 若找到相同的key，更新值并返回
3. 否则找到第一个过期的enty，执行替换操作。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><h4 id="两个线程并发的put元素-且这两个元素存在hash冲突-会造成问题吗" tabindex="-1"><a class="header-anchor" href="#两个线程并发的put元素-且这两个元素存在hash冲突-会造成问题吗" aria-hidden="true">#</a> 两个线程并发的put元素，且这两个元素存在hash冲突，会造成问题吗？</h4><p>主要原因在于并发下的 Rehash <code>会造成元素之间会形成一个循环链表</code>。不过，jdk 1.8 后解决了这个问题，但是还是不建议在多线程下使用 HashMap,因为多线程下使用 HashMap 还是会存在其他问题比如数据丢失。并发环境下推荐使用 ConcurrentHashMap 。</p><ol><li>HashMap在并发情况下的put操作会造成死循环。</li></ol><hr><h3 id="_2-concurrenthashmap" tabindex="-1"><a class="header-anchor" href="#_2-concurrenthashmap" aria-hidden="true">#</a> 2. ConcurrentHashMap</h3><h4 id="_1-7之前" tabindex="-1"><a class="header-anchor" href="#_1-7之前" aria-hidden="true">#</a> 1.7之前</h4><figure><img src="/assets/640-O-8bT7LT.jpeg" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h4 id="是否允许为null" tabindex="-1"><a class="header-anchor" href="#是否允许为null" aria-hidden="true">#</a> 是否允许为null</h4><p>key和value不可以为Null。</p><h4 id="线程安全" tabindex="-1"><a class="header-anchor" href="#线程安全" aria-hidden="true">#</a> 线程安全</h4><p>JDK1.8之前：数组+链表，采用<code>分段锁</code> Segment(继承 ReentrantLock)。</p><p>JDK1.8以后：数组+链表+红黑树，采用<code>CAS+synchronized</code></p><p><strong>锁分段技术</strong></p><p>HashTable容器在竞争激烈的并发环境下表现出效率低下的原因是所有访问HashTable的线程都必须竞争同一把锁，那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p><h4 id="concurrenthashmap-和-hashtable-的区别" tabindex="-1"><a class="header-anchor" href="#concurrenthashmap-和-hashtable-的区别" aria-hidden="true">#</a> ConcurrentHashMap 和 Hashtable 的区别？</h4><p>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现<code>线程安全的方式上</code>不同。</p><p>底层数据结构：</p><ul><li>JDK1.7的 ConcurrentHashMap 底层采用 <code>分段的数组+链表</code> 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。</li><li>Hashtable 和 JDK1.7 的 HashMap 的底层数据结构类似都是采用 数组+链表 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li></ul><p>实现线程安全的方式（重要）：</p><ul><li>在JDK1.7的时候，ConcurrentHashMap（分段锁） <code>对整个桶数组进行了分割分段(Segment)</code>，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。（<code>默认分配16个Segment</code>，比Hashtable效率提高16倍。）</li><li>JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 <code>Node数组+链表+红黑树的数据结构来实现</code>，并发控制使用 <code>synchronized </code>和<code>CAS</code>来操作。（JDK1.6以后对 synchronized锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；②</li><li>Hashtable(同一把锁) :使用 <code>synchronized</code> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li></ul><p>两者的对比图：</p><p>HashTable:</p><figure><img src="/assets/image-20201109165808848-SKo4vltz.png" alt="image-20201109165808848" tabindex="0" loading="lazy"><figcaption>image-20201109165808848</figcaption></figure><p>JDK1.7的ConcurrentHashMap：</p><figure><img src="/assets/image-20201109165820466-pAEnad1X.png" alt="image-20201109165820466" tabindex="0" loading="lazy"><figcaption>image-20201109165820466</figcaption></figure><p>JDK1.8的ConcurrentHashMap（TreeBin: 红黑二叉树节点 Node: 链表节点）：</p><figure><img src="/assets/image-20201109165840129-8jCQkKsR.png" alt="image-20201109165840129" tabindex="0" loading="lazy"><figcaption>image-20201109165840129</figcaption></figure><p>答：ConcurrentHashMap 结合了 <code>HashMap 和 HashTable </code>二者的优势。</p><p>HashMap 没有考虑同步，HashTable 考虑了同步的问题。但是 HashTable 在每次同步执行时都要锁住整个结构。 ConcurrentHashMap 锁的方式是稍微细粒度的。</p><h3 id="_3-linkedhashmap" tabindex="-1"><a class="header-anchor" href="#_3-linkedhashmap" aria-hidden="true">#</a> 3. LinkedHashMap</h3><h4 id="_1-存储结构" tabindex="-1"><a class="header-anchor" href="#_1-存储结构" aria-hidden="true">#</a> 1. 存储结构</h4><p>继承自 HashMap，因此具有和 HashMap 一样的快速查找特性。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>内部维护了一个双向链表，用来维护<strong>插入顺序</strong>或者 <strong>LRU</strong> 顺序。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * The head (eldest) of the doubly linked list.
 */</span>
<span class="token keyword">transient</span> <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> head<span class="token punctuation">;</span>

<span class="token doc-comment comment">/**
 * The tail (youngest) of the doubly linked list.
 */</span>
<span class="token keyword">transient</span> <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> tail<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但由于它又额外定义了一个以head为头结点的双向链表(如下面第二个图所示)，因此对于每次put进来Entry，除了将其保存到哈希表中对应的位置上之外，还会将其插入到双向链表的尾部。</p><figure><img src="/assets/SouthEast-1678611259449-7-K4s0CpgH.png" alt="这里写图片描述" tabindex="0" loading="lazy"><figcaption>这里写图片描述</figcaption></figure><p>其中，HashMap与LinkedHashMap的Entry结构示意图如下图所示：</p><figure><img src="/assets/SouthEast-e4Ww8HsX.png" alt="这里写图片描述" tabindex="0" loading="lazy"><figcaption>这里写图片描述</figcaption></figure><h4 id="_2-成员变量定义" tabindex="-1"><a class="header-anchor" href="#_2-成员变量定义" aria-hidden="true">#</a> 2. 成员变量定义</h4><p>与HashMap相比，LinkedHashMap增加了两个属性用于保证迭代顺序，分别是 <strong>双向链表头结点header</strong> 和 <strong>标志位accessOrder</strong> (值为true时，表示按照访问顺序迭代；值为false时，表示按照插入顺序迭代)。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * The head of the doubly linked list.
 */</span>
<span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> header<span class="token punctuation">;</span>  <span class="token comment">// 双向链表的表头元素</span>

<span class="token doc-comment comment">/**
 * The iteration ordering method for this linked hash map: <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tt</span><span class="token punctuation">&gt;</span></span><span class="token code-section"><span class="token line"><span class="token code language-java"><span class="token boolean">true</span></span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tt</span><span class="token punctuation">&gt;</span></span>
 * for access-order, <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tt</span><span class="token punctuation">&gt;</span></span><span class="token code-section"><span class="token line"><span class="token code language-java"><span class="token boolean">false</span></span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tt</span><span class="token punctuation">&gt;</span></span> for insertion-order.
 *
 * <span class="token keyword">@serial</span>
 */</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> accessOrder<span class="token punctuation">;</span>  <span class="token comment">//true表示按照访问顺序迭代，false时表示按照插入顺序 </span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_3-数据结构" tabindex="-1"><a class="header-anchor" href="#_3-数据结构" aria-hidden="true">#</a> 3. 数据结构</h4><p>本质上，LinkedHashMap = HashMap + <strong>双向链表</strong>，也就是说，HashMap和双向链表合二为一即是LinkedHashMap。也可以这样理解，LinkedHashMap 在不对HashMap做任何改变的基础上，给HashMap的任意两个节点间加了两条连线(before指针和after指针)，使这些节点形成一个双向链表。在LinkedHashMapMap中，所有put进来的Entry都保存在HashMap中，但由于它又额外定义了一个以head为头结点的空的双向链表，因此对于每次put进来Entry还会将其插入到双向链表的尾部。</p><p>他重写了HashMap的createREntry方法</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>    <span class="token keyword">void</span> <span class="token function">createEntry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token keyword">int</span> bucketIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        <span class="token comment">// 向哈希表中插入Entry，这点与HashMap中相同 </span>
        <span class="token comment">//创建新的Entry并将其链入到数组对应桶的链表的头结点处， </span>
        <span class="token class-name">HashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> old <span class="token operator">=</span> table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>  
        <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> old<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>     

        <span class="token comment">//在每次向哈希表插入Entry的同时，都会将其插入到双向链表的尾部，  </span>
        <span class="token comment">//这样就按照Entry插入LinkedHashMap的先后顺序来迭代元素(LinkedHashMap根据双向链表重写了迭代器)</span>
        <span class="token comment">//同时，新put进来的Entry是最近访问的Entry，把其放在链表末尾 ，也符合LRU算法的实现  </span>
        e<span class="token punctuation">.</span><span class="token function">addBefore</span><span class="token punctuation">(</span>header<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        size<span class="token operator">++</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由以上源码我们可以知道，在LinkedHashMap中向哈希表中插入新Entry的同时，还会通过Entry的addBefore方法将其链入到双向链表中。其中，addBefore方法本质上是一个双向链表的插入操作，其源码如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>    <span class="token comment">//在双向链表中，将当前的Entry插入到existingEntry(header)的前面  </span>
    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">addBefore</span><span class="token punctuation">(</span><span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> existingEntry<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        after  <span class="token operator">=</span> existingEntry<span class="token punctuation">;</span>
        before <span class="token operator">=</span> existingEntry<span class="token punctuation">.</span>before<span class="token punctuation">;</span>
        before<span class="token punctuation">.</span>after <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
        after<span class="token punctuation">.</span>before <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>  
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_4-扩容" tabindex="-1"><a class="header-anchor" href="#_4-扩容" aria-hidden="true">#</a> 4. 扩容</h4><p>桶HashMap扩容相似，只是简单的修改了复制数组的方法<code>transfer()</code></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>    <span class="token doc-comment comment">/**
     * Transfers all entries to new table array.  This method is called
     * by superclass resize.  It is overridden for performance, as it is
     * faster to iterate using our linked list.
     */</span>
    <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token class-name">HashMap<span class="token punctuation">.</span>Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTable<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> newTable<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token comment">// 与HashMap相比，借助于双向链表的特点进行重哈希使得代码更加简洁</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e <span class="token operator">=</span> header<span class="token punctuation">.</span>after<span class="token punctuation">;</span> e <span class="token operator">!=</span> header<span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>after<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 计算每个Entry所在的桶</span>
            <span class="token comment">// 将其链入桶中的链表</span>
            e<span class="token punctuation">.</span>next <span class="token operator">=</span> newTable<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
            newTable<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-treemap" tabindex="-1"><a class="header-anchor" href="#_4-treemap" aria-hidden="true">#</a> 4. TreeMap</h3><ul><li>按照key的自然排序排列</li></ul><h3 id="_5-hashtable与hashmap的区别" tabindex="-1"><a class="header-anchor" href="#_5-hashtable与hashmap的区别" aria-hidden="true">#</a> 5. HashTable与HashMap的区别</h3><h4 id="计算索引位置方法不同" tabindex="-1"><a class="header-anchor" href="#计算索引位置方法不同" aria-hidden="true">#</a> 计算索引位置方法不同</h4><ul><li>HashMap <ul><li><code>index = (n - 1) &amp; hash</code></li><li>因<code>n-1</code>为2的幂次，所以利用位运算高效算出索引</li></ul></li><li>HashTable <ul><li><code>int index = (hash &amp; 0x7FFFFFFF) % tab.length; </code></li><li>&amp;0x7FFFFFFF的目的是为了将负的hash值转化为正值(只有符号位改变)</li></ul></li></ul><h4 id="扩容方式不一样" tabindex="-1"><a class="header-anchor" href="#扩容方式不一样" aria-hidden="true">#</a> 扩容方式不一样</h4><ul><li>HashMap容量不足resize时，扩容必须要求原容量的2倍，且扩容结果一定是2的n次幂。</li><li>HashTable则扩到原容量的2倍+1。</li></ul><h4 id="解决hash冲突方式不容" tabindex="-1"><a class="header-anchor" href="#解决hash冲突方式不容" aria-hidden="true">#</a> 解决hash冲突方式不容</h4><ul><li>HashMap在Java8中，当出现冲突时，一个桶存储的链表长度大于等于 8 时会将链表转换为红黑树。</li><li>而在HashTable中， <strong>都是以链表方式存储。</strong></li></ul><h4 id="是否允许null值" tabindex="-1"><a class="header-anchor" href="#是否允许null值" aria-hidden="true">#</a> 是否允许null值</h4><ul><li>HashMap允许key、value为null值</li><li>HashTable不允许，会报空指针异常</li></ul><h4 id="线程安全-1" tabindex="-1"><a class="header-anchor" href="#线程安全-1" aria-hidden="true">#</a> 线程安全</h4><ul><li>HashMap不安全</li><li>HashTable安全，HashTable实现线程安全的代价就是<strong>效率变低</strong>，因为会<strong>锁住整个HashTable</strong>,而ConcurrentHashMap做了相关优化,因为ConcurrentHashMap使用了<strong>分段锁</strong>，并不对整个数据进行锁定,效率比HashTable高很多。</li></ul><h3 id="_6-解决哈希冲突的方法" tabindex="-1"><a class="header-anchor" href="#_6-解决哈希冲突的方法" aria-hidden="true">#</a> 6. 解决哈希冲突的方法</h3><ul><li>**拉链法(链地址法)：**采用数组+链表，数组的每一格就是一个链表，如果发生了哈希冲突就加在链表上。</li><li>**线性探测法：**如果发生了哈希冲突，就向后查找，直至找到一个空位置插入。</li></ul><h2 id="vector真的同步吗" tabindex="-1"><a class="header-anchor" href="#vector真的同步吗" aria-hidden="true">#</a> Vector真的同步吗？</h2><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>vector<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">)</span> 
vector<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
<span class="token comment">//这是经典的 put-if-absent 情况，尽管 contains, add 方法都正确地同步了，但作为 vector 之外的使用环境，仍然存在 race condition（锁竞争）: 因为虽然条件判断contains与add都是原子性的操作 (atomic)，但在 if 条件判断为真后，那个用来访问vector.contains 方法的锁已经释放，在即将的 vector.add 方法调用 之间有间隙，在多线程环境中，完全有可能被其他线程获得 vector的 lock 并改变其状态, 此时当前线程的vector.add(element); 正在等待（只不过我们不知道而已）。只有当其他线程释放了 vector 的 lock 后，vector.add(element); 继续，但此时它已经基于一个错误的假设了。</span>
<span class="token comment">//单个的方法 synchronized 了并不代表组合（compound）的方法调用具有原子性，使 compound actions 成为线程安全的可能解决办法之一还是离不开intrinsic lock (这个锁应该是 vector 的，但由 client 维护)：</span>
<span class="token comment">// 所有的 Vector 的方法都具有 synchronized 关键修饰。但对于复合操作，Vector 仍然需要进行同步处理。</span>
<span class="token comment">// 参考链接：https://yuanfentiank789.github.io/2016/11/25/vectorsafe/</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="替代方案" tabindex="-1"><a class="header-anchor" href="#替代方案" aria-hidden="true">#</a> 替代方案</h3><p>尽量使用ArrayList，少用Vector。</p><p>可以使用 <code>Collections.synchronizedList();</code> 得到一个线程安全的 ArrayList。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> synList <span class="token operator">=</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">synchronizedList</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>也可以使用 concurrent 并发包下的 CopyOnWriteArrayList 类。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CopyOnWriteArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="copyonwritearraylist" tabindex="-1"><a class="header-anchor" href="#copyonwritearraylist" aria-hidden="true">#</a> CopyOnWriteArrayList</h4><h5 id="_1-读写分离" tabindex="-1"><a class="header-anchor" href="#_1-读写分离" aria-hidden="true">#</a> 1. 读写分离</h5><p>写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。</p><p>写操作需要加锁，防止并发写入时导致写入数据丢失。</p><p>写操作结束之后需要把原始数组指向新的复制数组。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>
    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elements <span class="token operator">=</span> <span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> len <span class="token operator">=</span> elements<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newElements <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        newElements<span class="token punctuation">[</span>len<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
        <span class="token function">setArray</span><span class="token punctuation">(</span>newElements<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">setArray</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    array <span class="token operator">=</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">&quot;unchecked&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">private</span> <span class="token class-name">E</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> a<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="_2-使用场景" tabindex="-1"><a class="header-anchor" href="#_2-使用场景" aria-hidden="true">#</a> 2. 使用场景</h5><p><code>白名单，黑名单，商品类目的访问和更新场景</code></p><p>CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。</p><p>但是 CopyOnWriteArrayList 有其缺陷：</p><ul><li>内存占用：在写操作时需要复制一个新的数组，<strong>使得内存占用为原来的两倍左右；</strong></li><li>数据不一致：<strong>读操作不能读取实时性的数据</strong>，因为部分写操作的数据还未同步到读数组中。</li></ul><p>所以 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景。</p><h2 id="快速失败-fail-fast-和安全失败-fail-safe" tabindex="-1"><a class="header-anchor" href="#快速失败-fail-fast-和安全失败-fail-safe" aria-hidden="true">#</a> 快速失败(fail-fast)和安全失败(fail-safe)</h2><ul><li><ul><li><p>快速失败： 在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出Concurrent Modification Exception。java.util中的集合类都是快速失败的。</p></li><li><ul><li>在这些集合类中都有一个modCount变量，用来记录集合修改的次数，如果在迭代过程中modCount发生了变化，就会抛出异常。</li></ul></li><li><p>安全失败： 迭代的时候先复制原有集合内容，在拷贝的集合上进行遍历，所以即使原来的集合被修改了，迭代器也不知道。java.util.concurrent包内的容器都是安全失败的，可以在多线程下使用。</p></li></ul></li></ul><h2 id="list集合的三种遍历方式、效率如何" tabindex="-1"><a class="header-anchor" href="#list集合的三种遍历方式、效率如何" aria-hidden="true">#</a> List集合的三种遍历方式、效率如何？</h2><ul><li>迭代器遍历</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span>  it  <span class="token operator">=</span>  list<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  it<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">)</span>  <span class="token punctuation">{</span>  
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  
  <span class="token punctuation">}</span>  
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>这种方式在循环执行过程中会进行数据锁定，性能稍差</strong>，同时如果你想在循环过程中去掉某个元素，<code>只能调用it.remove方法</code>，不能使用list.remove方法，否则一定出现并发访问的错误。</p><ul><li>增强for循环</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code> <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">String</span>  data   <span class="token operator">:</span>  list<span class="token punctuation">)</span>  <span class="token punctuation">{</span>  
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  
  <span class="token punctuation">}</span>  
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>内部调用第一种</strong>，换汤不换药，因此比Iterator慢，这种循环方式还有其他限制，不建议使用它</p><p>第三种：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code> <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span>  i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>  i<span class="token operator">&lt;</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>  
    <span class="token class-name">A</span>  a  <span class="token operator">=</span>  list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  
  <span class="token punctuation">}</span>  
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>内部不锁定, 效率最高, 但是当写多线程时要考虑并发操作的问题</p><h2 id="map集合的几种遍历方式" tabindex="-1"><a class="header-anchor" href="#map集合的几种遍历方式" aria-hidden="true">#</a> Map集合的几种遍历方式</h2><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;1&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;nice&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;2&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;3&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;bucuo&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>**推荐第一种：**第二种还需要用get方法获取，效率低。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 第一种：获取map的entrySet</span>
<span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> it <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> entry <span class="token operator">=</span> it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;key = &quot;</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot; value = &quot;</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 第二种：获取map的keySet，然后再用get方法获取</span>
<span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> it1 <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>it1<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">String</span> key <span class="token operator">=</span> it1<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;key = &quot;</span> <span class="token operator">+</span> key <span class="token operator">+</span> <span class="token string">&quot; value = &quot;</span> <span class="token operator">+</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="如何实现数组和list之间的转换" tabindex="-1"><a class="header-anchor" href="#如何实现数组和list之间的转换" aria-hidden="true">#</a> 如何实现数组和List之间的转换</h2><p>详见<a href="Java疑难点.md">Java疑难点.md#2. 集合</a></p><h2 id="如何确保一个集合不能被修改" tabindex="-1"><a class="header-anchor" href="#如何确保一个集合不能被修改" aria-hidden="true">#</a> 如何确保一个集合不能被修改</h2><figure><img src="/assets/image-20200304231000271-_FZ5HmY-.png" alt="image-20200304231000271" tabindex="0" loading="lazy"><figcaption>image-20200304231000271</figcaption></figure><p><code>Collections.xxx</code></p><figure><img src="/assets/image-20200304231156504-gMUZHVEd.png" alt="image-20200304231156504" tabindex="0" loading="lazy"><figcaption>image-20200304231156504</figcaption></figure><p>修改则抛出异常<code>UnsupportOperationException()</code></p><p>**PS：**不能用final，因为集合是引用类型，所以只是让这个引用不能引用其他对象。</p><h2 id="如何获取线程安全容器" tabindex="-1"><a class="header-anchor" href="#如何获取线程安全容器" aria-hidden="true">#</a> 如何获取线程安全容器</h2><h3 id="使用juc下的集合类" tabindex="-1"><a class="header-anchor" href="#使用juc下的集合类" aria-hidden="true">#</a> 使用JUC下的集合类</h3><h4 id="list和set" tabindex="-1"><a class="header-anchor" href="#list和set" aria-hidden="true">#</a> List和Set</h4><ul><li>CopyOnWriteArrayList</li><li>CopyOnWriteArraySet <ul><li>相当于线程安全的HashSet。</li><li>底层通过CopyOnWriteArrayList实现的</li></ul></li><li>ConcurrentSkipListSet</li></ul><p>*第一，在”添加操作“开始前，<strong>获取独占锁(lock)</strong>，若此时有需要线程要获取锁，则必须等待；在操作完毕后，释放独占锁(lock)，此时其它线程才能获取锁。通过独占锁，来防止多线程同时修改数据！lock的定义如下： <code>transient final ReentrantLock lock = new ReentrantLock();</code></p><pre><code>第二，操作完毕时，会通过setArray()来更新”volatile数组“。而且，前面我们提过”即对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入“；这样**，每次添加元素之后，其它线程都能看到新添加的元素.**
</code></pre><h4 id="map-1" tabindex="-1"><a class="header-anchor" href="#map-1" aria-hidden="true">#</a> Map</h4><ul><li>ConcurrentHashMap <ul><li>相当于线程安全的HashMap</li><li>通过<strong>锁分段</strong>来实现的。</li></ul></li><li>ConcurrentSkipListMap <ul><li>线程安全的<strong>有序</strong>的哈希表(相当于线程安全的TreeMap);</li><li>它继承于AbstractMap类，并且实现ConcurrentNavigableMap接口。ConcurrentSkipListMap是通过“跳表”来实现的，它支持并发。</li></ul></li><li>ConcurrentSkipListSet <ul><li>线程安全的<strong>有序</strong>的集合(相当于线程安全的TreeSet)；它继承于AbstractSet，并实现了NavigableSet接口。</li><li>ConcurrentSkipListSet是通过ConcurrentSkipListMap实现的，它也支持并发。</li></ul></li></ul><h3 id="使用collections工具类" tabindex="-1"><a class="header-anchor" href="#使用collections工具类" aria-hidden="true">#</a> 使用Collections工具类</h3><figure><img src="/assets/image-20200304231547030-P-QMDAvM.png" alt="image-20200304231547030" tabindex="0" loading="lazy"><figcaption>image-20200304231547030</figcaption></figure><figure><img src="/assets/image-20200304231427865-1eDeWNxo.png" alt="image-20200304231427865" tabindex="0" loading="lazy"><figcaption>image-20200304231427865</figcaption></figure><p>使用synchronized加锁。</p><p>但是这些同步类的并发效率并不是很高。</p><h3 id="常见的几个集合类" tabindex="-1"><a class="header-anchor" href="#常见的几个集合类" aria-hidden="true">#</a> 常见的几个集合类</h3><p><code>Vector</code>，<code>stack</code>,<code>hashtable</code></p><h2 id="迭代器-itertor-是什么" tabindex="-1"><a class="header-anchor" href="#迭代器-itertor-是什么" aria-hidden="true">#</a> 迭代器 Itertor 是什么</h2><h3 id="迭代器模式" tabindex="-1"><a class="header-anchor" href="#迭代器模式" aria-hidden="true">#</a> 迭代器模式</h3><p>它是 Java 中常用的设计模式之一。用于<strong>顺序访问集合对象的元素</strong>，无需知道集合对象的底层实现。</p><h3 id="iterable与iterator" tabindex="-1"><a class="header-anchor" href="#iterable与iterator" aria-hidden="true">#</a> Iterable与Iterator</h3><ul><li><strong>Iterable</strong> 实现这个接口的集合对象支持迭代，是可以迭代的。实现了这个可以配合foreach使用 <ul><li>util.collection继承Iterable</li></ul></li><li><strong>Iterator</strong> 迭代器，提供迭代机制的对象，具体如何迭代是这个Iterator接口规范的。</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">//Iterable JDK源码</span>
<span class="token comment">//可以通过成员内部类，方法内部类，甚至匿名内部类去实现Iterator</span>

<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Iterable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span>
<span class="token punctuation">{</span>

    <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="foreach和iterator的关系" tabindex="-1"><a class="header-anchor" href="#foreach和iterator的关系" aria-hidden="true">#</a> foreach和Iterator的关系：</h3><ul><li><code>for each</code>以用来处理集合中的每个元素而不用考虑集合定下标。就是为了让用Iterator简单。但是删除的时候，区别就是在remove，循环中调用集合remove会导致原集合变化导致错误，而应该用迭代器的remove方法。</li></ul><h3 id="使用for循环还是迭代器iterator" tabindex="-1"><a class="header-anchor" href="#使用for循环还是迭代器iterator" aria-hidden="true">#</a> 使用for循环还是迭代器Iterator？</h3><ul><li><strong>采用ArrayList对随机访问比较快，而for循环中的get()方法，采用的即是随机访问的方法，因此在ArrayList里，for循环较快</strong></li><li><strong>采用LinkedList则是顺序访问比较快，iterator中的next()方法，采用的即是顺序访问的方法，因此在LinkedList里，使用iterator较快</strong></li></ul><p>for循环适合访问顺序结构,可以根据下标快速获取指定元素.而Iterator 适合访问链式结构,因为迭代器是通过next()和Pre()来定位的.可以访问没有顺序的集合.</p><h3 id="iterator、listiterator" tabindex="-1"><a class="header-anchor" href="#iterator、listiterator" aria-hidden="true">#</a> Iterator、ListIterator</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ListIterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/assets/image-20200305110337107-id-gL51T.png" alt="image-20200305110337107" tabindex="0" loading="lazy"><figcaption>image-20200305110337107</figcaption></figure><ul><li>都是接口，ListIterator继承Iterator</li><li>ListIterator可以双向移动。Iterator只能单项移动</li><li>且ListIterator可以添加、修改，而Iterator不能。</li></ul><h2 id="为什么基本类型不能做为hashmap的键值" tabindex="-1"><a class="header-anchor" href="#为什么基本类型不能做为hashmap的键值" aria-hidden="true">#</a> 为什么基本类型不能做为HashMap的键值？</h2><ul><li>Java中<strong>是使用泛型来约束 HashMap 中的key和value的类型的</strong>，HashMap&lt;K, V&gt;</li><li>泛型在Java的规定中必须是对象Object类型的，基本数据类型不是Object类型，不能作为键值</li><li>map.put(0, &quot;ConstXiong&quot;)中编译器已将 key 值 0 进行了自动装箱，变为了 Integer 类型</li></ul><h2 id="array-、arrays的关系" tabindex="-1"><a class="header-anchor" href="#array-、arrays的关系" aria-hidden="true">#</a> Array 、Arrays的关系</h2><p>Array是Java.lang,reflect</p><p>Arrays是数组工具类。</p><h2 id="同步容器-与-并发容器" tabindex="-1"><a class="header-anchor" href="#同步容器-与-并发容器" aria-hidden="true">#</a> 同步容器 与 并发容器</h2><h3 id="同步容器" tabindex="-1"><a class="header-anchor" href="#同步容器" aria-hidden="true">#</a> 同步容器</h3><p>同步容器直接保证了单个操作的线程安全性，但是无法保证复合操作的线程安全性。</p><p>虽然同步容器的所有方法都加了锁，但是对这些容器的复合操作无法保证其线程安全性。<strong>需要客户端通过主动加锁来保证。</strong></p><p>因为同步容器每一个方法都加锁，所以他的并发度较低。</p><p><strong>典型代表：</strong></p><ul><li>Vector</li><li>HashTable</li><li>Collections提供的静态方法创建的类synchronizedxxx</li></ul><h3 id="并发容器" tabindex="-1"><a class="header-anchor" href="#并发容器" aria-hidden="true">#</a> 并发容器</h3><p><strong>典型代表：</strong></p><ul><li>JUC下提供大量支持高效并发访问集合类。</li><li>Concurrentxxxx</li><li>CopyOnWritexxx</li></ul><p>Copy-On-Write容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。</p></div><!--[--><!----><!--]--><footer class="page-meta"><!----><div class="meta-item git-info"><div class="update-time"><span class="label">上次编辑于: </span><!----></div><div class="contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: 554417388@qq.com">honyelchak</span><!--]--><!--]--></div></div></footer><nav class="vp-page-nav"><a aria-label="/interview/A4-Java/Java基础" class="vp-link nav-link prev nav-link prev" href="/interview/A4-Java/Java%E5%9F%BA%E7%A1%80.html"><div class="hint"><span class="arrow start"></span>上一页</div><div class="link"><!---->/interview/A4-Java/Java基础</div></a><a aria-label="/interview/A4-Java/Streams" class="vp-link nav-link next nav-link next" href="/interview/A4-Java/Streams.html"><div class="hint">下一页<span class="arrow end"></span></div><div class="link">/interview/A4-Java/Streams<!----></div></a></nav><!----><!--[--><!----><!--]--><!--]--></main><!--]--><footer class="vp-footer-wrapper"><div class="vp-footer"><div style="width:300px;margin:0 auto; padding:20px 0;"><a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=42018502006321" style="display:inline-block;text-decoration:none;height:20px;line-height:20px;"><img src="http://122.51.214.59/wp-content/uploads/2022/11/备案图标.png" style="float:left;"/><p style="float:left;height:20px;line-height:20px;margin: 0px 0px 0px 5px;">鄂公网安备 42018502006321号</p></a></div></div><div class="vp-copyright">Copyright © 2024 Honyelchak</div></footer></div><!--]--><!----><!----><!--]--></div>
    <script type="module" src="/assets/app-XffPLay1.js" defer></script>
  </body>
</html>
