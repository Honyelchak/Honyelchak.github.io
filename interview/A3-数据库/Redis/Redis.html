<!doctype html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.0" />
    <meta name="theme" content="VuePress Theme Hope 2.0.0-rc.1" />
    <style>
      html {
        background: var(--bg-color, #fff);
      }

      html[data-theme="dark"] {
        background: var(--bg-color, #1d1e1f);
      }

      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <meta property="og:url" content="https://yuejinzhao.cn/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html"><meta property="og:site_name" content="Honyelchak's Blog"><meta property="og:title" content="一、概述"><meta property="og:description" content="NoSQL：not only SQL，意即“不仅仅是SQL”，泛指非关系型数据库。 这些类型的数据存储不需要固定的格式，无需多余操作就可以横向扩展。 一、概述 Redis(REmote DIctionary Server)是速度非常快的非关系型（NoSQL）内存键值数据库，可以存储键和五种不同类型的值之间的映射。 键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。 Redis 支持很多特性，例如将内存中的数据持久化到硬盘中，使用复制来扩展读性能，使用分片来扩展写性能。"><meta property="og:type" content="article"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2023-12-02T06:45:03.000Z"><meta property="article:author" content="Honyelchak"><meta property="article:modified_time" content="2023-12-02T06:45:03.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"一、概述","image":[""],"dateModified":"2023-12-02T06:45:03.000Z","author":[{"@type":"Person","name":"Honyelchak","url":"https://yuejinzhao.cn"}]}</script><title>一、概述 | Honyelchak's Blog</title><meta name="description" content="NoSQL：not only SQL，意即“不仅仅是SQL”，泛指非关系型数据库。 这些类型的数据存储不需要固定的格式，无需多余操作就可以横向扩展。 一、概述 Redis(REmote DIctionary Server)是速度非常快的非关系型（NoSQL）内存键值数据库，可以存储键和五种不同类型的值之间的映射。 键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。 Redis 支持很多特性，例如将内存中的数据持久化到硬盘中，使用复制来扩展读性能，使用分片来扩展写性能。">
    <link rel="preload" href="/assets/style-s-J8-r2b.css" as="style"><link rel="stylesheet" href="/assets/style-s-J8-r2b.css">
    <link rel="modulepreload" href="/assets/app-_dQeDwys.js"><link rel="modulepreload" href="/assets/Redis.html-jY6OUvTt.js"><link rel="modulepreload" href="/assets/Redis.html-JbQ9AYw5.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper-x3n3nnut.js">
    <link rel="prefetch" href="/assets/index.html-TJyD3cLk.js" as="script"><link rel="prefetch" href="/assets/intro.html-1OPW3V7h.js" as="script"><link rel="prefetch" href="/assets/project.html-1c2u4iC9.js" as="script"><link rel="prefetch" href="/assets/slides.html-lVESjsnf.js" as="script"><link rel="prefetch" href="/assets/cherry.html-nS81mElm.js" as="script"><link rel="prefetch" href="/assets/index.html-4H3YBJgo.js" as="script"><link rel="prefetch" href="/assets/disable.html-dU7RYcGn.js" as="script"><link rel="prefetch" href="/assets/encrypt.html-khbb8xwB.js" as="script"><link rel="prefetch" href="/assets/markdown.html-Yx5_DxvR.js" as="script"><link rel="prefetch" href="/assets/page.html-OnIm-J2S.js" as="script"><link rel="prefetch" href="/assets/Git.html-oNpdMzPA.js" as="script"><link rel="prefetch" href="/assets/JavaWeb.html-oc6THKuy.js" as="script"><link rel="prefetch" href="/assets/Java复习汇总.html-FEkRgJDv.js" as="script"><link rel="prefetch" href="/assets/LeetCode.html-wZBUP_Cp.js" as="script"><link rel="prefetch" href="/assets/Mybatis.html-rQMkYXsT.js" as="script"><link rel="prefetch" href="/assets/Netty.html-UvLeulHs.js" as="script"><link rel="prefetch" href="/assets/Untitled.html-wpkW5Hz-.js" as="script"><link rel="prefetch" href="/assets/个人剖析.html-Qux-C6vI.js" as="script"><link rel="prefetch" href="/assets/奇奇怪怪的问题.html-R2AxlnQN.js" as="script"><link rel="prefetch" href="/assets/数据结构.html-AaLXwRzK.js" as="script"><link rel="prefetch" href="/assets/斗智斗勇.html-jr6x8I8D.js" as="script"><link rel="prefetch" href="/assets/简历埋点.html-IhryRitK.js" as="script"><link rel="prefetch" href="/assets/dragonfruit.html-REUIcmkv.js" as="script"><link rel="prefetch" href="/assets/strawberry.html-13YPqcHt.js" as="script"><link rel="prefetch" href="/assets/tomato.html-NhdZoPTn.js" as="script"><link rel="prefetch" href="/assets/前缀和题单.html-R6MndNAg.js" as="script"><link rel="prefetch" href="/assets/原则.html-JA6wxwpp.js" as="script"><link rel="prefetch" href="/assets/小知识点.html-fagpbEUh.js" as="script"><link rel="prefetch" href="/assets/由数据范围反推算法复杂度以及算法内容.html-xpUkKYl-.js" as="script"><link rel="prefetch" href="/assets/面试常考算法模板.html-i0XZjljp.js" as="script"><link rel="prefetch" href="/assets/DP.html-WiFxcle4.js" as="script"><link rel="prefetch" href="/assets/LIS.html-h-dqg6Hf.js" as="script"><link rel="prefetch" href="/assets/区间DP.html-xTd8Gfqw.js" as="script"><link rel="prefetch" href="/assets/数位DP.html-22nQiboi.js" as="script"><link rel="prefetch" href="/assets/数字三角形模型.html-Hd6I0qCy.js" as="script"><link rel="prefetch" href="/assets/斜率优化DP.html-lma1t9G6.js" as="script"><link rel="prefetch" href="/assets/树形DP.html-rHCeZz09.js" as="script"><link rel="prefetch" href="/assets/状态压缩DP.html-SLYf7WbL.js" as="script"><link rel="prefetch" href="/assets/状态机.html-LLzfw_7m.js" as="script"><link rel="prefetch" href="/assets/二分.html-QNEhReAH.js" as="script"><link rel="prefetch" href="/assets/位运算.html-2eHDuHWH.js" as="script"><link rel="prefetch" href="/assets/前缀和.html-6mcJEeIr.js" as="script"><link rel="prefetch" href="/assets/快速幂.html-EdHQND9b.js" as="script"><link rel="prefetch" href="/assets/离散化.html-SrTvrZlI.js" as="script"><link rel="prefetch" href="/assets/BFS.html-zULDF6Cv.js" as="script"><link rel="prefetch" href="/assets/DFS.html-Zyq1Alr7.js" as="script"><link rel="prefetch" href="/assets/单调栈.html-m2BDrvPz.js" as="script"><link rel="prefetch" href="/assets/并查集.html-XgWBTZ1x.js" as="script"><link rel="prefetch" href="/assets/树状数组.html-LDW52PBO.js" as="script"><link rel="prefetch" href="/assets/线段树.html-mWchzgBB.js" as="script"><link rel="prefetch" href="/assets/STL.html-ph9XXeW4.js" as="script"><link rel="prefetch" href="/assets/基础算法.html-Vih4xw3c.js" as="script"><link rel="prefetch" href="/assets/搜索与图论.html-qOdq5f8p.js" as="script"><link rel="prefetch" href="/assets/数据结构.html-KpibRNSM.js" as="script"><link rel="prefetch" href="/assets/贪心.html-1uHjL1bO.js" as="script"><link rel="prefetch" href="/assets/CPU.html-nRszTbKA.js" as="script"><link rel="prefetch" href="/assets/Linux常用命令及线上项目调优.html-xJNWFxx_.js" as="script"><link rel="prefetch" href="/assets/操作系统.html-j-jahRCL.js" as="script"><link rel="prefetch" href="/assets/IP.html-ooHZS7Ra.js" as="script"><link rel="prefetch" href="/assets/IP冲突.html-yrytBUBs.js" as="script"><link rel="prefetch" href="/assets/Netty.html-SbVYJtub.js" as="script"><link rel="prefetch" href="/assets/UDT和QUIC.html-zBnAWslA.js" as="script"><link rel="prefetch" href="/assets/网络问题.html-iokrm3Ka.js" as="script"><link rel="prefetch" href="/assets/计算机网络.html-51AKb3zX.js" as="script"><link rel="prefetch" href="/assets/MVCC多版本并发控制.html-6oHzKDEC.js" as="script"><link rel="prefetch" href="/assets/MySQL数据库性能优化.html-SWW1Elbi.js" as="script"><link rel="prefetch" href="/assets/MySQL相关指令.html-w15QIOSt.js" as="script"><link rel="prefetch" href="/assets/SQL.html-Men8iY6P.js" as="script"><link rel="prefetch" href="/assets/SQL优化.html-9YVl9_PD.js" as="script"><link rel="prefetch" href="/assets/mysql的加锁情况.html-lQuvXxK7.js" as="script"><link rel="prefetch" href="/assets/手撕SQL.html-I1oi0HDI.js" as="script"><link rel="prefetch" href="/assets/金三银四Mysql面试突击班.html-lXCakC7i.js" as="script"><link rel="prefetch" href="/assets/锁.html-iL1ZA_qB.js" as="script"><link rel="prefetch" href="/assets/IO.html-vaADi92u.js" as="script"><link rel="prefetch" href="/assets/Java8新特性.html-uXOwhN5b.js" as="script"><link rel="prefetch" href="/assets/Java基础.html-cd-t6WYR.js" as="script"><link rel="prefetch" href="/assets/Java疑难点.html-A39ZJ9uH.js" as="script"><link rel="prefetch" href="/assets/Java集合.html-yrDYFwRv.js" as="script"><link rel="prefetch" href="/assets/Streams.html-OlVuTBBp.js" as="script"><link rel="prefetch" href="/assets/查漏补缺.html-aQg5QtiM.js" as="script"><link rel="prefetch" href="/assets/SpringBoot.html-RfMG4wQo.js" as="script"><link rel="prefetch" href="/assets/SpringBoot配置文件.html-gblPkDkU.js" as="script"><link rel="prefetch" href="/assets/SpringMVC.html-edpw_Lqq.js" as="script"><link rel="prefetch" href="/assets/Spring启动过程.html-Fb0gjLIE.js" as="script"><link rel="prefetch" href="/assets/Spring框架.html-iUnC64L5.js" as="script"><link rel="prefetch" href="/assets/Spring框架面试题.html-A-6vPun2.js" as="script"><link rel="prefetch" href="/assets/Spring源码阅读.html-64253mtH.js" as="script"><link rel="prefetch" href="/assets/Spring面试题(1).html-XSPzLdxS.js" as="script"><link rel="prefetch" href="/assets/Spring面试题.html-gPZhge76.js" as="script"><link rel="prefetch" href="/assets/奇奇怪怪的Spring问题.html-UijzzvQ2.js" as="script"><link rel="prefetch" href="/assets/循坏依赖专题.html-s9pUwxWS.js" as="script"><link rel="prefetch" href="/assets/手写一个Spring框架.html-LGw0GIVU.js" as="script"><link rel="prefetch" href="/assets/设计模式专题.html-AXq-b0LV.js" as="script"><link rel="prefetch" href="/assets/12306项目分析.html-29vrC0KF.js" as="script"><link rel="prefetch" href="/assets/12306项目查漏补缺.html-nIqK_YML.js" as="script"><link rel="prefetch" href="/assets/QPS20W接口测试.html-qgDvHIgZ.js" as="script"><link rel="prefetch" href="/assets/分布式雪花算法.html-2QXODQGV.js" as="script"><link rel="prefetch" href="/assets/单机20W并发的接口设计.html-zgC7QT4Y.js" as="script"><link rel="prefetch" href="/assets/项目相关.html-gsRLX_K0.js" as="script"><link rel="prefetch" href="/assets/基本理论.html-hG_H3x4V.js" as="script"><link rel="prefetch" href="/assets/Netty.html-4dzw_auG.js" as="script"><link rel="prefetch" href="/assets/nginx.html-MAoy_qLU.js" as="script"><link rel="prefetch" href="/assets/消息队列.html-fVGKtE-R.js" as="script"><link rel="prefetch" href="/assets/2019常见面试题.html-8XyYraer.js" as="script"><link rel="prefetch" href="/assets/Java面试题(答案).html-v1wiLhXn.js" as="script"><link rel="prefetch" href="/assets/Java面试题.html-uBWc-U87.js" as="script"><link rel="prefetch" href="/assets/面试常问的问题.html-1uWz3eOz.js" as="script"><link rel="prefetch" href="/assets/网络.html--mrgvBP1.js" as="script"><link rel="prefetch" href="/assets/测试安全问题.html-8OCb_kvc.js" as="script"><link rel="prefetch" href="/assets/RISC-V.html-5Cl8EY3X.js" as="script"><link rel="prefetch" href="/assets/秒杀.html-8mH6jTUa.js" as="script"><link rel="prefetch" href="/assets/1.html-l7LwHYr5.js" as="script"><link rel="prefetch" href="/assets/2.html-iDGX3PdD.js" as="script"><link rel="prefetch" href="/assets/3.html-xxZpy1PR.js" as="script"><link rel="prefetch" href="/assets/4.html-KVfWHQvA.js" as="script"><link rel="prefetch" href="/assets/1.html-2P9V0Zzm.js" as="script"><link rel="prefetch" href="/assets/2.html-zjevKTJb.js" as="script"><link rel="prefetch" href="/assets/3.html-KmAMgI8v.js" as="script"><link rel="prefetch" href="/assets/4.html-dKO_Yw-C.js" as="script"><link rel="prefetch" href="/assets/Floyd.html-18LX8b2q.js" as="script"><link rel="prefetch" href="/assets/综述.html-HIG0Tx1T.js" as="script"><link rel="prefetch" href="/assets/基本理论.html-UC_YVBxj.js" as="script"><link rel="prefetch" href="/assets/次小生成树.html-xXEOF_Je.js" as="script"><link rel="prefetch" href="/assets/网络.html-MIXrv6fO.js" as="script"><link rel="prefetch" href="/assets/Redis削峰.html-hcDk-sZ4.js" as="script"><link rel="prefetch" href="/assets/redis配置文件.html-awJcFh1H.js" as="script"><link rel="prefetch" href="/assets/缓存和数据库双写一致性.html-ftB7L-E1.js" as="script"><link rel="prefetch" href="/assets/缓存更新策略.html-Ws8dPBI1.js" as="script"><link rel="prefetch" href="/assets/ReentrantLock中的lockInterruptibly和lock.html-8jVpnec5.js" as="script"><link rel="prefetch" href="/assets/多线程题目.html-LA_QYezZ.js" as="script"><link rel="prefetch" href="/assets/多线程高并发笔记.html-Irdva4SV.js" as="script"><link rel="prefetch" href="/assets/并发.html-_Un2zYtv.js" as="script"><link rel="prefetch" href="/assets/线程池.html-uyUy7hhG.js" as="script"><link rel="prefetch" href="/assets/JVM.html-CYW6uuHo.js" as="script"><link rel="prefetch" href="/assets/JVM上.html-icNsX-58.js" as="script"><link rel="prefetch" href="/assets/JVM下.html-KjBqO_ew.js" as="script"><link rel="prefetch" href="/assets/JVM中.html-dmvqAVCm.js" as="script"><link rel="prefetch" href="/assets/JVM面试 (copy).html-n1-HiW0B.js" as="script"><link rel="prefetch" href="/assets/JVM面试.html-sxIWVtxC.js" as="script"><link rel="prefetch" href="/assets/404.html-tlyei_5h.js" as="script"><link rel="prefetch" href="/assets/index.html-5JTjs8mG.js" as="script"><link rel="prefetch" href="/assets/index.html--YxBfJSp.js" as="script"><link rel="prefetch" href="/assets/index.html-71JEMejL.js" as="script"><link rel="prefetch" href="/assets/index.html-ITzakDtH.js" as="script"><link rel="prefetch" href="/assets/index.html-fjktaOAH.js" as="script"><link rel="prefetch" href="/assets/index.html-ysR9goIb.js" as="script"><link rel="prefetch" href="/assets/index.html-DJ7Ym7Iq.js" as="script"><link rel="prefetch" href="/assets/index.html-tyJNw07b.js" as="script"><link rel="prefetch" href="/assets/index.html-d7UHyMoy.js" as="script"><link rel="prefetch" href="/assets/index.html-tBkkuQ9X.js" as="script"><link rel="prefetch" href="/assets/index.html-oYedy5bF.js" as="script"><link rel="prefetch" href="/assets/index.html-WqtN1zQQ.js" as="script"><link rel="prefetch" href="/assets/index.html-o-IVSgtO.js" as="script"><link rel="prefetch" href="/assets/index.html-1E9AP5fk.js" as="script"><link rel="prefetch" href="/assets/index.html-me3FmHfA.js" as="script"><link rel="prefetch" href="/assets/index.html-nZyBrfgS.js" as="script"><link rel="prefetch" href="/assets/index.html-Ca2m7Cu4.js" as="script"><link rel="prefetch" href="/assets/index.html-gjy07egy.js" as="script"><link rel="prefetch" href="/assets/index.html-pMhppvm1.js" as="script"><link rel="prefetch" href="/assets/index.html-a4Ze5x_t.js" as="script"><link rel="prefetch" href="/assets/index.html-TAN0vn8L.js" as="script"><link rel="prefetch" href="/assets/index.html-nGmkbY1x.js" as="script"><link rel="prefetch" href="/assets/index.html-312PX0oj.js" as="script"><link rel="prefetch" href="/assets/index.html-ObEgcdx_.js" as="script"><link rel="prefetch" href="/assets/index.html-DcRl1Zu4.js" as="script"><link rel="prefetch" href="/assets/index.html-RYgsJuRz.js" as="script"><link rel="prefetch" href="/assets/index.html-0hP2H4N-.js" as="script"><link rel="prefetch" href="/assets/index.html-jSgb6ZKH.js" as="script"><link rel="prefetch" href="/assets/index.html-mP0vS9o6.js" as="script"><link rel="prefetch" href="/assets/index.html-9U3Hmi6I.js" as="script"><link rel="prefetch" href="/assets/index.html-Lx5ri6mA.js" as="script"><link rel="prefetch" href="/assets/index.html-V0HSX5Sw.js" as="script"><link rel="prefetch" href="/assets/index.html--RD3L-9a.js" as="script"><link rel="prefetch" href="/assets/index.html-TLF0Maaf.js" as="script"><link rel="prefetch" href="/assets/index.html-7B1umk9D.js" as="script"><link rel="prefetch" href="/assets/index.html-LDS5hg0b.js" as="script"><link rel="prefetch" href="/assets/index.html-03f83TYL.js" as="script"><link rel="prefetch" href="/assets/index.html-Vm7CMeJ9.js" as="script"><link rel="prefetch" href="/assets/index.html-PxwaX4D5.js" as="script"><link rel="prefetch" href="/assets/index.html-GD-sGv9o.js" as="script"><link rel="prefetch" href="/assets/index.html-7fHiBdve.js" as="script"><link rel="prefetch" href="/assets/index.html-uaVWCPeu.js" as="script"><link rel="prefetch" href="/assets/index.html-9Qhj3LDt.js" as="script"><link rel="prefetch" href="/assets/index.html-1pEV0-DQ.js" as="script"><link rel="prefetch" href="/assets/index.html-HG-dF-LV.js" as="script"><link rel="prefetch" href="/assets/index.html-Awfi2Oy0.js" as="script"><link rel="prefetch" href="/assets/index.html-kjfsO1qY.js" as="script"><link rel="prefetch" href="/assets/index.html-m-ubR1oj.js" as="script"><link rel="prefetch" href="/assets/index.html-zti7c-jn.js" as="script"><link rel="prefetch" href="/assets/index.html-yLAg9VY_.js" as="script"><link rel="prefetch" href="/assets/index.html-FUeLVl_L.js" as="script"><link rel="prefetch" href="/assets/index.html-OqUPM_6t.js" as="script"><link rel="prefetch" href="/assets/index.html-FvD6AmyZ.js" as="script"><link rel="prefetch" href="/assets/index.html-IzKBN8uZ.js" as="script"><link rel="prefetch" href="/assets/index.html-hx-a2twd.js" as="script"><link rel="prefetch" href="/assets/index.html-BQhJTnsp.js" as="script"><link rel="prefetch" href="/assets/index.html-4T1nTBMu.js" as="script"><link rel="prefetch" href="/assets/index.html-j1p3xwFm.js" as="script"><link rel="prefetch" href="/assets/intro.html-CrFd_OkX.js" as="script"><link rel="prefetch" href="/assets/project.html-PxmS83I7.js" as="script"><link rel="prefetch" href="/assets/slides.html-foxsdEPI.js" as="script"><link rel="prefetch" href="/assets/cherry.html-69QbF_X2.js" as="script"><link rel="prefetch" href="/assets/index.html-rHITYQO6.js" as="script"><link rel="prefetch" href="/assets/disable.html-5UHP5c6M.js" as="script"><link rel="prefetch" href="/assets/encrypt.html-PQdbK8nw.js" as="script"><link rel="prefetch" href="/assets/markdown.html-WTzrSQQF.js" as="script"><link rel="prefetch" href="/assets/page.html-Tvns-x-U.js" as="script"><link rel="prefetch" href="/assets/Git.html-_IRUUxIU.js" as="script"><link rel="prefetch" href="/assets/JavaWeb.html-e3NGPneM.js" as="script"><link rel="prefetch" href="/assets/Java复习汇总.html-dg6jwjVv.js" as="script"><link rel="prefetch" href="/assets/LeetCode.html-U93QfIFK.js" as="script"><link rel="prefetch" href="/assets/Mybatis.html-uJrkWgfj.js" as="script"><link rel="prefetch" href="/assets/Netty.html-MWIwbuk_.js" as="script"><link rel="prefetch" href="/assets/Untitled.html-qH2pTOfa.js" as="script"><link rel="prefetch" href="/assets/个人剖析.html-DPTBZ98C.js" as="script"><link rel="prefetch" href="/assets/奇奇怪怪的问题.html-V8rVhf4T.js" as="script"><link rel="prefetch" href="/assets/数据结构.html-jc5Gky_u.js" as="script"><link rel="prefetch" href="/assets/斗智斗勇.html-38k6LtCy.js" as="script"><link rel="prefetch" href="/assets/简历埋点.html-Xgp4Nztj.js" as="script"><link rel="prefetch" href="/assets/dragonfruit.html-beGhF_B3.js" as="script"><link rel="prefetch" href="/assets/strawberry.html-7IHsIBcj.js" as="script"><link rel="prefetch" href="/assets/tomato.html-CG7gZS24.js" as="script"><link rel="prefetch" href="/assets/前缀和题单.html-IZgNq2rC.js" as="script"><link rel="prefetch" href="/assets/原则.html-GcTwBchL.js" as="script"><link rel="prefetch" href="/assets/小知识点.html-qDsWzWs8.js" as="script"><link rel="prefetch" href="/assets/由数据范围反推算法复杂度以及算法内容.html-KYYzpbxt.js" as="script"><link rel="prefetch" href="/assets/面试常考算法模板.html-vA5BqgpZ.js" as="script"><link rel="prefetch" href="/assets/DP.html-HMgJceNr.js" as="script"><link rel="prefetch" href="/assets/LIS.html-AwsbRk8t.js" as="script"><link rel="prefetch" href="/assets/区间DP.html-u6KUZPML.js" as="script"><link rel="prefetch" href="/assets/数位DP.html-PwXKaxg1.js" as="script"><link rel="prefetch" href="/assets/数字三角形模型.html-qCQQrYf9.js" as="script"><link rel="prefetch" href="/assets/斜率优化DP.html-a1RafgH-.js" as="script"><link rel="prefetch" href="/assets/树形DP.html-UchQcJSI.js" as="script"><link rel="prefetch" href="/assets/状态压缩DP.html-TADWIv_s.js" as="script"><link rel="prefetch" href="/assets/状态机.html-ikXMnM_D.js" as="script"><link rel="prefetch" href="/assets/二分.html-MlL0ty7i.js" as="script"><link rel="prefetch" href="/assets/位运算.html-Q9u5_Vge.js" as="script"><link rel="prefetch" href="/assets/前缀和.html-6ULMGduI.js" as="script"><link rel="prefetch" href="/assets/快速幂.html-8xjtKNiT.js" as="script"><link rel="prefetch" href="/assets/离散化.html-T1nabbq_.js" as="script"><link rel="prefetch" href="/assets/BFS.html-NgT46bQa.js" as="script"><link rel="prefetch" href="/assets/DFS.html-sNK-Ey73.js" as="script"><link rel="prefetch" href="/assets/单调栈.html-zSOFxjb0.js" as="script"><link rel="prefetch" href="/assets/并查集.html-prZwbIQp.js" as="script"><link rel="prefetch" href="/assets/树状数组.html-i4uikXEc.js" as="script"><link rel="prefetch" href="/assets/线段树.html-H0mWmyOf.js" as="script"><link rel="prefetch" href="/assets/STL.html-cL7cVbPU.js" as="script"><link rel="prefetch" href="/assets/基础算法.html-2Da1qLAP.js" as="script"><link rel="prefetch" href="/assets/搜索与图论.html-ZBkaoFI7.js" as="script"><link rel="prefetch" href="/assets/数据结构.html-ymUTaIQJ.js" as="script"><link rel="prefetch" href="/assets/贪心.html-deT6FEOU.js" as="script"><link rel="prefetch" href="/assets/CPU.html-RyFQgprw.js" as="script"><link rel="prefetch" href="/assets/Linux常用命令及线上项目调优.html-tPnFLaLm.js" as="script"><link rel="prefetch" href="/assets/操作系统.html-_BPZUfrf.js" as="script"><link rel="prefetch" href="/assets/IP.html-2v2E_bzD.js" as="script"><link rel="prefetch" href="/assets/IP冲突.html-GV32IREe.js" as="script"><link rel="prefetch" href="/assets/Netty.html-J7QkovFO.js" as="script"><link rel="prefetch" href="/assets/UDT和QUIC.html-HDtOoSjO.js" as="script"><link rel="prefetch" href="/assets/网络问题.html-ilmzGnBL.js" as="script"><link rel="prefetch" href="/assets/计算机网络.html-DcQUj-mn.js" as="script"><link rel="prefetch" href="/assets/MVCC多版本并发控制.html-bHjwhWko.js" as="script"><link rel="prefetch" href="/assets/MySQL数据库性能优化.html-PNAW7UfT.js" as="script"><link rel="prefetch" href="/assets/MySQL相关指令.html-IbpeGyab.js" as="script"><link rel="prefetch" href="/assets/SQL.html-8ZLvTbIV.js" as="script"><link rel="prefetch" href="/assets/SQL优化.html-Tc60Z2KH.js" as="script"><link rel="prefetch" href="/assets/mysql的加锁情况.html-XJB9jHAJ.js" as="script"><link rel="prefetch" href="/assets/手撕SQL.html-tFQlSdlY.js" as="script"><link rel="prefetch" href="/assets/金三银四Mysql面试突击班.html-5Pke0g7v.js" as="script"><link rel="prefetch" href="/assets/锁.html-JJISi0zY.js" as="script"><link rel="prefetch" href="/assets/IO.html-5wGVTsEd.js" as="script"><link rel="prefetch" href="/assets/Java8新特性.html-uCQAfmVe.js" as="script"><link rel="prefetch" href="/assets/Java基础.html-KkIPpvSi.js" as="script"><link rel="prefetch" href="/assets/Java疑难点.html-jao7Q06V.js" as="script"><link rel="prefetch" href="/assets/Java集合.html-oWdTraws.js" as="script"><link rel="prefetch" href="/assets/Streams.html-qwviTMKA.js" as="script"><link rel="prefetch" href="/assets/查漏补缺.html-Tzv_yLM_.js" as="script"><link rel="prefetch" href="/assets/SpringBoot.html-RKoCVXfb.js" as="script"><link rel="prefetch" href="/assets/SpringBoot配置文件.html-bBydVLOD.js" as="script"><link rel="prefetch" href="/assets/SpringMVC.html-mqIf9uaH.js" as="script"><link rel="prefetch" href="/assets/Spring启动过程.html-7PyxpbbR.js" as="script"><link rel="prefetch" href="/assets/Spring框架.html-FaJo75jH.js" as="script"><link rel="prefetch" href="/assets/Spring框架面试题.html-_1UBB7m5.js" as="script"><link rel="prefetch" href="/assets/Spring源码阅读.html-5VaTozO0.js" as="script"><link rel="prefetch" href="/assets/Spring面试题(1).html-0yewJnNa.js" as="script"><link rel="prefetch" href="/assets/Spring面试题.html-3uhVdxqQ.js" as="script"><link rel="prefetch" href="/assets/奇奇怪怪的Spring问题.html-BBtunO5H.js" as="script"><link rel="prefetch" href="/assets/循坏依赖专题.html-IqJ7C5oe.js" as="script"><link rel="prefetch" href="/assets/手写一个Spring框架.html-4I9P32q0.js" as="script"><link rel="prefetch" href="/assets/设计模式专题.html-Al4S02v2.js" as="script"><link rel="prefetch" href="/assets/12306项目分析.html-RAgFuytj.js" as="script"><link rel="prefetch" href="/assets/12306项目查漏补缺.html-5yfLAC9u.js" as="script"><link rel="prefetch" href="/assets/QPS20W接口测试.html-EIVqGUhR.js" as="script"><link rel="prefetch" href="/assets/分布式雪花算法.html-K9Eyz9qS.js" as="script"><link rel="prefetch" href="/assets/单机20W并发的接口设计.html-h-OdwGR1.js" as="script"><link rel="prefetch" href="/assets/项目相关.html-_IzamkhF.js" as="script"><link rel="prefetch" href="/assets/基本理论.html-vmS7SL6u.js" as="script"><link rel="prefetch" href="/assets/Netty.html-aexxJpU6.js" as="script"><link rel="prefetch" href="/assets/nginx.html-l71ey52r.js" as="script"><link rel="prefetch" href="/assets/消息队列.html-f9hLe4IL.js" as="script"><link rel="prefetch" href="/assets/2019常见面试题.html-yKmaUpx2.js" as="script"><link rel="prefetch" href="/assets/Java面试题(答案).html-5IochmPC.js" as="script"><link rel="prefetch" href="/assets/Java面试题.html-NGaZnRlX.js" as="script"><link rel="prefetch" href="/assets/面试常问的问题.html-u31RLHXt.js" as="script"><link rel="prefetch" href="/assets/网络.html-8D1RiJ1M.js" as="script"><link rel="prefetch" href="/assets/测试安全问题.html-pf-724Y0.js" as="script"><link rel="prefetch" href="/assets/RISC-V.html-kXlQz7PJ.js" as="script"><link rel="prefetch" href="/assets/秒杀.html-l_vj0GYQ.js" as="script"><link rel="prefetch" href="/assets/1.html-SC5D4HMm.js" as="script"><link rel="prefetch" href="/assets/2.html-xokqY9JS.js" as="script"><link rel="prefetch" href="/assets/3.html-63tT5sWY.js" as="script"><link rel="prefetch" href="/assets/4.html-uVfNHt85.js" as="script"><link rel="prefetch" href="/assets/1.html-4OJRlIqR.js" as="script"><link rel="prefetch" href="/assets/2.html-kgms37SS.js" as="script"><link rel="prefetch" href="/assets/3.html-RfRnp7WV.js" as="script"><link rel="prefetch" href="/assets/4.html-_Lr9o4OG.js" as="script"><link rel="prefetch" href="/assets/Floyd.html-XMaZ3aiT.js" as="script"><link rel="prefetch" href="/assets/综述.html-NQPrRx2b.js" as="script"><link rel="prefetch" href="/assets/基本理论.html-uNElyDu8.js" as="script"><link rel="prefetch" href="/assets/次小生成树.html-EIlPRK75.js" as="script"><link rel="prefetch" href="/assets/网络.html-7cZdNpiQ.js" as="script"><link rel="prefetch" href="/assets/Redis削峰.html-OznxY4mS.js" as="script"><link rel="prefetch" href="/assets/redis配置文件.html-hDrpVKYX.js" as="script"><link rel="prefetch" href="/assets/缓存和数据库双写一致性.html-CVX1XVEh.js" as="script"><link rel="prefetch" href="/assets/缓存更新策略.html-Rl25CQPe.js" as="script"><link rel="prefetch" href="/assets/ReentrantLock中的lockInterruptibly和lock.html-f8ZhTtNl.js" as="script"><link rel="prefetch" href="/assets/多线程题目.html-tSnTWS-L.js" as="script"><link rel="prefetch" href="/assets/多线程高并发笔记.html-JsChvawk.js" as="script"><link rel="prefetch" href="/assets/并发.html-Dctl45Z-.js" as="script"><link rel="prefetch" href="/assets/线程池.html-KT6KNP2e.js" as="script"><link rel="prefetch" href="/assets/JVM.html-VUZyPoKG.js" as="script"><link rel="prefetch" href="/assets/JVM上.html-oQMtVYRG.js" as="script"><link rel="prefetch" href="/assets/JVM下.html-_hKQrgr6.js" as="script"><link rel="prefetch" href="/assets/JVM中.html-YADHTrja.js" as="script"><link rel="prefetch" href="/assets/JVM面试 (copy).html-AoNTwFzm.js" as="script"><link rel="prefetch" href="/assets/JVM面试.html-gefUgiqF.js" as="script"><link rel="prefetch" href="/assets/404.html-r5ZCmiM0.js" as="script"><link rel="prefetch" href="/assets/index.html-rCUKvMnN.js" as="script"><link rel="prefetch" href="/assets/index.html-N57fgIrH.js" as="script"><link rel="prefetch" href="/assets/index.html-a8XbNRNn.js" as="script"><link rel="prefetch" href="/assets/index.html-COlppnQk.js" as="script"><link rel="prefetch" href="/assets/index.html-pyRVdBTv.js" as="script"><link rel="prefetch" href="/assets/index.html-HOL3-gQ2.js" as="script"><link rel="prefetch" href="/assets/index.html-5RjGse8e.js" as="script"><link rel="prefetch" href="/assets/index.html-pzP15I8X.js" as="script"><link rel="prefetch" href="/assets/index.html-qXdun72T.js" as="script"><link rel="prefetch" href="/assets/index.html-0BN1kCla.js" as="script"><link rel="prefetch" href="/assets/index.html-YS3W3JZb.js" as="script"><link rel="prefetch" href="/assets/index.html-FXP2QW3w.js" as="script"><link rel="prefetch" href="/assets/index.html-YZ35KlwH.js" as="script"><link rel="prefetch" href="/assets/index.html-_9gs_jod.js" as="script"><link rel="prefetch" href="/assets/index.html-CZrgcu4u.js" as="script"><link rel="prefetch" href="/assets/index.html-YgouxP__.js" as="script"><link rel="prefetch" href="/assets/index.html-eBIoycM0.js" as="script"><link rel="prefetch" href="/assets/index.html-BiUJxVxu.js" as="script"><link rel="prefetch" href="/assets/index.html-EnZpQpUA.js" as="script"><link rel="prefetch" href="/assets/index.html--7D36E37.js" as="script"><link rel="prefetch" href="/assets/index.html-BcwO5X8n.js" as="script"><link rel="prefetch" href="/assets/index.html-5R0k2Ezv.js" as="script"><link rel="prefetch" href="/assets/index.html-Gvy_XkL7.js" as="script"><link rel="prefetch" href="/assets/index.html-74nCY1q_.js" as="script"><link rel="prefetch" href="/assets/index.html-pRNAqr0A.js" as="script"><link rel="prefetch" href="/assets/index.html-ZCqi0TXh.js" as="script"><link rel="prefetch" href="/assets/index.html-LV1REigO.js" as="script"><link rel="prefetch" href="/assets/index.html-tpBtlDjF.js" as="script"><link rel="prefetch" href="/assets/index.html-G0oyTrBa.js" as="script"><link rel="prefetch" href="/assets/index.html-QA4aMZDh.js" as="script"><link rel="prefetch" href="/assets/index.html-ODBpfQ_1.js" as="script"><link rel="prefetch" href="/assets/index.html-QnG2w8BB.js" as="script"><link rel="prefetch" href="/assets/index.html-Bq6eknPY.js" as="script"><link rel="prefetch" href="/assets/index.html-wg00LF7W.js" as="script"><link rel="prefetch" href="/assets/index.html-oYMnXBND.js" as="script"><link rel="prefetch" href="/assets/index.html-25ZDAwRm.js" as="script"><link rel="prefetch" href="/assets/index.html-0LvI7w65.js" as="script"><link rel="prefetch" href="/assets/index.html-tjNU7l4_.js" as="script"><link rel="prefetch" href="/assets/index.html-BWxhqCva.js" as="script"><link rel="prefetch" href="/assets/index.html-8gCl_xkT.js" as="script"><link rel="prefetch" href="/assets/index.html-AHoht34p.js" as="script"><link rel="prefetch" href="/assets/index.html-JWvCdv7f.js" as="script"><link rel="prefetch" href="/assets/index.html-7m-BTi2r.js" as="script"><link rel="prefetch" href="/assets/index.html-IRMUWs3j.js" as="script"><link rel="prefetch" href="/assets/index.html-A8YxbXPy.js" as="script"><link rel="prefetch" href="/assets/index.html-p6QAuL_c.js" as="script"><link rel="prefetch" href="/assets/index.html-BSpRSIQL.js" as="script"><link rel="prefetch" href="/assets/index.html-5vMJo5zl.js" as="script"><link rel="prefetch" href="/assets/index.html-NzOldGCw.js" as="script"><link rel="prefetch" href="/assets/index.html-8LHbHViB.js" as="script"><link rel="prefetch" href="/assets/index.html-QJ1JiGiQ.js" as="script"><link rel="prefetch" href="/assets/index.html-luFRsGQO.js" as="script"><link rel="prefetch" href="/assets/index.html-lEOgePBM.js" as="script"><link rel="prefetch" href="/assets/index.html-n2WOIVUQ.js" as="script"><link rel="prefetch" href="/assets/index.html-Rr0p6vcr.js" as="script"><link rel="prefetch" href="/assets/index.html-uigoOqzk.js" as="script"><link rel="prefetch" href="/assets/index.html-ekS7DzYz.js" as="script"><link rel="prefetch" href="/assets/photoswipe.esm-i2ohwMnJ.js" as="script"><link rel="prefetch" href="/assets/SearchResult-3GFtD4MS.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container has-toc"><!--[--><header id="navbar" class="vp-navbar"><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><!--[--><a class="vp-link vp-brand vp-brand" href="/"><img class="vp-nav-logo" src="/icon.png" alt="Honyelchak&#39;s Blog"><!----><span class="vp-site-name hide-in-pad">Honyelchak&#39;s Blog</span></a><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-center"><!--[--><!----><!--]--><!--[--><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-end"><!--[--><!----><!--]--><!--[--><!--[--><button type="button" class="search-pro-button" role="search" aria-label="搜索"><svg xmlns="http://www.w3.org/2000/svg" class="icon search-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="search icon"><path d="M192 480a256 256 0 1 1 512 0 256 256 0 0 1-512 0m631.776 362.496-143.2-143.168A318.464 318.464 0 0 0 768 480c0-176.736-143.264-320-320-320S128 303.264 128 480s143.264 320 320 320a318.016 318.016 0 0 0 184.16-58.592l146.336 146.368c12.512 12.48 32.768 12.48 45.28 0 12.48-12.512 12.48-32.768 0-45.28"></path></svg><div class="search-pro-placeholder">搜索</div><div class="search-pro-key-hints"><kbd class="search-pro-key">Ctrl</kbd><kbd class="search-pro-key">K</kbd></div></button><!--]--><!----><div class="nav-item hide-in-mobile"><button type="button" id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><nav class="vp-nav-links"><div class="nav-item hide-in-mobile"><a aria-label="主页" class="vp-link nav-link nav-link" href="/"><span class="font-icon icon fa-fw fa-sm fas fa-home" style=""></span>主页<!----></a></div><div class="nav-item hide-in-mobile"><a aria-label="Java学习" class="vp-link nav-link active nav-link active" href="/interview.html"><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span>Java学习<!----></a></div><div class="nav-item hide-in-mobile"><a aria-label="算法学习" class="vp-link nav-link nav-link" href="/algorithm.html"><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span>算法学习<!----></a></div><div class="nav-item hide-in-mobile"><a aria-label="课程学习" class="vp-link nav-link nav-link" href="/course.html"><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span>课程学习<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button type="button" class="dropdown-title" aria-label="项目"><span class="title"><span class="font-icon icon fa-fw fa-sm fas fa-circle-info" style=""></span>项目</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>教程</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a aria-label="/zh/cookbook/markdown/" class="vp-link nav-link nav-link" href="/zh/cookbook/markdown/"><!---->/zh/cookbook/markdown/<!----></a></li><li class="dropdown-subitem"><a aria-label="/zh/cookbook/vuepress/" class="vp-link nav-link nav-link" href="/zh/cookbook/vuepress/"><!---->/zh/cookbook/vuepress/<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>项目</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a aria-label="/zh/changelog" class="vp-link nav-link nav-link" href="/zh/changelog.html"><!---->/zh/changelog<!----></a></li><li class="dropdown-subitem"><a aria-label="/zh/migration/" class="vp-link nav-link nav-link" href="/zh/migration/"><!---->/zh/migration/<!----></a></li><li class="dropdown-subitem"><a aria-label="/zh/related" class="vp-link nav-link nav-link" href="/zh/related.html"><!---->/zh/related<!----></a></li><li class="dropdown-subitem"><a aria-label="/zh/contribution" class="vp-link nav-link nav-link" href="/zh/contribution.html"><!---->/zh/contribution<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><a aria-label="关于我" class="vp-link nav-link nav-link" href="/project.html"><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span>关于我<!----></a></div></nav><!--]--><!--[--><!----><!--]--><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar"><!--[--><!----><!--]--><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><p class="vp-sidebar-heading clickable active"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span><a aria-label="操作系统" class="vp-link nav-link vp-sidebar-title nav-link vp-sidebar-title" href="/interview/A1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><!---->操作系统<!----></a><!----></p><ul class="vp-sidebar-links"><li><!--[--><a aria-label="/interview/Git" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/Git.html"><!---->/interview/Git<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="/interview/JavaWeb" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/JavaWeb.html"><!---->/interview/JavaWeb<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="/interview/Java复习汇总" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/Java%E5%A4%8D%E4%B9%A0%E6%B1%87%E6%80%BB.html"><!---->/interview/Java复习汇总<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="/interview/Mybatis" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/Mybatis.html"><!---->/interview/Mybatis<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="/interview/Untitled" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/Untitled.html"><!---->/interview/Untitled<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="/interview/个人剖析" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/%E4%B8%AA%E4%BA%BA%E5%89%96%E6%9E%90.html"><!---->/interview/个人剖析<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="/interview/数据结构" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html"><!---->/interview/数据结构<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="/interview/斗智斗勇" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/%E6%96%97%E6%99%BA%E6%96%97%E5%8B%87.html"><!---->/interview/斗智斗勇<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="2 算法" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/LeetCode.html"><!---->2 算法<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">A1 操作系统</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">A2 计算机网络</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable active" type="button"><!----><span class="vp-sidebar-title">A3 数据库</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><!--[--><a aria-label="/interview/A3-数据库/MySQL数据库性能优化" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html"><!---->/interview/A3-数据库/MySQL数据库性能优化<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="/interview/A3-数据库/MySQL相关指令" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E7%9B%B8%E5%85%B3%E6%8C%87%E4%BB%A4.html"><!---->/interview/A3-数据库/MySQL相关指令<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="/interview/A3-数据库/SQL优化" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/SQL%E4%BC%98%E5%8C%96.html"><!---->/interview/A3-数据库/SQL优化<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="2021版" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%87%91%E4%B8%89%E9%93%B6%E5%9B%9BMysql%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB%E7%8F%AD.html"><!---->2021版<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="MVCC多版本并发控制" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/MVCC%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6.html"><!---->MVCC多版本并发控制<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="mysql的加锁情况" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E7%9A%84%E5%8A%A0%E9%94%81%E6%83%85%E5%86%B5.html"><!---->mysql的加锁情况<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable active" type="button"><!----><span class="vp-sidebar-title">Redis</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><!--[--><a aria-label="/interview/A3-数据库/Redis/Redis削峰" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%89%8A%E5%B3%B0.html"><!---->/interview/A3-数据库/Redis/Redis削峰<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="/interview/A3-数据库/Redis/redis配置文件" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/redis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.html"><!---->/interview/A3-数据库/Redis/redis配置文件<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="/interview/A3-数据库/Redis/缓存和数据库双写一致性" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7.html"><!---->/interview/A3-数据库/Redis/缓存和数据库双写一致性<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="/interview/A3-数据库/Redis/缓存更新策略" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5.html"><!---->/interview/A3-数据库/Redis/缓存更新策略<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="一、概述" class="vp-link nav-link active vp-sidebar-link vp-sidebar-page active nav-link active vp-sidebar-link vp-sidebar-page active" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html"><!---->一、概述<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="1、redis单线程 vs 多线程" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#_1、redis单线程-vs-多线程"><!---->1、redis单线程 vs 多线程<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="2、redis6.0如何开启多线程" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#_2、redis6-0如何开启多线程"><!---->2、redis6.0如何开启多线程<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="1、STRING" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#_1、string"><!---->1、STRING<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="2、HASH" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#_2、hash"><!---->2、HASH<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="3、LIST" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#_3、list"><!---->3、LIST<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="4、SET" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#_4、set"><!---->4、SET<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="数据结构" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#数据结构"><!---->数据结构<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="5、ZSET" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#_5、zset"><!---->5、ZSET<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="6、bitmap" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#_6、bitmap"><!---->6、bitmap<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="基本操作" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#基本操作"><!---->基本操作<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="扩容机制" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#扩容机制"><!---->扩容机制<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="7、hyperloglog" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#_7、hyperloglog"><!---->7、hyperloglog<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="基本操作" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#基本操作-1"><!---->基本操作<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="应用场景" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#应用场景"><!---->应用场景<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="8、GEO" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#_8、geo"><!---->8、GEO<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="基本原理" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#基本原理"><!---->基本原理<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="基本操作" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#基本操作-2"><!---->基本操作<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="SDS" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#sds"><!---->SDS<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="结构" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#结构"><!---->结构<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="优势" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#优势"><!---->优势<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="内部编码" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#内部编码"><!---->内部编码<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="链表" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#链表"><!---->链表<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="链表结构设计" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#链表结构设计"><!---->链表结构设计<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="链表的优势与缺陷" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#链表的优势与缺陷"><!---->链表的优势与缺陷<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="ZipList(用时间还换空间)" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#ziplist-用时间还换空间"><!---->ZipList(用时间还换空间)<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="结构" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#结构-1"><!---->结构<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="整数集合(intset)" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#整数集合-intset"><!---->整数集合(intset)<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="特点" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#特点"><!---->特点<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="主要操作" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#主要操作"><!---->主要操作<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="优缺点" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#优缺点"><!---->优缺点<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="应用" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#应用"><!---->应用<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="缓存雪崩" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#缓存雪崩"><!---->缓存雪崩<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="缓存穿透" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#缓存穿透"><!---->缓存穿透<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="缓存击穿" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#缓存击穿"><!---->缓存击穿<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="缓存预热" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#缓存预热"><!---->缓存预热<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="基本概念" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#基本概念"><!---->基本概念<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="方案" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#方案"><!---->方案<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="setnx + expire" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#setnx-expire"><!---->setnx + expire<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="setnx value为(系统时间 + 过期时间)" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#setnx-value为-系统时间-过期时间"><!---->setnx value为(系统时间 + 过期时间)<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Lua脚本(setnx + expire)" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#lua脚本-setnx-expire"><!---->Lua脚本(setnx + expire)<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Set的扩展命令(SET EX PX NX)" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#set的扩展命令-set-ex-px-nx"><!---->Set的扩展命令(SET EX PX NX)<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="SET NX PX NX + 校验唯一随机值，再删除" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#set-nx-px-nx-校验唯一随机值-再删除"><!---->SET NX PX NX + 校验唯一随机值，再删除<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Redisson框架" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#redisson框架"><!---->Redisson框架<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="多机实现的分布式锁Redlock+Redisson" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#多机实现的分布式锁redlock-redisson"><!---->多机实现的分布式锁Redlock+Redisson<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="相关面试题" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#相关面试题"><!---->相关面试题<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="RDB 持久化" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#rdb-持久化"><!---->RDB 持久化<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="触发策略" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#触发策略"><!---->触发策略<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="执行快照时，数据能被修改吗？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#执行快照时-数据能被修改吗"><!---->执行快照时，数据能被修改吗？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="AOF 持久化" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#aof-持久化"><!---->AOF 持久化<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="使用方法" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#使用方法"><!---->使用方法<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="日志格式" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#日志格式"><!---->日志格式<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="写回策略" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#写回策略"><!---->写回策略<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="重写机制" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#重写机制"><!---->重写机制<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="AOF修复" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#aof修复"><!---->AOF修复<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="总结" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#总结"><!---->总结<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="RDB 和 AOF 合体" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#rdb-和-aof-合体"><!---->RDB 和 AOF 合体<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="常用命令" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#常用命令"><!---->常用命令<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="三个阶段" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#三个阶段"><!---->三个阶段<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="四种错误情况" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#四种错误情况"><!---->四种错误情况<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="特性" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#特性"><!---->特性<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="文件事件" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#文件事件"><!---->文件事件<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="时间事件" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#时间事件"><!---->时间事件<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="事件的调度与执行" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#事件的调度与执行"><!---->事件的调度与执行<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="连接过程" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#连接过程"><!---->连接过程<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="主从链" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#主从链"><!---->主从链<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="常用玩法" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#常用玩法"><!---->常用玩法<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="缺点" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#缺点"><!---->缺点<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="面试题" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#面试题"><!---->面试题<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="1、为什么redis集群的最大槽位是16384个？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#_1、为什么redis集群的最大槽位是16384个"><!---->1、为什么redis集群的最大槽位是16384个？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="玩法" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#玩法"><!---->玩法<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="文章信息" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#文章信息"><!---->文章信息<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="点赞功能" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#点赞功能"><!---->点赞功能<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="对文章进行排序" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#对文章进行排序"><!---->对文章进行排序<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="BASE" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#base"><!---->BASE<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Redis部分命令" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#redis部分命令"><!---->Redis部分命令<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="查看redis版本信息" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#查看redis版本信息"><!---->查看redis版本信息<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="数据库命令" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#数据库命令"><!---->数据库命令<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="String类型命令" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#string类型命令"><!---->String类型命令<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="List类型命令" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#list类型命令"><!---->List类型命令<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Docker容器部署Redis" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#docker容器部署redis"><!---->Docker容器部署Redis<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="1、基本数据类型，你还知道其他redis的类型吗？你是怎么应用这几个数据类型的？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#_1、基本数据类型-你还知道其他redis的类型吗-你是怎么应用这几个数据类型的"><!---->1、基本数据类型，你还知道其他redis的类型吗？你是怎么应用这几个数据类型的？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="2、bigkey、hotkey的定义" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#_2、bigkey、hotkey的定义"><!---->2、bigkey、hotkey的定义<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="bigkey" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#bigkey"><!---->bigkey<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="hotkeys" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#hotkeys"><!---->hotkeys<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="3、如何排查Redis的bigkey、hotkey？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#_3、如何排查redis的bigkey、hotkey"><!---->3、如何排查Redis的bigkey、hotkey？<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="查找bigkey" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#查找bigkey"><!---->查找bigkey<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="查找HotKey" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#查找hotkey"><!---->查找HotKey<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="4、如何解决bigkey以及hotkey问题" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#_4、如何解决bigkey以及hotkey问题"><!---->4、如何解决bigkey以及hotkey问题<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="bigkey" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#bigkey-1"><!---->bigkey<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="hotkey" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#hotkey"><!---->hotkey<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="5、个人觉得Redis中比较惊艳的地方？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#_5、个人觉得redis中比较惊艳的地方"><!---->5、个人觉得Redis中比较惊艳的地方？<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="SDS会默认会创建 0~10000的共享对象" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#sds会默认会创建-0-10000的共享对象"><!---->SDS会默认会创建 0~10000的共享对象<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="6、Redis中的各个组成部分的关系" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#_6、redis中的各个组成部分的关系"><!---->6、Redis中的各个组成部分的关系<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="7、Redis中是如何解决hash碰撞的？和HashMap有什么区别？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#_7、redis中是如何解决hash碰撞的-和hashmap有什么区别"><!---->7、Redis中是如何解决hash碰撞的？和HashMap有什么区别？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="8、渐进式rehash" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#_8、渐进式rehash"><!---->8、渐进式rehash<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="9、Innodb为什么选择使用B+树而不是跳表，Redis为什么选择调表而不是B+树？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#_9、innodb为什么选择使用b-树而不是跳表-redis为什么选择调表而不是b-树"><!---->9、Innodb为什么选择使用B+树而不是跳表，Redis为什么选择调表而不是B+树？<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="B+树和跳表相同之处" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#b-树和跳表相同之处"><!---->B+树和跳表相同之处<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="不同之处" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis.html#不同之处"><!---->不同之处<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li></ul><!--]--></li></ul></section></li><li><!--[--><a aria-label="SQL基础知识" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%89%8B%E6%92%95SQL.html"><!---->SQL基础知识<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="一、字符集" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/SQL.html"><!---->一、字符集<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="锁的种类" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%81.html"><!---->锁的种类<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li></ul></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">A4 Java</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">A5 Spring</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">A6 高并发相关</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">A7 分布式</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">A8 中间件</span><span class="vp-arrow end"></span></button><!----></section></li><li><!--[--><a aria-label="JAVA" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E9%97%AE%E9%A2%98.html"><!---->JAVA<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">Java面试题</span><span class="vp-arrow end"></span></button><!----></section></li><li><!--[--><a aria-label="三、总结" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/%E7%AE%80%E5%8E%86%E5%9F%8B%E7%82%B9.html"><!---->三、总结<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">工具</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">测试开发</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">硬件</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">系统设计</span><span class="vp-arrow end"></span></button><!----></section></li><li><!--[--><a aria-label="面试题" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/Netty.html"><!---->面试题<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li></ul></section></li><li><section class="vp-sidebar-group"><p class="vp-sidebar-heading"><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span><span class="vp-sidebar-title">计算机网络</span><!----></p><ul class="vp-sidebar-links"><li><!--[--><a aria-label="/interview/A2-计算机网络/IP冲突" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/A2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E5%86%B2%E7%AA%81.html"><!---->/interview/A2-计算机网络/IP冲突<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="/interview/A2-计算机网络/UDT和QUIC" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/A2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/UDT%E5%92%8CQUIC.html"><!---->/interview/A2-计算机网络/UDT和QUIC<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="/interview/A2-计算机网络/网络问题" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/A2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98.html"><!---->/interview/A2-计算机网络/网络问题<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="IP" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/A2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP.html"><!---->IP<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="一、HTTP" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/A2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.html"><!---->一、HTTP<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="常见问题" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/interview/A2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Netty.html"><!---->常见问题<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">重学计算机网络</span><span class="vp-arrow end"></span></button><!----></section></li></ul></section></li></ul><!--[--><!----><!--]--></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!--[--><!----><!--]--><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><!---->一、概述</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://yuejinzhao.cn" target="_blank" rel="noopener noreferrer">Honyelchak</a></span><span property="author" content="Honyelchak"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2023-12-02T06:45:03.000Z"></span><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 69 分钟</span><meta property="timeRequired" content="PT69M"></span><!----><!----></div><hr></div><div class="toc-place-holder"><aside id="toc"><!--[--><!----><!--]--><div class="toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button></div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#_1、redis单线程-vs-多线程">1、redis单线程 vs 多线程</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#_2、redis6-0如何开启多线程">2、redis6.0如何开启多线程</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#_1、string">1、STRING</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#_2、hash">2、HASH</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#_3、list">3、LIST</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#_4、set">4、SET</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#数据结构">数据结构</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#_5、zset">5、ZSET</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#_6、bitmap">6、bitmap</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#基本操作">基本操作</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#扩容机制">扩容机制</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#_7、hyperloglog">7、hyperloglog</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#基本操作-1">基本操作</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#应用场景">应用场景</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#_8、geo">8、GEO</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#基本原理">基本原理</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#基本操作-2">基本操作</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#sds">SDS</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#结构">结构</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#优势">优势</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#内部编码">内部编码</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#链表">链表</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#链表结构设计">链表结构设计</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#链表的优势与缺陷">链表的优势与缺陷</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#ziplist-用时间还换空间">ZipList(用时间还换空间)</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#结构-1">结构</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#整数集合-intset">整数集合(intset)</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#特点">特点</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#主要操作">主要操作</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#优缺点">优缺点</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#应用">应用</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#缓存雪崩">缓存雪崩</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#缓存穿透">缓存穿透</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#缓存击穿">缓存击穿</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#缓存预热">缓存预热</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#基本概念">基本概念</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#方案">方案</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#setnx-expire">setnx + expire</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#setnx-value为-系统时间-过期时间">setnx value为(系统时间 + 过期时间)</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#lua脚本-setnx-expire">Lua脚本(setnx + expire)</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#set的扩展命令-set-ex-px-nx">Set的扩展命令(SET EX PX NX)</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#set-nx-px-nx-校验唯一随机值-再删除">SET NX PX NX + 校验唯一随机值，再删除</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#redisson框架">Redisson框架</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#多机实现的分布式锁redlock-redisson">多机实现的分布式锁Redlock+Redisson</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#相关面试题">相关面试题</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#rdb-持久化">RDB 持久化</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#触发策略">触发策略</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#执行快照时-数据能被修改吗">执行快照时，数据能被修改吗？</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#aof-持久化">AOF 持久化</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#使用方法">使用方法</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#日志格式">日志格式</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#写回策略">写回策略</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#重写机制">重写机制</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#aof修复">AOF修复</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#总结">总结</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#rdb-和-aof-合体">RDB 和 AOF 合体</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#常用命令">常用命令</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#三个阶段">三个阶段</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#四种错误情况">四种错误情况</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#特性">特性</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#文件事件">文件事件</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#时间事件">时间事件</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#事件的调度与执行">事件的调度与执行</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#连接过程">连接过程</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#主从链">主从链</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#常用玩法">常用玩法</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#缺点">缺点</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#面试题">面试题</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#_1、为什么redis集群的最大槽位是16384个">1、为什么redis集群的最大槽位是16384个？</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#玩法">玩法</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#文章信息">文章信息</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#点赞功能">点赞功能</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#对文章进行排序">对文章进行排序</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#base">BASE</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#redis部分命令">Redis部分命令</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#查看redis版本信息">查看redis版本信息</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#数据库命令">数据库命令</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#string类型命令">String类型命令</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#list类型命令">List类型命令</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#docker容器部署redis">Docker容器部署Redis</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#_1、基本数据类型-你还知道其他redis的类型吗-你是怎么应用这几个数据类型的">1、基本数据类型，你还知道其他redis的类型吗？你是怎么应用这几个数据类型的？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#_2、bigkey、hotkey的定义">2、bigkey、hotkey的定义</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#bigkey">bigkey</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#hotkeys">hotkeys</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#_3、如何排查redis的bigkey、hotkey">3、如何排查Redis的bigkey、hotkey？</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#查找bigkey">查找bigkey</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#查找hotkey">查找HotKey</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#_4、如何解决bigkey以及hotkey问题">4、如何解决bigkey以及hotkey问题</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#bigkey-1">bigkey</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#hotkey">hotkey</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#_5、个人觉得redis中比较惊艳的地方">5、个人觉得Redis中比较惊艳的地方？</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#sds会默认会创建-0-10000的共享对象">SDS会默认会创建 0~10000的共享对象</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#_6、redis中的各个组成部分的关系">6、Redis中的各个组成部分的关系</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#_7、redis中是如何解决hash碰撞的-和hashmap有什么区别">7、Redis中是如何解决hash碰撞的？和HashMap有什么区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#_8、渐进式rehash">8、渐进式rehash</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#_9、innodb为什么选择使用b-树而不是跳表-redis为什么选择调表而不是b-树">9、Innodb为什么选择使用B+树而不是跳表，Redis为什么选择调表而不是B+树？</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#b-树和跳表相同之处">B+树和跳表相同之处</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#不同之处">不同之处</a></li><!----><!--]--></ul></li><!--]--></ul><div class="toc-marker" style="top:-1.7rem;"></div></div><!--[--><!----><!--]--></aside></div><!--[--><!----><!--]--><div class="theme-hope-content"><p><strong>NoSQL</strong>：not only SQL，意即“不仅仅是SQL”，泛指非关系型数据库。</p><p>这些类型的数据存储不需要固定的格式，无需多余操作就可以横向扩展。</p><hr><h1 id="一、概述" tabindex="-1"><a class="header-anchor" href="#一、概述" aria-hidden="true">#</a> 一、概述</h1><p>Redis(REmote DIctionary Server)是速度非常快的非关系型（NoSQL）内存键值数据库，可以存储键和五种不同类型的值之间的映射。</p><p>键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。</p><p>Redis 支持很多特性，例如将内存中的数据持久化到硬盘中，使用复制来扩展读性能，使用分片来扩展写性能。</p><p>**特点：**高性能分布式内存数据库</p><ul><li>支持数据的持久化，可以将内存中的数据保持在磁盘上，重启的时候可以再次加载进行使用</li><li>不仅仅支持简单的Key-value类型的数据，同时还提供list、set、zset、hash等数据结构的存储</li><li>支持数据的备份，即Master-slave模式的数据备份</li></ul><p>重点：KV、Cache、pesistence</p><h2 id="_1、redis单线程-vs-多线程" tabindex="-1"><a class="header-anchor" href="#_1、redis单线程-vs-多线程" aria-hidden="true">#</a> 1、redis单线程 vs 多线程</h2><p><strong>redis各个版本的真实情况：</strong></p><ol><li>3.x及以前的版本是单线程的，4.x为了解决大key删除问题，引入了多线程异步删除机制，但是负责处理客户端请求的线程仍然是单线程。</li><li>6.0之后，网络IO引入了多线程，有多个线程处理IO连接、解析命令，但是具体命令执行的工作线程还是由单线程来完成。</li></ol><p><strong>既然单线程这么好，为什么逐渐又加入了多线程特性？</strong></p><ol><li>单线程也有单线程的烦恼，例如redis3.x最经典的故障，大key删除问题。 <ol><li>大key指一个非常大的键值对，在删除他的时候会导致redis长时间阻塞。</li></ol></li></ol><p><strong>根据作者的原话：</strong></p><ol><li>redis的瓶颈通常不在CPU，而是在内存和网络。</li></ol><p><strong>Redis6为什么引入了多线程：</strong></p><ol><li><p>I/O 的读和写本身是堵塞的，比如当 socket 中有数据时，Redis 会通过调用先将数据从内核态空间拷贝到用户态空间，再交给 Redis 调用，而这个拷贝的过程就是阻塞的，当数据量越大时拷贝所需要的时间就越多，而这些操作都是基于单线程完成的。</p><figure><img src="/assets/image-20230419210931169-h1TwkWM-.png" alt="image-20230419210931169" tabindex="0" loading="lazy"><figcaption>image-20230419210931169</figcaption></figure></li><li><p>在 Redis 6.0 中新增了多线程的功能来提高 I/O 的读写性能，他的主要实现思路是将<strong>主线程的 IO 读写任务拆分给一组独立的线程去执行，这样就可以使多个 socket 的读写可以并行化了，采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗)，将最耗时的Socket的读取、请求解析、写入单独外包出去，剩下的命令执行仍然由主线程串行执行并和内存的数据交互。</strong></p><figure><img src="/assets/image-20230419211046322-20u18-qT.png" alt="image-20230419211046322" tabindex="0" loading="lazy"><figcaption>image-20230419211046322</figcaption></figure><figure><img src="/assets/964edb969c434e429693dba052d85216tplv-k3u1fbpfcp-zoom-in-crop-mark4536000-2JzFyvcM.webp" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure></li></ol><blockquote><p><strong>Redis的单线程指的是什么？</strong></p><p>主要是指Redis的网络IO和键值对读写是由一个线程来完成的，Redis在处理客户端的请求时包括获取 (socket 读)、解析、执行、内容返回 (socket 写) 等都由一个顺序串行的主线程处理，这就是所谓的“单线程”。这也是Redis对外提供键值存储服务的主要流程。</p><p>但Redis的其他功能，比如<code>持久化、异步删除、集群数据同步等等，其实是由额外的线程执行的。Redis工作线程是单线程的，但是，整个Redis来说，是多线程的；</code></p></blockquote><blockquote><p><strong>【作者原话】为什么Redis使用了单线程还可以这么快？</strong></p><p>Redis 的 CPU 瓶颈并不是很常见，因为 Redis 通常受限于内存或网络。例如，运行在一台普通 Linux 系统上的 Redis 使用管道可以实现每秒 100 万请求，所以如果您的应用主要使用 O(N) 或 O(log(N)) 命令，它几乎不会消耗太多 CPU。然而，要最大化 CPU 使用率，您可以在同一台计算机上启动多个 Redis 实例并将它们视为不同的服务器。在某些时候，单个计算机可能无法满足需求，因此，如果您想使用多个 CPU，您可以提前考虑一些分片方法。</p><p>您可以在分区页面中找到有关使用多个 Redis 实例的更多信息。</p><p>然而，从 Redis 4.0 开始，我们逐渐让 Redis 更多地使用线程。目前，这仅限于在后台删除对象以及通过 Redis 模块实现的阻塞性命令。对于未来的版本，计划是让 Redis 使用越来越多的线程。</p></blockquote><h2 id="_2、redis6-0如何开启多线程" tabindex="-1"><a class="header-anchor" href="#_2、redis6-0如何开启多线程" aria-hidden="true">#</a> 2、redis6.0如何开启多线程</h2><p>在Redis6.0中，多线程机制默认是关闭的，如果需要使用多线程功能，需要在redis.conf中完成两个设置</p><ol><li><p>设置io-thread-do-reads配置项为yes，表示启动多线程。</p></li><li><p>设置线程个数。关于线程数的设置，官方的建议是如果为 4 核的 CPU，建议线程数设置为 2 或 3，如果为 8 核 CPU 建议线程数设置为 6，线程数一定要小于机器核数，线程数并不是越大越好。</p></li></ol><figure><img src="/assets/image-20230419211148107-rj5wlC4P.png" alt="image-20230419211148107" tabindex="0" loading="lazy"><figcaption>image-20230419211148107</figcaption></figure><h1 id="二、数据类型" tabindex="-1"><a class="header-anchor" href="#二、数据类型" aria-hidden="true">#</a> 二、数据类型</h1><table><thead><tr><th>数据类型</th><th>可以存储的值</th><th>底层数据结构</th><th>操作</th><th>场景</th></tr></thead><tbody><tr><td>STRING</td><td>字符串、整数、浮点数</td><td></td><td>对整个字符串或者字符串的其中一部分执行操作、对整数和浮点数执行自增或者自减操作</td><td>简单的缓存、点赞、计数器</td></tr><tr><td>HASH</td><td>包含键值对的无序散列表</td><td></td><td>添加、获取、移除单个键值对 获取所有键值对 检查某个键是否存在</td><td>购物车、Java中的对象</td></tr><tr><td>LIST</td><td>列表</td><td></td><td>从两端压入或者弹出元素 对单个或者多个元素进行修剪， 只保留一个范围内的元素.底层是<strong>链表</strong></td><td>微信公众号订阅的消息、商品评论列表</td></tr><tr><td>SET</td><td>无序集合</td><td></td><td>添加、获取、移除单个元素 检查一个元素是否存在于集合中 计算交集、并集、差集 从集合里面随机获取元素</td><td>抽奖小程序、朋友圈点赞、共同关注的人、QQ可能认识的人</td></tr><tr><td>ZSET</td><td>有序集合</td><td></td><td>添加、获取、删除元素 根据分值范围或者成员来获取元素 计算一个键的排名。</td><td>排行榜、抖音热搜、商品热门榜</td></tr><tr><td>bitmap</td><td>0、1组成的bit数组</td><td>String</td><td></td><td>连续签到统计、最近一周的活跃用户、统计某个用户一年的登陆天数</td></tr><tr><td>hyperloglog</td><td></td><td></td><td></td><td></td></tr><tr><td>GEO</td><td></td><td></td><td></td><td></td></tr><tr><td>Stream</td><td></td><td></td><td></td><td></td></tr></tbody></table><p><strong>注意：</strong> 命令不区分大小写，而key区分大小写。</p><h2 id="_1、string" tabindex="-1"><a class="header-anchor" href="#_1、string" aria-hidden="true">#</a> 1、STRING</h2><p>单个key的设置/获取</p><ul><li><code>set key value</code></li><li><code>get key</code></li></ul><p>多个key的设置/获取</p><ul><li><code>mset k1 v1 k2 v2 [k v..]</code></li><li><code>mget k1 [k ...]</code></li></ul><p>数值增减</p><ul><li><code>incr key</code></li><li><code>incrby key increment</code></li><li><code>decr key</code></li><li><code>decrby key descrement</code></li></ul><p>字符串的长度</p><ul><li><code>strlen key</code></li></ul><p>分布式锁</p><ul><li><code>setnx key value</code></li><li><code>set key value</code></li></ul><h2 id="_2、hash" tabindex="-1"><a class="header-anchor" href="#_2、hash" aria-hidden="true">#</a> 2、HASH</h2><p>可以理解为Java中的<code>Map&lt;String, Map&lt;Object, Object&gt;&gt;</code></p><p>单个字段值的设置/获取</p><ul><li><code>hset key field value</code></li><li><code>hget key field</code></li></ul><p>多个字段值的设置/获取</p><ul><li><code>hmset key f1 v1 f2 v2 ...</code></li><li><code>hmget key f1 f2 f3 f4</code></li></ul><p>获取所有字段的值</p><ul><li><code>hgetall key</code></li></ul><p>获取某个key内的全部数量</p><ul><li><code>hlen key</code></li></ul><p>删除一个key</p><ul><li><code>hdel key</code></li></ul><h2 id="_3、list" tabindex="-1"><a class="header-anchor" href="#_3、list" aria-hidden="true">#</a> 3、LIST</h2><p>向列表左/右边添加元素</p><ul><li><code>lpush key value [value ...]</code></li><li><code>rpush key value [value ...]</code></li></ul><p>查看列表<code>[start, end]</code>, start和end都是从0开始的</p><ul><li><code>lrange key start end</code></li></ul><p>获取列表中元素的个数</p><ul><li><code>llen key</code></li></ul><h2 id="_4、set" tabindex="-1"><a class="header-anchor" href="#_4、set" aria-hidden="true">#</a> 4、SET</h2><p>基本操作：</p><ul><li>添加元素：<code>sadd key v1 v2 ...</code></li><li>删除元素：<code>srem key v1 v2 ...</code></li><li>获取集合中的所有元素：<code>smembers key</code></li><li>判断元素是否在集合中：<code>sismember key v1</code></li><li>获取集合中的元素总数：<code>scard key</code></li></ul><p>弹出元素：</p><ul><li>从集合中随机弹出N个元素，不删除：<code>srandmember key N</code><ul><li>不加参数N，默认只弹出一个</li></ul></li><li>从集合中随机弹出N个元素，要删除：<code>spop key N</code><ul><li>不加参数N，默认只弹出一个</li></ul></li></ul><p>集合运算：</p><ul><li>集合的差集：<code>sdiff k1 k2 k3....</code><ul><li>属于k1,但是不属于k2、k3....的元素</li></ul></li><li>集合的交集：<code>sinter k1 k2 k3...</code><ul><li>k1、k2、k3....共有的元素</li></ul></li><li>集合的并集：<code>sunion k1 k2 k3</code><ul><li>k1、k2、k3....合并的元素</li></ul></li></ul><h3 id="数据结构" tabindex="-1"><a class="header-anchor" href="#数据结构" aria-hidden="true">#</a> 数据结构</h3><ol><li>intset整数数组(当set中全是整数，并且元素个数小于512)</li><li>ziplist压缩</li></ol><h2 id="_5、zset" tabindex="-1"><a class="header-anchor" href="#_5、zset" aria-hidden="true">#</a> 5、ZSET</h2><ul><li>添加元素：<code>ZADD key score member [score member ...]</code></li><li>返回[start,end]元素：<code>ZRANGE key start end [WITHSCORES]</code><ul><li>按照元素分数从小到大的顺序，返回索引从start到stop之间的所有元素</li></ul></li><li>删除元素：<code>ZREM key member [member ...]</code></li><li>获取元素的分数: <code>ZSCORE key member</code></li><li>获取指定分数范围的元素：<code>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</code></li><li>增加某个元素的分数：<code>zincrby key increment member</code></li><li>获取集合中元素的数量：<code>ZCARD key</code></li><li>获得指定分数范围内的元素个数：<code>ZCOUNT key min max</code></li><li>按照排名范围删除元素：<code>ZREMRANGEBYRANK key start stop</code></li><li>获取元素排名： <ul><li>从小到大：<code>ZRANK key member</code></li><li>从大到小：<code>ZREVRANK key member</code></li></ul></li></ul><hr><h2 id="_6、bitmap" tabindex="-1"><a class="header-anchor" href="#_6、bitmap" aria-hidden="true">#</a> 6、bitmap</h2><p>用String类型作为底层数据结构实现的一种统计二值状态的数据类型。</p><ul><li><p>位图本质是数组，它是基于String数据类型的按位的操作。该数组由多个二进制位组成，每个二进制位都对应一个偏移量(我们可以称之为一个索引或者位格)。</p></li><li><p>Bitmap支持的最大位数是2<sup>32位，它可以极大的节约存储空间，使用512M内存就可以存储多大42.9亿的字节信息(2</sup>32 = 4294967296)</p><ul><li>512MB = 2^32 / 8 / 1024 / 1024</li></ul></li></ul><h3 id="基本操作" tabindex="-1"><a class="header-anchor" href="#基本操作" aria-hidden="true">#</a> 基本操作</h3><ul><li><code>setbit key offset value</code><ul><li>value只能是0/1</li><li>offset偏移量也是从0开始计算的</li></ul></li><li><code>getbit key offset</code></li><li>统计用了多少字节：<code>strlen key</code></li><li>统计有多少位是1：<code>bitcount key</code></li><li>位操作：<code>bitop</code><ul><li>统计连续两天都登录的用户，可以用<code>bitop and resKey day1 day2</code></li></ul></li></ul><h3 id="扩容机制" tabindex="-1"><a class="header-anchor" href="#扩容机制" aria-hidden="true">#</a> 扩容机制</h3><p>Bitmap的扩容操作是通过<code>bitmapSetbit()</code>函数来实现的。在这个函数中，如果设置的偏移量超出了当前Bitmap的大小，就会调用<code>stringEditLength()</code>函数来进行Bitmap的扩容操作。</p><p>在stringEditLength()函数中，首先会计算出扩容后的新大小，具体代码如下：</p><ul><li><p><code>newlen = curlen+(incr &amp;&amp; ~(size_t)511)+BITMAP_INIT_SIZE;</code></p></li><li><p>其中，curlen为当前字符串的长度，incr为要扩容的长度。这里的计算方式是将要扩容的长度向上舍入到512的倍数，并且在此基础上再加上BITMAP_INIT_SIZE（BITMAP_INIT_SIZE为Redis中定义的一个常量，表示Bitmap在初始化时的默认大小）。</p></li></ul><p>计算出新的大小后，stringEditLength()函数会调用sdsgrowzero()函数来进行字符串的扩容，并将扩容后的空间全部设置为0。</p><p>因此，可以看出Redis的Bitmap扩容策略是将要扩容的长度向上舍入到512的倍数，并且在此基础上再加上一个常量。这个常量是为了避免频繁进行扩容操作，以提高性能。</p><h2 id="_7、hyperloglog" tabindex="-1"><a class="header-anchor" href="#_7、hyperloglog" aria-hidden="true">#</a> 7、hyperloglog</h2><blockquote><p>没有hyperloglog，我可能想到用set、bitmap来进行基数统计：</p><p>使用bitmap进行一些统计工作，尽管比较精确，但是在数据量大的情况，内存消耗过大。并且对于亿级数据的统计页不合适。</p></blockquote><p>是一种具有去重复统计功能的基数估计算法, 能够提供不精确的去重计数。</p><p>有几个特点：</p><ol><li>首先hyperloglog是一种概率算法，她并不存储数据本身，只是通过一定的概率统计方法预估基数值，同时保证误差在一定范围内。</li><li>hyperloglog通过牺牲准确率来换取存储空间，在不要求绝对准确率的场景下可以使用。</li><li>hyperloglog的基本原理：通过一个hash函数将数据流映射到<code>01</code>序列，之后通过二进制中 1 出现的第一个位置来估算整体的数量。 <ol><li>首先把这批元素通过 hash 函数处理成 0,1 序列，然后把这批 0,1 序列都放入 1 个桶，然后通过计算这个桶里面所有 0,1 序列中第一次出现1的位置的最大值，就可以预估出整体的数量。</li><li>但是如果只有一个桶的话，那误差会非常大，</li></ol></li><li>redis中的hyperloglog在实现的时候，有一个<code>16384</code>(2^14)的桶，每个桶有6位，每个桶可以表达的最大数字是63。</li></ol><ul><li>只是进行不重复的基数统计，不是集合也不保存数据，只记录数量而不是具体内容。</li><li>具体的原理是：利用</li><li>http://content.research.neustar.biz/blog/hll.html 原理的演示地址。</li></ul><h3 id="基本操作-1" tabindex="-1"><a class="header-anchor" href="#基本操作-1" aria-hidden="true">#</a> 基本操作</h3><ul><li><p>将元素添加到key中：<code>pfadd key e1 e2 e3</code></p><ul><li>在存入的时候，e1 e2 e3会被hash成64位，即64bit的比特字符串，前14位用来分桶，前14位二进制-》十进制就是桶标号</li></ul></li><li><p>(估算)统计key中元素的个数：<code>pfcount key</code></p></li><li><p>合并key到新key：<code>pfmerge new_key k1 k2</code></p></li></ul><h3 id="应用场景" tabindex="-1"><a class="header-anchor" href="#应用场景" aria-hidden="true">#</a> 应用场景</h3><ol><li>统计某个网站的UV、统计某篇文章的PV</li><li>用户搜索网站关键词的数量</li><li>统计用户每天搜索不同词条个数</li></ol><h2 id="_8、geo" tabindex="-1"><a class="header-anchor" href="#_8、geo" aria-hidden="true">#</a> 8、GEO</h2><h3 id="基本原理" tabindex="-1"><a class="header-anchor" href="#基本原理" aria-hidden="true">#</a> 基本原理</h3><p>利用GEOhash算法将经纬度坐标转化为二进制编码，底层利用了zset进行存储。</p><h4 id="geohash算法" tabindex="-1"><a class="header-anchor" href="#geohash算法" aria-hidden="true">#</a> GEOHash算法</h4><ol><li><p>编码的过程(redis中默认geohash编码的长度是11，基本上误差在0.5之内)</p><ol><li>首先经度是[-180, 180]，纬度是[-90, 90]。比如我们的经纬度[112.xxx, 30.xxx]</li><li>拿经度来举例子，每次都先将经度分为左右两个区间，左区间[-180, 0],右区间[0, 180]，如果当前位置在左半边，那么就记为0, 否则记为1。</li><li>对于经度，经过不断地二分，不断地缩小区间，我们能够得到一个二进制编码。同理，也可以得到一个纬度的二进制编码</li><li>组码：最后将上一步得到的两个二进制编码进行组合，偶数位放经度，奇数位放纬度，形成一个新的二进制编码。</li><li>通过base32编码将组合成的二进制编码转化位字符串。</li></ol><figure><img src="/assets/672e9867ddf7426f87a3babd7bb073adtplv-k3u1fbpfcp-zoom-in-crop-mark4536000-xPeWl_J1.webp" alt="在这里插入图片描述" tabindex="0" loading="lazy"><figcaption>在这里插入图片描述</figcaption></figure></li></ol><h4 id="redis中的geohash" tabindex="-1"><a class="header-anchor" href="#redis中的geohash" aria-hidden="true">#</a> Redis中的GEOHash</h4><ol><li><p>redis的GEO和标准的GEOHash算法还不一样，它经过二分编码-》组码之后形成52位二进制，再通过base32编码(每5位编码一次，不够补0)为11位的字符串。</p></li><li><p><strong>从图中可知此时误差不超过0.0001492km，即0.1492m，由于GepHash的长度没有达到55位，因此精度会低一些，但是不会超过0.5971m（为了性能考虑）</strong></p></li><li><p>调用<code>GEOADD</code>,会将每一个点都进行geohash，最后调用zset的命令去存储[GEOHASH编码, 地点]，例如：<code>zadd key GEOHASH编码 地点名称</code></p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">// 遍历所有点</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> elements<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">double</span> xy<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">extractLongLatOrReply</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>argv<span class="token operator">+</span>longidx<span class="token punctuation">)</span><span class="token operator">+</span><span class="token punctuation">(</span>i<span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>xy<span class="token punctuation">)</span> <span class="token operator">==</span> C_ERR<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> argc<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">decrRefCount</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">zfree</span><span class="token punctuation">(</span>argv<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/* Turn the coordinates into the score of the element. */</span>
    GeoHashBits hash<span class="token punctuation">;</span>
    <span class="token function">geohashEncodeWGS84</span><span class="token punctuation">(</span>xy<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> xy<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> GEO_STEP_MAX<span class="token punctuation">,</span> <span class="token operator">&amp;</span>hash<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 得到hash编码</span>
    GeoHashFix52Bits bits <span class="token operator">=</span> <span class="token function">geohashAlign52Bits</span><span class="token punctuation">(</span>hash<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// score 就是hash编码字符串</span>
    robj <span class="token operator">*</span>score <span class="token operator">=</span> <span class="token function">createObject</span><span class="token punctuation">(</span>OBJ_STRING<span class="token punctuation">,</span> <span class="token function">sdsfromlonglong</span><span class="token punctuation">(</span>bits<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// val 就是 该地点的名称</span>
    robj <span class="token operator">*</span>val <span class="token operator">=</span> c<span class="token operator">-&gt;</span>argv<span class="token punctuation">[</span>longidx <span class="token operator">+</span> i <span class="token operator">*</span> <span class="token number">3</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    argv<span class="token punctuation">[</span>longidx<span class="token operator">+</span>i<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> score<span class="token punctuation">;</span>
    argv<span class="token punctuation">[</span>longidx<span class="token operator">+</span><span class="token number">1</span><span class="token operator">+</span>i<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> val<span class="token punctuation">;</span>
    <span class="token function">incrRefCount</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><h3 id="基本操作-2" tabindex="-1"><a class="header-anchor" href="#基本操作-2" aria-hidden="true">#</a> 基本操作</h3><ol><li>向key中添加多个经纬度：<code>geoadd key lon lat name [lon lat name...]</code></li><li>返回该key里给定名称的经纬度：<code>geopos key name [name...]</code>&#39;</li><li>返回坐标的geohash表示：<code>geohash key name [name...]</code><ol><li>由geohash算法生成的base32编码值</li></ol></li><li>计算两点之间的距离：<code>geodist key n1 n2 m[m | km | ft英尺 | mi英里]</code></li><li>计算以该点为中心，且半径为radiu的类似于圆的范围内所有的位置元素：<code>georadius key lon lat radius km [withdist | withcoord | count 10 | withhash | desc]</code><ol><li>WITHDIST: 在返回位置元素的同时， 将位置元素与中心之间的距离也一并返回。距离的单位和用户给定的范围单位保持一致。</li><li>WITHCOORD: 将位置元素的经度和维度也一并返回。</li><li>WITHHASH: 以 52 位有符号整数的形式， 返回位置元素经过原始 geohash 编码的有序集合分值。这个选项主要用于底层应用或者调试，实际中的作用并不大</li><li>COUNT：限定返回的记录数。</li></ol></li><li>找出位于指定范围内的元素，中心点是给定的位置元素决定：<code>georadiusbymember key name1 radius km [withdist | withcoord | count 10 | withhash | desc]</code></li></ol><h1 id="补充-数据结构" tabindex="-1"><a class="header-anchor" href="#补充-数据结构" aria-hidden="true">#</a> 补充：数据结构</h1><h2 id="sds" tabindex="-1"><a class="header-anchor" href="#sds" aria-hidden="true">#</a> SDS</h2><h3 id="结构" tabindex="-1"><a class="header-anchor" href="#结构" aria-hidden="true">#</a> 结构</h3><figure><img src="/assets/image-20230909160555631-P1JauMso.png" alt="image-20230909160555631" tabindex="0" loading="lazy"><figcaption>image-20230909160555631</figcaption></figure><p>结构中的每个成员变量分别介绍下：</p><ul><li><strong>len，记录了字符串长度</strong>。这样获取字符串长度的时候，只需要返回这个成员变量值就行，时间复杂度只需要 O（1）。</li><li><strong>alloc，分配给字符数组的空间长度</strong>。这样在修改字符串的时候，可以通过 <code>alloc - len</code> 计算出剩余的空间大小，可以用来判断空间是否满足修改需求，如果不满足的话，就会自动将 SDS 的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用 SDS 既不需要手动修改 SDS 的空间大小，也不会出现前面所说的缓冲区溢出的问题。</li><li><strong>flags，用来表示不同类型的 SDS</strong>。一共设计了 5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64，后面在说明区别之处。</li><li><strong>buf[]，字符数组，用来保存实际数据</strong>。不仅可以保存字符串，也可以保存二进制数据。</li></ul><blockquote><p>Redis 的 SDS 结构里引入了 alloc 和 len 成员变量，这样 SDS API 通过 <code>alloc - len</code> 计算，可以算出剩余可用的空间大小，这样在对字符串做修改操作的时候，就可以由程序内部判断缓冲区大小是否足够用。</p></blockquote><h3 id="优势" tabindex="-1"><a class="header-anchor" href="#优势" aria-hidden="true">#</a> 优势</h3><ul><li>获取字符串长度的时间复杂度是<code>O(1)</code></li><li>不仅可以保存文本数据，还可以保存二进制数据。(这是因为C语言底层字符串使用了<code>\0</code>来判断是否为字符串的结尾)</li><li>SDS API是安全的，拼接字符串不会造成缓冲区溢出。(C语言中<code>strcat</code>函数在执行的时候默认程序员已经分配好了内存，有缓冲区溢出的风险，有可能会造成程序运行终止；)</li><li>比原来的更加节省空间，利用<code>flags</code>区分不同类型的结构体，灵活保存不同大小的字符串，从而更有效的节省内存 ，并且在编程上还<strong>使用了专门的编译优化来节省内存空间</strong>，即在 struct 声明了 <code>__attribute__ ((packed))</code> ，它的作用是：<strong>告诉编译器取消结构体在编译过程中的优化对齐，按照实际占用字节数进行对齐</strong>。</li></ul><h3 id="内部编码" tabindex="-1"><a class="header-anchor" href="#内部编码" aria-hidden="true">#</a> 内部编码</h3><ul><li><p>int：8个字节</p><ul><li>如果大于8个字节或者为数字等</li></ul></li><li><p>embstr：会通过一次内存分配函数来分配一块连续的内存空间来保存redisObject和SDS</p><blockquote><ul><li>优势： <ul><li><code>embstr</code>编码将创建字符串对象所需的内存分配次数从 <code>raw</code> 编码的两次降低为一次；</li><li>释放 <code>embstr</code>编码的字符串对象同样只需要调用一次内存释放函数；</li><li>因为<code>embstr</code>编码的字符串对象的所有数据都保存在一块连续的内存里面可以更好的利用 CPU 缓存提升性能。</li></ul></li><li>缺点： <ul><li>只读，如果需要修改数据的话，就会先将内部编码从embstr变为raw</li></ul></li></ul></blockquote></li><li><p>raw：会通过调用两次内存分配函数来分别分配两块空间来保存redisObject和SDS</p></li><li><p>Redis 内部其实先将浮点数转化为字符串值，然后再保存。</p></li></ul><p>那这两者的区别见下图： <img src="/assets/image-20230906143730725-nT0UKB9Q.png" alt="image-20230906143730725" loading="lazy"></p><figure><img src="/assets/image-20230906143657469-uEsqrRK1.png" alt="image-20230906143657469" tabindex="0" loading="lazy"><figcaption>image-20230906143657469</figcaption></figure><h2 id="链表" tabindex="-1"><a class="header-anchor" href="#链表" aria-hidden="true">#</a> 链表</h2><h3 id="链表结构设计" tabindex="-1"><a class="header-anchor" href="#链表结构设计" aria-hidden="true">#</a> 链表结构设计</h3><div class="language-C line-numbers-mode" data-ext="C"><pre class="language-C"><code>typedef struct listNode {
    //前置节点
    struct listNode *prev;
    //后置节点
    struct listNode *next;
    //节点的值
    void *value;
} listNode;

typedef struct list {
    //链表头节点
    listNode *head;
    //链表尾节点
    listNode *tail;
    //节点值复制函数
    void *(*dup)(void *ptr);
    //节点值释放函数
    void (*free)(void *ptr);
    //节点值比较函数
    int (*match)(void *ptr, void *key);
    //链表节点数量
    unsigned long len;
} list;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>list 结构为链表提供了链表头指针 head、链表尾节点 tail、链表节点数量 len、以及可以自定义实现的 dup、free、match 函数。</p><p>举个例子，下面是由 list 结构和 3 个 listNode 结构组成的链表。</p><figure><img src="/assets/cadf797496816eb343a19c2451437f1e-2O_rG_Kx.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="链表的优势与缺陷" tabindex="-1"><a class="header-anchor" href="#链表的优势与缺陷" aria-hidden="true">#</a> 链表的优势与缺陷</h3><h4 id="优势-1" tabindex="-1"><a class="header-anchor" href="#优势-1" aria-hidden="true">#</a> 优势</h4><ol><li><code>listNode</code>链表节点的结构里有<code>pre</code>和<code>next</code>指针，获取某个节点的前置节点或后置节点的时间复杂度只需要<code>O(1)</code></li><li>list包含了头尾指针，<strong>获取链表的表头节点和表尾节点的时间复杂度只需O(1)</strong></li><li>list 结构因为提供了链表节点数量 len，所以<strong>获取链表中的节点数量的时间复杂度只需O(1)</strong></li><li>listNode 链表节使用 void* 指针保存节点值，并且可以通过 list 结构的 dup、free、match 函数指针为节点设置该节点类型特定的函数，因此<strong>链表节点可以保存各种不同类型的值</strong></li></ol><h4 id="缺陷" tabindex="-1"><a class="header-anchor" href="#缺陷" aria-hidden="true">#</a> 缺陷</h4><ol><li>链表中的每个节点之前的内存都是不连续的，无法很好利用CPU缓存</li><li>保存一个链表节点的值都需要一个链表结构头的分配，内存开销较大</li></ol><h2 id="ziplist-用时间还换空间" tabindex="-1"><a class="header-anchor" href="#ziplist-用时间还换空间" aria-hidden="true">#</a> ZipList(用时间还换空间)</h2><p>它是<strong>由连续内存块组成的顺序型xx数据结构</strong>，总体思想是用时间来换空间。</p><p>只适合<code>字段个数少，且字段值也比较小</code>的场景。</p><h3 id="结构-1" tabindex="-1"><a class="header-anchor" href="#结构-1" aria-hidden="true">#</a> 结构</h3><p>ziplist是一个经过特殊编码的双向链表，它不存储指向上一个链表节点和指向下一个链表节点的指针，而是存储<code>上一个节点长度和当前节点长度</code></p><figure><img src="/assets/image-20230909200656971-oYScT7Ls.png" alt="image-20230909200656971" tabindex="0" loading="lazy"><figcaption>image-20230909200656971</figcaption></figure><p>压缩列表在表头有三个字段：</p><ul><li><em><strong>zlbytes</strong></em>，记录整个压缩列表占用对内存字节数；</li><li><em><strong>zltail</strong></em>，记录压缩列表「尾部」节点距离起始地址由多少字节，也就是列表尾的偏移量；</li><li><em><strong>zllen</strong></em>，记录压缩列表包含的节点数量；</li><li><em><strong>zlend</strong></em>，标记压缩列表的结束点，固定值 0xFF（十进制255）。</li></ul><h2 id="整数集合-intset" tabindex="-1"><a class="header-anchor" href="#整数集合-intset" aria-hidden="true">#</a> 整数集合(intset)</h2><hr><h1 id="三、布隆过滤器" tabindex="-1"><a class="header-anchor" href="#三、布隆过滤器" aria-hidden="true">#</a> 三、布隆过滤器</h1><p>它是由一个二进制数组和一系列hash算法组成的，主要是用于判断一个元素是否在集合中。</p><h2 id="特点" tabindex="-1"><a class="header-anchor" href="#特点" aria-hidden="true">#</a> 特点</h2><ul><li>能够高效的插入和查询，占用空间少，返回的结果是不确定性的。</li><li>对于一个元素来说，利用该算法如果判断存在，那他可能存在。但是如果判断不存在，<strong>那么它一定不存在</strong>。 <ul><li>这是因为映射函数本身就是散列函数，散列函数是会有碰撞的。</li></ul></li><li>bloomfilter可以添加元素，但是不能删除元素。删除元素会导致误判率增加。</li><li>误判只会发生在过滤器没有添加过的元素，对于添加过的元素不会发生误判。</li></ul><h2 id="主要操作" tabindex="-1"><a class="header-anchor" href="#主要操作" aria-hidden="true">#</a> 主要操作</h2><ul><li><p>添加key</p><ul><li>使用多个hash函数对同一个key进行hash运算。每个hash函数都会得到一个整数索引值，对位数组长度去摸之后得到一个位置。使用多个hash函数得到多个位置，将这几个位置都置为1就完成了添加操作。</li></ul></li><li><p>查询key</p><ul><li>利用刚才的hash函数得到多个位置，并查看这些位置是否都为1，若有一位是0，那么该key一定不存在。若全都是1，则不一定存在对应的key。</li></ul></li></ul><h2 id="优缺点" tabindex="-1"><a class="header-anchor" href="#优缺点" aria-hidden="true">#</a> 优缺点</h2><p>优点</p><ul><li>高效的插入和查询，占用空间少。</li></ul><p>缺点</p><ul><li>不能删除元素。因为删除元素会导致误判率增加，因为hash冲突导致同一个位置可能被多次置为1。若删除key，即将该位置位0，那么可能会删掉与他共享同一个位置的其他的key。</li><li>存在误判，不同的数据可能出现相同的hash值。</li></ul><p>**Ps：**布谷鸟过滤器能够解决不能删除的问题。</p><h2 id="应用" tabindex="-1"><a class="header-anchor" href="#应用" aria-hidden="true">#</a> 应用</h2><p>正是基于布隆过滤器的快速检测特性，我们可以用布隆过滤器来解决缓存穿透和黑名单问题，判断数据是否存在。</p><h1 id="四、缓存雪崩、缓存穿透、缓存击穿、缓存预热" tabindex="-1"><a class="header-anchor" href="#四、缓存雪崩、缓存穿透、缓存击穿、缓存预热" aria-hidden="true">#</a> 四、缓存雪崩、缓存穿透、缓存击穿、缓存预热</h1><h2 id="缓存雪崩" tabindex="-1"><a class="header-anchor" href="#缓存雪崩" aria-hidden="true">#</a> 缓存雪崩</h2><p><strong>原因：</strong></p><ol><li>redis主机挂掉</li><li>大量key同时过期</li></ol><p><strong>解决：</strong></p><ol><li>redis缓存集群实现高可用 <ol><li>主从 + 哨兵</li><li>Redis Cluster</li></ol></li><li>ehcache本地缓存 + hystrix或者阿里sentinel限流&amp;降级</li><li>开启redis持久化机制aof/rdb，尽快恢复缓存集群。</li><li>缓存设置随机过期时间，避免同时过期</li></ol><h2 id="缓存穿透" tabindex="-1"><a class="header-anchor" href="#缓存穿透" aria-hidden="true">#</a> 缓存穿透</h2><p><strong>原因：</strong></p><p>请求去查询一条记录，先redis后mysql发现都查询不到该条记录，但是请求每次都会打到数据库上面去，导致后台数据库压力暴增，这种现象我们称为缓存穿透，这个redis变成了一个摆设。</p><p><strong>解决：</strong></p><ol><li><code>缓存空对象或缺省值</code></li><li><code>Google布隆过滤器Guava解决缓存穿透</code><ol><li>缺点是<strong>只能单机使用</strong></li></ol></li><li><code>Redis布隆过滤器解决缓存穿透问题</code><ol><li>bf.reserve key error_rate的值 initial_size 的值 <ol><li>默认的error_rate是 0.01， 默认的initial_size是 100。</li></ol></li><li>bf.add key 值</li><li>bf.exists key 值</li><li>bf.madd 一次添加多个元素</li><li>bf.mexists 一次查询多个元素是否存在</li></ol></li></ol><h2 id="缓存击穿" tabindex="-1"><a class="header-anchor" href="#缓存击穿" aria-hidden="true">#</a> 缓存击穿</h2><p><strong>原因：</strong></p><p>某个热点key在某一时刻恰好失效，然后此时刚好有大量的并发请求，导致大量的请求都打到数据库上了。</p><p><strong>危害：</strong></p><p>会造成某一时刻数据库请求量过大，压力剧增。</p><p><strong>解决：</strong></p><ol><li><code>对于访问频繁的热点key，不设置过期时间</code></li><li><code>互斥更新</code>，多个线程同时去查询数据库的这条数据，那么我们可以在第一个查询数据的请求上使用一个互斥锁来锁住它。来发现已经有缓存了，就直接走缓存。</li><li><code>使用随机退避方式</code>，失效时随机 sleep 一个很短的时间，再次查询，如果失败再执行更新</li></ol><h2 id="缓存预热" tabindex="-1"><a class="header-anchor" href="#缓存预热" aria-hidden="true">#</a> 缓存预热</h2><p>简单来说，就是在访问高峰期前，将热点数据提前加载到缓存中。 假设您的网站有一个热门页面，每天有很多用户访问。为了提高用户体验，您可以在高峰期前预热缓存，提前将热门页面的数据加载到缓存中。这样，在高峰期时，用户可以从缓存中快速获取数据，而不用等待缓慢的数据库查询，从而提高网站的响应速度和用户满意度。</p><h1 id="五、分布式锁" tabindex="-1"><a class="header-anchor" href="#五、分布式锁" aria-hidden="true">#</a> 五、分布式锁</h1><h2 id="基本概念" tabindex="-1"><a class="header-anchor" href="#基本概念" aria-hidden="true">#</a> 基本概念</h2><p>**锁的种类：**单机锁(Synchronized、Lock接口的锁)、分布式锁</p><p><strong>分布式锁应具备的条件：</strong></p><ol><li>独占性：任何时刻有且仅有一个线程持有该资源</li><li>高可用：若redis集群环境下，不能因为某一个节点挂了而出现获取锁和释放锁失败的情况</li><li>防死锁(超时释放)：杜绝思索，必须有超时控制机制或撤销操作，有个兜底终止跳出方案</li><li>安全性：防止张冠李戴，不能私下lock别人的锁，只能自己加锁，自己释放。</li><li>重入性：同一个节点的同一个线程如果获得锁之后，它也可以再次获取这个锁。</li></ol><h2 id="方案" tabindex="-1"><a class="header-anchor" href="#方案" aria-hidden="true">#</a> 方案</h2><p>总结来说，分布式锁的演化过程是这样的：</p><ol><li>单机版的redis <ol><li>只有<code>setnx</code> 和<code>delete</code>，不加过期时间，一定情况下会导致死锁。</li><li><code>setnx</code> + <code>expires</code> 和<code>delete</code>，setnx和expires两条指令的执行不具有原子性，<strong>那就是如果在客户端加锁成功后，还没有设置过期时间时宕机，就会出现死锁</strong></li><li><code>set key value nx ..</code> 和<code>delete</code>，业务执行较慢，还没执行到删除，锁就过期了，该删除的时候发现锁已经被别人拿到了，此时就会导致把别人的锁释放掉。</li><li><code>set key value nx ..</code> 和<code>delete(校验是否为自己的锁)</code>，校验是否为自己的锁与delete两个动作的执行不具有原子性，导致可能把别人的锁删掉。 <ol><li>判断到redis中的锁是自己之后，突然CPU资源分配给其他任务了，CPU回到当前任务的时候锁刚好到期释放了，这个时候删除，可能会删除掉别人拿到的锁。</li></ol></li><li><code>set key value nx ..</code> 和<code>delete(校验是否为自己的锁)(lua脚本)</code>，使用lua脚本来保证删除和校验操作的原子性。</li></ol></li><li>分布式的redis</li></ol><h3 id="setnx-expire" tabindex="-1"><a class="header-anchor" href="#setnx-expire" aria-hidden="true">#</a> setnx + expire</h3><p>即先用<code>setnx</code>来抢锁，如果抢到之后，再用<code>expire</code>给锁设置一个过期时间，防止锁忘记了释放。</p><blockquote><p>setnx是set if not exits的简写，日常命令格式是<code>setnx key value</code>，如果key不存在，则setnx成功返回1，否则返回0.</p></blockquote><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">if</span>（jedis<span class="token punctuation">.</span><span class="token function">setnx</span><span class="token punctuation">(</span>key_resource_id<span class="token punctuation">,</span>lock_value<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span>）<span class="token punctuation">{</span> <span class="token comment">//加锁</span>
    expire（key_resource_id，<span class="token number">100</span>）<span class="token punctuation">;</span> <span class="token comment">//设置过期时间</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">do</span> something  <span class="token comment">//业务请求</span>
    <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
　　<span class="token punctuation">}</span>
　　<span class="token keyword">finally</span> <span class="token punctuation">{</span>
       jedis<span class="token punctuation">.</span><span class="token function">del</span><span class="token punctuation">(</span>key_resource_id<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//释放锁</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>缺点：</strong></p><ol><li><code>sexnx</code>和<code>expire</code>两个命令的执行不是原子操作。 <ol><li>若<code>sexnx</code>加完锁之后，正准备执行<code>expire</code>设置过期时间时，进程crash或者重启维护了，那么这个锁就永远存在，别的线程永远获取不到锁。</li></ol></li></ol><h3 id="setnx-value为-系统时间-过期时间" tabindex="-1"><a class="header-anchor" href="#setnx-value为-系统时间-过期时间" aria-hidden="true">#</a> setnx value为(系统时间 + 过期时间)</h3><p>巧妙移除<code>expire</code>单独设置过期时间的操作，把<strong>过期时间放到setnx的value值</strong>里面来。解决了方案一发生异常，锁得不到释放的问题。但是这个方案还有别的缺点：</p><p>缺点：</p><ol><li>过期时间时客户端自己生成的，所以需要分布式环境下不同客户端的时间要同步。</li><li>如果锁过期的时候，并发多个客户端同时请求过来，都执行jedis.getSet()，最终只能有一个客户端加锁成功，但是该客户端锁的过期时间，可能被别的客户端覆盖</li><li>该锁没有保存持有者的唯一标识，可能被别的客户端释放/解锁。</li></ol><h3 id="lua脚本-setnx-expire" tabindex="-1"><a class="header-anchor" href="#lua脚本-setnx-expire" aria-hidden="true">#</a> Lua脚本(setnx + expire)</h3><p>Redis使用Lua脚本能够保证指令执行的原子性</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code> <span class="token class-name">String</span> lua_scripts <span class="token operator">=</span> <span class="token string">&quot;if redis.call(&#39;setnx&#39;,KEYS[1],ARGV[1]) == 1 then&quot;</span> <span class="token operator">+</span>
            <span class="token string">&quot; redis.call(&#39;expire&#39;,KEYS[1],ARGV[2]) return 1 else return 0 end&quot;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="set的扩展命令-set-ex-px-nx" tabindex="-1"><a class="header-anchor" href="#set的扩展命令-set-ex-px-nx" aria-hidden="true">#</a> Set的扩展命令(SET EX PX NX)</h3><p><code>SET key value [EX seconds] [PX milliseconds] [NX|XX]</code></p><blockquote><p>NX :表示key不存在的时候，才能set成功，也即保证只有第一个客户端请求才能获得锁，而其他客户端请求只能等其释放锁，才能获取。</p><p>EX seconds :设定key的过期时间，时间单位是秒。</p><p>PX milliseconds: 设定key的过期时间，单位为毫秒</p><p>XX: 仅当key存在时设置值</p></blockquote><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">if</span>（jedis<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key_resource_id<span class="token punctuation">,</span> lock_value<span class="token punctuation">,</span> <span class="token string">&quot;NX&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;EX&quot;</span><span class="token punctuation">,</span> <span class="token number">100</span>s<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span>）<span class="token punctuation">{</span> <span class="token comment">//加锁</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">do</span> something  <span class="token comment">//业务处理</span>
    <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
　　<span class="token punctuation">}</span>
　　<span class="token keyword">finally</span> <span class="token punctuation">{</span>
       jedis<span class="token punctuation">.</span><span class="token function">del</span><span class="token punctuation">(</span>key_resource_id<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//释放锁</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种方案也有问题：</p><ol><li>当锁过期释放了之后，业务还没执行完！</li><li>锁被别的线程误删。</li></ol><h3 id="set-nx-px-nx-校验唯一随机值-再删除" tabindex="-1"><a class="header-anchor" href="#set-nx-px-nx-校验唯一随机值-再删除" aria-hidden="true">#</a> SET NX PX NX + 校验唯一随机值，再删除</h3><p>既然锁可能被其他线程删除掉，那我们给value值设置一个标记当前线程唯一的随机数，在删除的时候，校验一下：</p><h3 id="redisson框架" tabindex="-1"><a class="header-anchor" href="#redisson框架" aria-hidden="true">#</a> Redisson框架</h3><h3 id="多机实现的分布式锁redlock-redisson" tabindex="-1"><a class="header-anchor" href="#多机实现的分布式锁redlock-redisson" aria-hidden="true">#</a> 多机实现的分布式锁Redlock+Redisson</h3><h3 id="相关面试题" tabindex="-1"><a class="header-anchor" href="#相关面试题" aria-hidden="true">#</a> 相关面试题</h3><figure><img src="/assets/image-20230428161700395-IrwL83cg.png" alt="image-20230428161700395" tabindex="0" loading="lazy"><figcaption>image-20230428161700395</figcaption></figure><h1 id="六、键的过期时间" tabindex="-1"><a class="header-anchor" href="#六、键的过期时间" aria-hidden="true">#</a> 六、键的过期时间</h1><p>Redis 可以为每个键设置过期时间，当键过期时，会自动删除该键。</p><p>对于散列表这种容器，只能为整个键设置过期时间（整个散列表），而不能为键里面的单个元素设置过期时间。</p><h1 id="七、数据淘汰策略" tabindex="-1"><a class="header-anchor" href="#七、数据淘汰策略" aria-hidden="true">#</a> 七、数据淘汰策略</h1><p>可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略。</p><p>Redis 具体有 6 种淘汰策略：</p><table><thead><tr><th>策略</th><th>描述</th></tr></thead><tbody><tr><td>volatile-lru</td><td>从已设置过期时间的数据集中挑选<strong>最近最少使用</strong>的数据淘汰</td></tr><tr><td>volatile-ttl</td><td>从已设置过期时间的数据集中挑选将<strong>要过期</strong>的数据淘汰</td></tr><tr><td>volatile-random</td><td>从已设置过期时间的数据集<strong>中任意选择数据淘汰</strong></td></tr><tr><td>allkeys-lru</td><td>从所有数据集中挑选<strong>最近最少使用</strong>的数据淘汰</td></tr><tr><td>allkeys-random</td><td>从所有数据集中<strong>任意选择</strong>数据进行淘汰</td></tr><tr><td>noeviction</td><td>禁止驱逐数据</td></tr></tbody></table><p>作为内存数据库，出于对性能和内存消耗的考虑，Redis 的淘汰算法实际实现上并非针对所有 key，而是抽样一小部分并且从中选出被淘汰的 key。</p><p>使用 Redis 缓存数据时，为了提高缓存命中率，<strong>需要保证缓存数据都是热点数据。可以将内存最大使用量设置为热点数据占用的内存量</strong>，然后启用 allkeys-lru 淘汰策略，将最近最少使用的数据淘汰。</p><p>Redis 4.0 引入了 volatile-lfu 和 allkeys-lfu 淘汰策略，LFU 策略通过统计<strong>访问频率，将访问频率最少的键值对淘汰</strong>。</p><h1 id="八、持久化" tabindex="-1"><a class="header-anchor" href="#八、持久化" aria-hidden="true">#</a> 八、持久化</h1><p>Redis 是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上。</p><h2 id="rdb-持久化" tabindex="-1"><a class="header-anchor" href="#rdb-持久化" aria-hidden="true">#</a> RDB 持久化</h2><p><strong>将某个时间点的所有数据以二进制的形式保存到硬盘上。</strong></p><p>可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。</p><p>如果系统发生故障，将会丢失最后一次创建快照之后的数据。</p><p>如果数据量很大，保存快照的时间会很长。</p><blockquote><p>Redis会单独创建一个子进程来进行持久化，会先将数据写入到一个临时文件中，代持久化过程结束之后，再用这个临时文件替换上次持久化好的文件。</p><p>整个过程中，主进程是不进行任何I/O操作的，这就确保了较高的性能。</p><p>如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是特别敏感，那RDB方式要比AOF方式更加高效。</p><p>RDB的<strong>缺点是最后一次持久化后的数据可能丢失。</strong></p></blockquote><h3 id="触发策略" tabindex="-1"><a class="header-anchor" href="#触发策略" aria-hidden="true">#</a> 触发策略</h3><h4 id="手动触发" tabindex="-1"><a class="header-anchor" href="#手动触发" aria-hidden="true">#</a> 手动触发</h4><p>手动触发的两个命令区别在于是否在<code>主线程</code>里执行</p><ul><li><p><code>save</code></p><ul><li>会阻塞Redis服务器的正常操作, 直到RDB文件写入完成.</li><li>只管保存，单线程，会阻塞其他线程</li></ul></li><li><p><code>bgsave</code></p><ul><li>redis会在后台异步进行快照操作，快照同时还可以相应客户端请求。可以通过lastsave命令获取最后一次成功执行快照的时间</li></ul></li></ul><h4 id="自动触发" tabindex="-1"><a class="header-anchor" href="#自动触发" aria-hidden="true">#</a> 自动触发</h4><p>自动触发RDB持久化机制可以通过配置文件中的save选项来实现。可以配置多个save选项，每个选项指定一个时间间隔和执行SAVE或BGSAVE命令.</p><h3 id="执行快照时-数据能被修改吗" tabindex="-1"><a class="header-anchor" href="#执行快照时-数据能被修改吗" aria-hidden="true">#</a> 执行快照时，数据能被修改吗？</h3><p><strong>写时复制技术（Copy-On-Write, COW）。</strong></p><p>细心的同学，肯定发现了，bgsave 快照过程中，如果主线程修改了共享数据，<strong>发生了写时复制后，RDB 快照保存的是原本的内存数据</strong>，而主线程刚修改的数据，是没办法在这一时间写入 RDB 文件的，只能交由下一次的 bgsave 快照。</p><p>所以 Redis 在使用 bgsave 快照过程中，如果主线程修改了内存数据，不管是否是共享的内存数据，RDB 快照都无法写入主线程刚修改的数据，因为此时主线程（父进程）的内存数据和子进程的内存数据已经分离了，子进程写入到 RDB 文件的内存数据只能是原本的内存数据。</p><p>如果系统恰好在 RDB 快照文件创建完毕后崩溃了，那么 Redis 将会丢失主线程在快照期间修改的数据。</p><p>另外，写时复制的时候会出现这么个极端的情况。</p><p>在 Redis 执行 RDB 持久化期间，刚 fork 时，主进程和子进程共享同一物理内存，但是途中主进程处理了写操作，修改了共享内存，于是当前被修改的数据的物理内存就会被复制一份。</p><p>那么极端情况下，<strong>如果所有的共享内存都被修改，则此时的内存占用是原先的 2 倍。</strong></p><p>所以，针对写操作多的场景，我们要留意下快照过程中内存的变化，防止内存被占满了。</p><blockquote><p>总结：</p><ol><li>利用写时复制技术，可以进行修改</li><li>但是修改的数据无法保存在当前RDB中，只能等下一次RDB了。</li><li>如果修改的数据比较多的时候，可能会复制双份内存，导致内存占用率过高。</li></ol></blockquote><h2 id="aof-持久化" tabindex="-1"><a class="header-anchor" href="#aof-持久化" aria-hidden="true">#</a> AOF 持久化</h2><p>将写命令添加到 AOF 文件（Append Only File）的末尾。</p><p>以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下里(读操作不记录)，只允许追加文件但不允许改写文件，rdis启动之初会读取该文件重新构建数据。</p><blockquote><p>保存写操作命令到日志的持久化方式，就是Redis中的AOF持久化功能， 注意<code>只会记录写操作命令</code>，读操作命令是不会被记录的。</p></blockquote><h3 id="使用方法" tabindex="-1"><a class="header-anchor" href="#使用方法" aria-hidden="true">#</a> 使用方法</h3><p>默认在redis中是没有启用AOF的，需要我们修改<code>redis.conf</code>配置文件中的参数：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>appendonly yes //表示是否开启AOF持久化(默认关闭)
appendfilename &quot;appendonly.aof&quot; //AOF持久化文件的名称
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="日志格式" tabindex="-1"><a class="header-anchor" href="#日志格式" aria-hidden="true">#</a> 日志格式</h3><p>存储的就是<code>普通的文本</code>，可以使用cat等日志查看工具来进行查看。</p><p>我这里以「<em>set name xiaolin</em>」命令作为例子，Redis 执行了这条命令后，记录在 AOF 日志里的内容如下图：</p><figure><img src="/assets/337021a153944fd0f964ca834e34d0f2-zGifu9rF.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="写回策略" tabindex="-1"><a class="header-anchor" href="#写回策略" aria-hidden="true">#</a> 写回策略</h3><p>使用 AOF 持久化需要设置同步选项，从而确保写命令同步到磁盘文件上的时机。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是<strong>先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘</strong>。有以下同步选项：</p><figure><img src="/assets/4eeef4dd1bedd2ffe0b84d4eaa0dbdea-t_mbY-7o.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><table><thead><tr><th>选项</th><th>同步频率</th></tr></thead><tbody><tr><td>always</td><td>每个写命令都同步(到磁盘)</td></tr><tr><td>everysec(默认)</td><td><strong>每秒同步一次</strong>(先将命令写入到 AOF 文件的内核缓冲区，然后每隔一秒将缓冲区里的内容写回到硬盘)</td></tr><tr><td>no</td><td>表示不执行AOF持久化操作，仅依靠操作系统的缓存来保证数据的可靠性。这种策略不安全，可能会导致数据的丢失。</td></tr></tbody></table><ul><li>always 选项不可避免影响主线程的性能；</li><li>no 选项并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量。</li><li>everysec是一种折中的方法，避免了always策略的性能开销，也比No策略更能避免数据丢失。</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 默认配置</span>
<span class="token comment"># appendfsync always</span>
appendfsync everysec
<span class="token comment"># appendfsync no</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>三种写回策略都只是在控制 <code>fsync()</code> 函数的调用时机。调用 <code>fsync()</code> 函数，这样内核就会将内核缓冲区的数据直接写入到硬盘，等到硬盘写操作完成后，该函数才会返回。</p><ul><li><p>always 每次写入之后，就调用</p></li><li><p>everysec 创建一个异步任务来执行</p></li><li><p>no永不调用fsync</p></li></ul></blockquote><h3 id="重写机制" tabindex="-1"><a class="header-anchor" href="#重写机制" aria-hidden="true">#</a> 重写机制</h3><p>随着服务器写请求的增多，AOF 文件会越来越大。Redis 为了避免 AOF 文件越写越大，提供了 <strong>AOF 重写机制</strong>，当 AOF 文件的大小超过所设定的阈值后，Redis 就会启用 AOF 重写机制，来压缩 AOF 文件。</p><blockquote><p>当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集，可以使用命令<code>bgrewriteraof</code></p></blockquote><figure><img src="/assets/image-20210412170946018-oqB2zevf.png" alt="image-20210412170946018" tabindex="0" loading="lazy"><figcaption>image-20210412170946018</figcaption></figure><p>**触发机制：**Redis会记录上次重写时的AOF的大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发。</p><p>Redis的后台重写机制是由后台子进程<code>bgrewriteaof</code>来完成的，这样做有两个好处：</p><ol><li>子进程在AOF重写期间，主进程可以继续处理命令请求，从而避免阻塞主线程。</li><li>子进程是通过主进程利用<code>fork</code>系统调用生成的，操作系统会将主进程的<code>页表</code>复制一份给子进程，这个页表记录着虚拟地址和物理地址映射关系，而不会复制物理内存，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。 <ol><li>不过，当父进程或者子进程在向这个内存发起写操作时，CPU 就会触发<strong>写保护中断</strong>，这个写保护中断是由于违反权限导致的，然后操作系统会在「写保护中断处理函数」里进行<strong>物理内存的复制</strong>，并重新设置其内存映射关系，将父子进程的内存读写权限设置为<strong>可读写</strong>，最后才会对内存进行写操作，这个过程被称为「<strong>写时复制(*Copy On Write*)</strong>」。</li><li>写时复制顾名思义，<strong>在发生写操作的时候，操作系统才会去复制物理内存</strong>，这样是为了防止 fork 创建子进程时，由于物理内存数据的复制时间过长而导致父进程长时间阻塞的问题。</li></ol></li></ol><p>在AOF重写的过程中，主进程可能对redis中的数据进行了写操作，那么就会发生写时复制，复制并修改主进程要修改的物理内存数据，那这就会导致主进程的内存和子进程的内存不一致。为了解决这种不一致，Redis在AOF重写的过程中，设置了一个AOF重写缓冲区。</p><p>也就是说，在 bgrewriteaof 子进程执行 AOF 重写期间，主进程需要执行以下三个工作:</p><ul><li>执行客户端发来的命令；</li><li>将执行后的写命令追加到 「AOF 缓冲区」；</li><li>将执行后的写命令追加到 「AOF 重写缓冲区」；</li></ul><p>当子进程完成 AOF 重写工作（<em>扫描数据库中所有数据，逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志</em>）后，会向主进程发送一条信号，信号是进程间通讯的一种方式，且是异步的。</p><p>主进程收到该信号后，会调用一个信号处理函数，该函数主要做以下工作：</p><ul><li>将 AOF 重写缓冲区中的所有内容追加到新的 AOF 的文件中，使得新旧两个 AOF 文件所保存的数据库状态一致；</li><li>新的 AOF 的文件进行改名，覆盖现有的 AOF 文件。</li></ul><h3 id="aof修复" tabindex="-1"><a class="header-anchor" href="#aof修复" aria-hidden="true">#</a> AOF修复</h3><p>由于Redis断电异常，AOF文件可能被会写入一些不合理的命令，这时可用<code>redis-check-aof --fix appendonly.aof</code>修复aof文件，</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><h3 id="rdb-和-aof-合体" tabindex="-1"><a class="header-anchor" href="#rdb-和-aof-合体" aria-hidden="true">#</a> RDB 和 AOF 合体</h3><p>尽管 RDB 比 AOF 的数据恢复速度快，但是快照的频率不好把握：</p><ul><li>如果频率太低，两次快照间一旦服务器发生宕机，就可能会比较多的数据丢失；</li><li>如果频率太高，频繁写入磁盘和创建子进程会带来额外的性能开销。</li></ul><p>那有没有什么方法不仅有 RDB 恢复速度快的优点和，又有 AOF 丢失数据少的优点呢？</p><p>当然有，那就是将 RDB 和 AOF 合体使用，这个方法是在 Redis 4.0 提出的，该方法叫<strong>混合使用 AOF 日志和内存快照</strong>，也叫混合持久化。</p><p>如果想要开启混合持久化功能，可以在 Redis 配置文件将下面这个配置项设置成 yes：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>aof-use-rdb-preamble yes
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>混合持久化工作在 <strong>AOF 日志重写过程</strong>。</p><p>当开启了混合持久化时，在 AOF 重写日志时，</p><ol><li><code>fork</code> 出来的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件</li><li>然后主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会<code>以 AOF 方式写入到 AOF 文件</code></li><li>写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。</li></ol><p>也就是说，使用了混合持久化，AOF 文件的<strong>前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据</strong>。</p><figure><img src="/assets/f67379b60d151262753fec3b817b8617-H5KJHLRv.jpeg" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>这样的好处在于，重启 Redis 加载数据的时候，由于前半部分是 RDB 内容，这样<strong>加载的时候速度会很快</strong>。</p><p>加载完 RDB 的内容后，才会加载后半部分的 AOF 内容，这里的内容是 <code>Redis 后台子进程重写 AOF 期间，主线程处理的操作命令，可以使得**数据更少的丢失**</code>。</p><figure><img src="/assets/image-20210412172417293-0FgMwaAn.png" alt="image-20210412172417293" tabindex="0" loading="lazy"><figcaption>image-20210412172417293</figcaption></figure><figure><img src="/assets/image-20210413091801110-fhiM3wJx.png" alt="image-20210413091801110" tabindex="0" loading="lazy"><figcaption>image-20210413091801110</figcaption></figure><h1 id="九、事务" tabindex="-1"><a class="header-anchor" href="#九、事务" aria-hidden="true">#</a> 九、事务</h1><p>一个事务包含了多个命令，服务器在执行事务期间，不会改去执行其它客户端的命令请求。</p><p><code>它可以减少客户端与服务器之间的网络通信次数从而提升性能。</code></p><p>Redis事务中的命令不会立即执行，而是将它们按顺序添加到一个事务队列中，然后通过 EXEC 命令一次性执行所有命令。如果在事务执行期间出现错误，不会影响队列中后续的命令执行。</p><h2 id="常用命令" tabindex="-1"><a class="header-anchor" href="#常用命令" aria-hidden="true">#</a> 常用命令</h2><ul><li>Discard</li><li>exec</li><li>multi</li><li>unwatch <ul><li>取消watch命令对所有key的监视。</li></ul></li><li>watch key <ul><li>监视一个或多个key，如果在事务执行之前，key被其他命令修改，那么事务将会被打断。</li></ul></li></ul><h2 id="三个阶段" tabindex="-1"><a class="header-anchor" href="#三个阶段" aria-hidden="true">#</a> 三个阶段</h2><ul><li>开启：以multi开始一个事务。</li><li>入队：将多个命令入队到事务中，接到这些命令并不会立即执行，而是放到等待执行的事务队列中。</li><li>执行：由exec命令触发事务。</li></ul><h2 id="四种错误情况" tabindex="-1"><a class="header-anchor" href="#四种错误情况" aria-hidden="true">#</a> 四种错误情况</h2><ul><li><p>正常执行</p><ul><li><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>multi
<span class="token builtin class-name">set</span> k1 v1
<span class="token builtin class-name">set</span> k2 v2
<span class="token builtin class-name">set</span> k3 v3
<span class="token builtin class-name">exec</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p>放弃事务</p><ul><li><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>multi
<span class="token builtin class-name">set</span> k1 v1
<span class="token builtin class-name">set</span> k2 v2
<span class="token builtin class-name">set</span> k3 v3
discard
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p>全体连坐<code>（队列中有一条指令出现了编译错误）</code></p><ul><li><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>multi
<span class="token builtin class-name">set</span> k1 v1
<span class="token builtin class-name">set</span> k2 v2
<span class="token builtin class-name">set</span> k3 v3
getset k3 <span class="token comment"># 命令编译时报Error</span>
<span class="token builtin class-name">set</span> k5 v5
<span class="token builtin class-name">exec</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>中间有一个命令没成功，所有的命令都不执行。</p></li></ul></li><li><p>源头债主<code>（队列中有一条指令出现了运行异常）</code></p><ul><li><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>multi
<span class="token builtin class-name">set</span> k1 v1
incr k1 <span class="token comment"># 命令执行时异常，只有该条记录未修改成功</span>
<span class="token builtin class-name">set</span> k2 v2
<span class="token builtin class-name">set</span> k3 v3
<span class="token builtin class-name">exec</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p>watch监控</p><ul><li>悲观锁 <ul><li>悲观，每次去拿数据的时候都认为别人会修改，所以每次去拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。</li><li>传统的关系型数据库里边就用到了很多这种锁机制，比如行锁、表锁、读锁、写锁等。都是在操作数据前先上锁。</li></ul></li><li>乐观锁 <ul><li>乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量。</li><li>提交版本必须大于记录当前版本才能更新</li></ul></li><li>CAS</li><li><img src="/assets/image-20210413101133523-FN2ob5qp.png" alt="image-20210413101133523" tabindex="0" loading="lazy"><figcaption>image-20210413101133523</figcaption></li></ul></li></ul><h2 id="特性" tabindex="-1"><a class="header-anchor" href="#特性" aria-hidden="true">#</a> 特性</h2><ul><li><img src="/assets/image-20210413101547075-YQSt1d2y.png" alt="image-20210413101547075" tabindex="0" loading="lazy"><figcaption>image-20210413101547075</figcaption></li></ul><h1 id="十、事件" tabindex="-1"><a class="header-anchor" href="#十、事件" aria-hidden="true">#</a> 十、事件</h1><p>Redis 服务器是一个事件驱动程序。</p><h2 id="文件事件" tabindex="-1"><a class="header-anchor" href="#文件事件" aria-hidden="true">#</a> 文件事件</h2><p>服务器通过套接字与客户端或者其它服务器进行通信，文件事件就是对套接字操作的抽象。</p><p>Redis 基于 Reactor 模式开发了自己的网络事件处理器，使用 I/O 多路复用程序来同时监听多个套接字，并将到达的事件传送给文件事件分派器，分派器会根据套接字产生的事件类型调用相应的事件处理器。</p><figure><a href="https://camo.githubusercontent.com/b570ff3264449fd72ba03e0c70ca02247cc4f283/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39656138366562352d303030612d343238312d623934382d3762353637626436663164382e706e67" target="_blank" rel="noopener noreferrer"><img src="https://camo.githubusercontent.com/b570ff3264449fd72ba03e0c70ca02247cc4f283/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39656138366562352d303030612d343238312d623934382d3762353637626436663164382e706e67" alt="img" tabindex="0" loading="lazy"><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a><figcaption>img</figcaption></figure><h2 id="时间事件" tabindex="-1"><a class="header-anchor" href="#时间事件" aria-hidden="true">#</a> 时间事件</h2><p>服务器有一些操作需要在给定的时间点执行，时间事件是对这类定时操作的抽象。</p><p>时间事件又分为：</p><ul><li>定时事件：是让一段程序在指定的时间之内执行一次；</li><li>周期性事件：是让一段程序每隔指定时间就执行一次。</li></ul><p>Redis 将所有时间事件都放在一个无序链表中，通过遍历整个链表查找出已到达的时间事件，并调用相应的事件处理器。</p><h2 id="事件的调度与执行" tabindex="-1"><a class="header-anchor" href="#事件的调度与执行" aria-hidden="true">#</a> 事件的调度与执行</h2><p>服务器需要不断监听文件事件的套接字才能得到待处理的文件事件，但是不能一直监听，否则时间事件无法在规定的时间内执行，因此监听时间应该根据距离现在最近的时间事件来决定。</p><p>事件调度与执行由 aeProcessEvents 函数负责，伪代码如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>def aeProcessEvents():
    # 获取到达时间离当前时间最接近的时间事件
    time_event = aeSearchNearestTimer()
    # 计算最接近的时间事件距离到达还有多少毫秒
    remaind_ms = time_event.when - unix_ts_now()
    # 如果事件已到达，那么 remaind_ms 的值可能为负数，将它设为 0
    if remaind_ms &lt; 0:
        remaind_ms = 0
    # 根据 remaind_ms 的值，创建 timeval
    timeval = create_timeval_with_ms(remaind_ms)
    # 阻塞并等待文件事件产生，最大阻塞时间由传入的 timeval 决定
    aeApiPoll(timeval)
    # 处理所有已产生的文件事件
    procesFileEvents()
    # 处理所有已到达的时间事件
    processTimeEvents()
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>将 aeProcessEvents 函数置于一个循环里面，加上初始化和清理函数，就构成了 Redis 服务器的主函数，伪代码如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>def main():
    # 初始化服务器
    init_server()
    # 一直处理事件，直到服务器关闭为止
    while server_is_not_shutdown():
        aeProcessEvents()
    # 服务器关闭，执行清理操作
    clean_server()
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从事件处理的角度来看，服务器运行流程如下：</p><figure><a href="https://camo.githubusercontent.com/87a2045534a9a0cc2ba02a0e21581d85d2ca2b84/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f63306139666139312d646132652d343839322d386339662d3830323036613666373034372e706e67" target="_blank" rel="noopener noreferrer"><img src="https://camo.githubusercontent.com/87a2045534a9a0cc2ba02a0e21581d85d2ca2b84/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f63306139666139312d646132652d343839322d386339662d3830323036613666373034372e706e67" alt="img" tabindex="0" loading="lazy"><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a><figcaption>img</figcaption></figure><h1 id="十一、复制" tabindex="-1"><a class="header-anchor" href="#十一、复制" aria-hidden="true">#</a> 十一、复制</h1><p>通过使用 slaveof host port 命令来让一个服务器成为另一个服务器的从服务器。</p><p>一个从服务器只能有一个主服务器，并且不支持主主复制。</p><blockquote><ul><li><p>配从(库)不配主(库)</p></li><li><p>从库配置：slaveof 主库ip 主库端口</p><ul><li>每次与master断开之后，都需要重新连接，除非你配置再redis.conf文件中。</li><li>info republication命令：打印出republication信息</li></ul></li><li><p>修改配置文件操作细节</p><ol><li>拷贝多个redis.conf文件</li><li>开启daemonize yes</li><li>pid 文件名字</li><li>指定端口</li><li>log文件名字</li><li>dump.rdb文件名字</li></ol></li></ul></blockquote><h2 id="连接过程" tabindex="-1"><a class="header-anchor" href="#连接过程" aria-hidden="true">#</a> 连接过程</h2><ol><li>主服务器创建快照文件，发送给从服务器，并在发送期间使用缓冲区记录执行的写命令。快照文件发送完毕之后，开始向从服务器发送存储在缓冲区中的写命令；</li><li>从服务器丢弃所有旧数据，载入主服务器发来的快照文件，之后从服务器开始接受主服务器发来的写命令；</li><li>主服务器每执行一次写命令，就向从服务器发送相同的写命令。</li></ol><h2 id="主从链" tabindex="-1"><a class="header-anchor" href="#主从链" aria-hidden="true">#</a> 主从链</h2><p>随着负载不断上升，主服务器可能无法很快地更新所有从服务器(为了减轻master的写压力)，或者重新连接和重新同步从服务器将导致系统超载。为了解决这个问题，可以创建一个中间层来分担主服务器的复制工作。中间层的服务器是最上层服务器的从服务器，又是最下层服务器的主服务器。</p><figure><a href="https://camo.githubusercontent.com/db582544b7e7d6b094f7e051eb2f76f0b2f8b3ff/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f33393561396538332d623161312d346131642d623137302d6430383165376262356261622e706e67" target="_blank" rel="noopener noreferrer"><img src="https://camo.githubusercontent.com/db582544b7e7d6b094f7e051eb2f76f0b2f8b3ff/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f33393561396538332d623161312d346131642d623137302d6430383165376262356261622e706e67" alt="img" tabindex="0" loading="lazy"><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a><figcaption>img</figcaption></figure><h2 id="常用玩法" tabindex="-1"><a class="header-anchor" href="#常用玩法" aria-hidden="true">#</a> 常用玩法</h2><ul><li>一主二从</li><li>薪火相传</li><li>反客为主</li></ul><h2 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点" aria-hidden="true">#</a> 缺点</h2><p>复制延迟(master到slave)</p><h2 id="面试题" tabindex="-1"><a class="header-anchor" href="#面试题" aria-hidden="true">#</a> 面试题</h2><h3 id="_1、为什么redis集群的最大槽位是16384个" tabindex="-1"><a class="header-anchor" href="#_1、为什么redis集群的最大槽位是16384个" aria-hidden="true">#</a> 1、为什么redis集群的最大槽位是16384个？</h3><blockquote><p>Redis集群并没有使用一致性hash而是引入了哈希槽的概念。Redis集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。但为什么哈希槽的数量是16384（2^14）个呢？</p><p>CRC16算法产生的hash值有16bit，该算法可以产生2^16=65536个值。 换句话说值是分布在0~65535之间。那作者在做mod运算的时候，为什么不mod65536，而选择mod16384？</p></blockquote><ul><li><p>正常的心跳数据包带有节点的完整配置，可以用幂等方式用旧的节点替换旧节点，以便更新旧的配置。这意味着它们包含原始节点的插槽配置，该节点使用2k的空间和16k的插槽，但是会使用8k的空间（使用65k的插槽）。</p></li><li><p>同时，由于其他设计折衷，Redis集群不太可能扩展到1000个以上的主节点。 因此16k处于正确的范围内，以确保每个主机具有足够的插槽，最多可容纳1000个矩阵，但数量足够少，可以轻松地将插槽配置作为原始位图传播。请注意，在小型群集中，位图将难以压缩，因为当N较小时，位图将设置的slot / N位占设置位的很大百分比。</p></li><li><figure><img src="/assets/image-20230426142544218-0WtzMmSP.png" alt="image-20230426142544218" tabindex="0" loading="lazy"><figcaption>image-20230426142544218</figcaption></figure></li><li><p>(1)如果槽位为65536，发送心跳信息的消息头达8k，发送的心跳包过于庞大。 在消息头中最占空间的是myslots[CLUSTER_SLOTS/8]。 当槽位为65536时，这块的大小是: 65536÷8÷1024=8kb 因为每秒钟，redis节点需要发送一定数量的ping消息作为心跳包，如果槽位为65536，这个ping消息的消息头太大了，浪费带宽。</p><p>(2)redis的集群主节点数量基本不可能超过1000个。 集群节点越多，心跳包的消息体内携带的数据越多。如果节点过1000个，也会导致网络拥堵。因此redis作者不建议redis cluster节点数量超过1000个。 那么，对于节点数在1000以内的redis cluster集群，16384个槽位够用了。没有必要拓展到65536个。</p><p>(3)槽位越小，节点少的情况下，压缩比高，容易传输 Redis主节点的配置信息中它所负责的哈希槽是通过一张bitmap的形式来保存的，在传输过程中会对bitmap进行压缩，但是如果bitmap的填充率slots / N很高的话(N表示节点数)，bitmap的压缩率就很低。 如果节点数很少，而哈希槽数量很多的话，bitmap的压缩率就很低。</p></li></ul><h1 id="十二、sentinel" tabindex="-1"><a class="header-anchor" href="#十二、sentinel" aria-hidden="true">#</a> 十二、Sentinel</h1><p>Sentinel（哨兵）可以监听集群中的服务器，并在主服务器进入下线状态时，自动从从服务器中选举出新的主服务器。</p><h2 id="玩法" tabindex="-1"><a class="header-anchor" href="#玩法" aria-hidden="true">#</a> 玩法</h2><ol><li>自定义的<code>/myredis</code>目录新建<code>sentinel.conf</code>文件，名字绝对不能错。</li><li>配置哨兵 <ol><li>sentinel monitor 被监控数据库名字(自己起) 127.0.0.1 6379 1</li><li>上面的数字1，表示主机挂掉后slave投票看让谁接替成为主机，得票数多少后成为主机。</li></ol></li><li>启动哨兵 <ol><li><code>redis-sentinel /xxx/sentinel.conf</code></li></ol></li></ol><h1 id="十三、分片" tabindex="-1"><a class="header-anchor" href="#十三、分片" aria-hidden="true">#</a> 十三、分片</h1><p>当 Redis 缓存数据量大到一台服务器无法缓存时，就需要使用 <strong>Redis 切片集群</strong>（Redis Cluster ）方案，它将数据分布在不同的服务器上，以此来降低系统对单主节点的依赖，从而提高 Redis 服务的读写性能。</p><p>分片是将数据划分为多个部分的方法，可以将数据存储到多台机器里面，这种方法在解决某些问题时可以获得线性级别的性能提升。</p><p>假设有 4 个 Redis 实例 R0，R1，R2，R3，还有很多表示用户的键 user:1，user:2，... ，有不同的方式来选择一个指定的键存储在哪个实例中。</p><ul><li>最简单的方式是范围分片，例如用户 id 从 0~1000 的存储到实例 R0 中，用户 id 从 1001~2000 的存储到实例 R1 中，等等。但是这样需要维护一张映射范围表，维护操作代价很高。</li><li>还有一种方式是哈希分片，使用 CRC32 哈希函数将键转换为一个数字，再对实例数量求模就能知道应该存储的实例。</li></ul><p>根据执行分片的位置，可以分为三种分片方式：</p><ul><li>客户端分片：客户端使用一致性哈希等算法决定键应当分布到哪个节点。</li><li>代理分片：将客户端请求发送到代理上，由代理转发请求到正确的节点上。</li><li>服务器分片：Redis Cluster。</li></ul><h1 id="十四、一个简单的论坛系统分析" tabindex="-1"><a class="header-anchor" href="#十四、一个简单的论坛系统分析" aria-hidden="true">#</a> 十四、一个简单的论坛系统分析</h1><p>该论坛系统功能如下：</p><ul><li>可以发布文章；</li><li>可以对文章进行点赞；</li><li>在首页可以按文章的发布时间或者文章的点赞数进行排序显示。</li></ul><h2 id="文章信息" tabindex="-1"><a class="header-anchor" href="#文章信息" aria-hidden="true">#</a> 文章信息</h2><p>文章包括标题、作者、赞数等信息，在关系型数据库中很容易构建一张表来存储这些信息，在 Redis 中可以使用 HASH 来存储每种信息以及其对应的值的映射。</p><p>Redis 没有关系型数据库中的表这一概念来将同种类型的数据存放在一起，而是使用命名空间的方式来实现这一功能。键名的前面部分存储命名空间，后面部分的内容存储 ID，通常使用 : 来进行分隔。例如下面的 HASH 的键名为 article:92617，其中 article 为命名空间，ID 为 92617。</p><figure><a href="https://camo.githubusercontent.com/6a63ea8766fbef1f2d118e93473a963785c48c04/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f37633534646532312d653266662d343032652d626334322d3430333764653163313539322e706e67" target="_blank" rel="noopener noreferrer"><img src="https://camo.githubusercontent.com/6a63ea8766fbef1f2d118e93473a963785c48c04/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f37633534646532312d653266662d343032652d626334322d3430333764653163313539322e706e67" alt="img" tabindex="0" loading="lazy"><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a><figcaption>img</figcaption></figure><h2 id="点赞功能" tabindex="-1"><a class="header-anchor" href="#点赞功能" aria-hidden="true">#</a> 点赞功能</h2><p>当有用户为一篇文章点赞时，除了要对该文章的 votes 字段进行加 1 操作，还必须记录该用户已经对该文章进行了点赞，防止用户点赞次数超过 1。可以建立文章的已投票用户集合来进行记录。</p><p>为了节约内存，规定一篇文章发布满一周之后，就不能再对它进行投票，而文章的已投票集合也会被删除，可以为文章的已投票集合设置一个一周的过期时间就能实现这个规定。</p><figure><a href="https://camo.githubusercontent.com/4ca96abd48fc7cd1cb19df7e0ae888a443e77559/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f34383566646633342d636366382d343138352d393763362d3137333734656537313961302e706e67" target="_blank" rel="noopener noreferrer"><img src="https://camo.githubusercontent.com/4ca96abd48fc7cd1cb19df7e0ae888a443e77559/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f34383566646633342d636366382d343138352d393763362d3137333734656537313961302e706e67" alt="img" tabindex="0" loading="lazy"><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a><figcaption>img</figcaption></figure><h2 id="对文章进行排序" tabindex="-1"><a class="header-anchor" href="#对文章进行排序" aria-hidden="true">#</a> 对文章进行排序</h2><p>为了按发布时间和点赞数进行排序，可以建立一个文章发布时间的有序集合和一个文章点赞数的有序集合。（下图中的 score 就是这里所说的点赞数；下面所示的有序集合分值并不直接是时间和点赞数，而是根据时间和点赞数间接计算出来的）</p><figure><a href="https://camo.githubusercontent.com/fbb72eeafa944f3994bfd7ffcc9066bba1b6190b/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f66376431373061332d653434362d346136342d616332642d6362393530323866383161382e706e67" target="_blank" rel="noopener noreferrer"><img src="https://camo.githubusercontent.com/fbb72eeafa944f3994bfd7ffcc9066bba1b6190b/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f66376431373061332d653434362d346136342d616332642d6362393530323866383161382e706e67" alt="img" tabindex="0" loading="lazy"><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a><figcaption>img</figcaption></figure><h1 id="十五、传统rdbms与redis的比较" tabindex="-1"><a class="header-anchor" href="#十五、传统rdbms与redis的比较" aria-hidden="true">#</a> 十五、传统RDBMS与Redis的比较</h1><p><strong>RDBMS：</strong></p><ul><li>结构化查询语言</li><li>数据和关系都存储在单独的表中</li><li>数据操纵语言，数据定义语言</li><li>严格的一致性</li><li>基础事务</li></ul><p><strong>NoSQL：</strong></p><ul><li>代表着不仅仅是SQL</li><li>没有声明性查询语言</li><li>没有预定义的模式</li><li>K-V键值对存储、列存储、文档存储、图形数据库</li><li>最终一致性，而非ACID属性</li><li>非结构化和不可预知的数据</li><li>CAP定理</li><li>高性能，高可用性和可伸缩性</li></ul><h1 id="十六、cap" tabindex="-1"><a class="header-anchor" href="#十六、cap" aria-hidden="true">#</a> 十六、CAP</h1><p><strong>CAP：</strong></p><ul><li>Consistency强一致性</li><li>Availability可用性</li><li>Partition Tolerance分区容错性</li></ul><p>CAP理论的核心是：<strong>一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，最多只能同时较好的满足两个。</strong></p><p>而由于当前的网络硬件肯定会出现延迟丢包等问题，所以分区容忍性是我们必须需要实现的。</p><p>所以我们只能在<strong>一致性</strong>和<strong>可用性</strong>之间进行权衡，没有NoSQL系统能够同时保证这三点。</p><figure><img src="/assets/image-20210410152741160-InoRcQgV.png" alt="image-20210410152741160" tabindex="0" loading="lazy"><figcaption>image-20210410152741160</figcaption></figure><blockquote><p>CA 传统Oracle数据库</p><p>AP 大多数网站架构的选择</p><p>CP Redis、Mongodb</p></blockquote><figure><img src="/assets/image-20210410153431269-bd91YKaf.png" alt="image-20210410153431269" tabindex="0" loading="lazy"><figcaption>image-20210410153431269</figcaption></figure><h2 id="base" tabindex="-1"><a class="header-anchor" href="#base" aria-hidden="true">#</a> BASE</h2><p>BASE就是为了解决关系数据库强一致性引起的问题而引起的可用性降低而提出的解决方案。</p><ul><li>基本可用(Basically Available)</li><li>软状态(Soft state)</li><li>最终一致(Eventually consistent)</li></ul><p>他的思想是通过让系统放松对某一时刻数据一致性的要求来换取系统整体伸缩性和性能上改观。</p><h1 id="十七、linux操作redis" tabindex="-1"><a class="header-anchor" href="#十七、linux操作redis" aria-hidden="true">#</a> 十七、Linux操作Redis</h1><h2 id="redis部分命令" tabindex="-1"><a class="header-anchor" href="#redis部分命令" aria-hidden="true">#</a> Redis部分命令</h2><blockquote><p>redis端口6379在是手机按键上MERZ对应的号码，而MERZ取自意大利歌女<a href="http://it.wikipedia.org/wiki/Alessia_Merz" target="_blank" rel="noopener noreferrer">Alessia Merz<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>的名字</p></blockquote><p><code>Redis</code>命令参考：http://redisdoc.com/</p><h3 id="查看redis版本信息" tabindex="-1"><a class="header-anchor" href="#查看redis版本信息" aria-hidden="true">#</a> 查看redis版本信息</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>redis-server <span class="token parameter variable">--version</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="数据库命令" tabindex="-1"><a class="header-anchor" href="#数据库命令" aria-hidden="true">#</a> 数据库命令</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>redis-cli  <span class="token comment">#客户端连接redis</span>
<span class="token keyword">select</span> <span class="token number">0</span> <span class="token comment">#连接第一个db，默认16个db</span>
keys * <span class="token comment">#查询当前所有key，老版本默认为3个，新版本6.x为0个</span>
keys k* <span class="token comment">#查询当前db中k开头的key，老版本为k?</span>
flushdb <span class="token comment">#清空当前db中的所有k-v</span>
flushall <span class="token comment">#清空所有db中的k-v</span>
dbsize <span class="token comment">#查询当前db中k-v的数量</span>
exists key <span class="token comment"># 查询当前key是否在db中</span>
MOVE key db<span class="token comment"># 将当前数据库的 key 移动到给定的数据库 db 当中，若当前数据库(源数据库)和给定数据库(目标数据库)有相同名字的给定 key ，或者 key 不存在于当前数据库，那么 MOVE 没有任何效果。</span>
expire key 秒钟<span class="token comment"># 给当前key设定过期时间</span>
ttl key <span class="token comment"># 查看当前key还有多少秒过期，-1表示永不过期，-2表示已过期。过期就会被移除db</span>
<span class="token builtin class-name">type</span> key <span class="token comment"># 查看你的key是什么类型</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="string类型命令" tabindex="-1"><a class="header-anchor" href="#string类型命令" aria-hidden="true">#</a> String类型命令</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>set/get/del/apped/strlen <span class="token comment"># 和Java中类似</span>
incr key <span class="token comment"># 自减1</span>
decr key <span class="token comment"># 自减1</span>
incrby key num <span class="token comment">#自增num</span>
decrby key num <span class="token comment">#自减num</span>
<span class="token comment"># 切记，上述四个命令，一定要是数字才能够进行加键</span>

getrange/setrange key offset <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token comment"># 部分字符的获取/替换，offset0~-1表全部</span>
setex<span class="token punctuation">(</span>set with expire<span class="token punctuation">)</span>键秒值<span class="token comment"># 将键 key 的值设置为 value ， 并将键 key 的生存时间设置为 seconds 秒钟。</span>
setnx<span class="token punctuation">(</span>set <span class="token keyword">if</span> not exist<span class="token punctuation">)</span> <span class="token comment"># 只在键 key 不存在的情况下，才将键 key 的值设置为 value 。</span>

meset/mget/msetnx <span class="token comment">#批量set、批量get</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="list类型命令" tabindex="-1"><a class="header-anchor" href="#list类型命令" aria-hidden="true">#</a> List类型命令</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>lpush/rpush/lrange <span class="token comment"># lpush先进后出(头插法)，rpush先进先出(尾插法)，</span>
lpop/rpop <span class="token comment"># lpop删除头元素，rpop删除尾元素</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="docker容器部署redis" tabindex="-1"><a class="header-anchor" href="#docker容器部署redis" aria-hidden="true">#</a> Docker容器部署Redis</h2><p>使用交互式命令进入docker内部</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> redis /bin/bash
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h1 id="十八、发布与订阅" tabindex="-1"><a class="header-anchor" href="#十八、发布与订阅" aria-hidden="true">#</a> 十八、发布与订阅</h1><p>进程间的一种消息通信模式：<strong>发送者发送消息，订阅者接收消息。</strong></p><figure><img src="/assets/image-20210413102114363-GhwxI2-N.png" alt="image-20210413102114363" tabindex="0" loading="lazy"><figcaption>image-20210413102114363</figcaption></figure><hr><h1 id="十九、面试题" tabindex="-1"><a class="header-anchor" href="#十九、面试题" aria-hidden="true">#</a> 十九、面试题</h1><h2 id="_1、基本数据类型-你还知道其他redis的类型吗-你是怎么应用这几个数据类型的" tabindex="-1"><a class="header-anchor" href="#_1、基本数据类型-你还知道其他redis的类型吗-你是怎么应用这几个数据类型的" aria-hidden="true">#</a> 1、基本数据类型，你还知道其他redis的类型吗？你是怎么应用这几个数据类型的？</h2><p><strong>Ps：</strong></p><ul><li>命令是不区分大小写的，而key是区分大小写的。</li><li>帮助手册<code>help @命令</code></li></ul><p>//基本五个</p><ul><li><p>string(点赞、喜欢、阅读数)</p><ul><li><img src="/assets/image-20210413115527545-vtQXgYRB.png" alt="image-20210413115527545" tabindex="0" loading="lazy"><figcaption>image-20210413115527545</figcaption></li></ul></li><li><p>list</p><ul><li>微信订阅号</li></ul></li><li><p>hash</p><ul><li><code>Map&lt;String, Map&lt;Object,Object&gt;&gt;</code></li><li>可以做购物车</li></ul></li><li><p>set</p><ul><li>微信抽奖小程序 <ul><li>随机返回一个<code>srandmember xxx 1</code></li><li>随机抽两个二等奖<code>spop xxx 2</code></li><li><img src="/assets/image-20210413121728119-UZ37wpMl.png" alt="image-20210413121728119" tabindex="0" loading="lazy"><figcaption>image-20210413121728119</figcaption></li></ul></li><li>微信朋友圈点赞 <ul><li><img src="/assets/image-20210413122002566-YXYKQw4V.png" alt="image-20210413122002566" tabindex="0" loading="lazy"><figcaption>image-20210413122002566</figcaption></li></ul></li><li>微博好友关系社交关系 <ul><li>共同关注~~~~取交集<code>sinter xx xxx</code></li></ul></li><li>QQ内推可能认识的人 <ul><li>两个好友取差集<code>sdiff xx xx1</code></li></ul></li></ul></li><li><p>zset</p><ul><li>抖音热搜 <ul><li><img src="/assets/image-20210413123157672-AHSu5Jud.png" alt="image-20210413123157672" tabindex="0" loading="lazy"><figcaption>image-20210413123157672</figcaption></li></ul></li></ul></li></ul><p>//另外还有</p><ul><li>bitmap</li><li>HyperLogLog</li><li>Geo</li><li>Stream</li></ul><h2 id="_2、bigkey、hotkey的定义" tabindex="-1"><a class="header-anchor" href="#_2、bigkey、hotkey的定义" aria-hidden="true">#</a> 2、bigkey、hotkey的定义</h2><h3 id="bigkey" tabindex="-1"><a class="header-anchor" href="#bigkey" aria-hidden="true">#</a> bigkey</h3><p>大Key可以分为两种情况：</p><ul><li><code>Key的Value较大</code>，例如一个String类型的Key大小达到10MB，或者一个集合类型（Hash，List，Set等）的元素总大小达到了100MB。一般我们定义单个String类型的Key大小达到10KB，或者集合类型的Key总大小达到50MB，则定义其为大Key。</li><li><code>Key的元素较多</code>，例如一个Hash类型的Key，其元素数量达到了10000。一般我们定义集合类型的Key中元素超过5000个，则认为其为大Key。</li></ul><h4 id="bigkey会造成什么问题" tabindex="-1"><a class="header-anchor" href="#bigkey会造成什么问题" aria-hidden="true">#</a> bigkey会造成什么问题？</h4><ol><li><strong>客户端超时阻塞：</strong></li><li>**引发网络阻塞：**大key费流量</li><li>**阻塞工作线程：**del大key会阻塞工作线程</li><li>**内存分布不均：**集群模型在slot分片均匀情况下，会出现数据和查询倾斜情况，部分有大key的Redis节点占用内存多，QPS也会比较大。</li></ol><h3 id="hotkeys" tabindex="-1"><a class="header-anchor" href="#hotkeys" aria-hidden="true">#</a> hotkeys</h3><p>通常以一个Key被操作的频率和占用的资源来判定其是否为热Key，例如：</p><ul><li>某个集群实例一个分片每秒处理10000次请求，其中有3000次都是操作同一个Key。</li><li>某个集群实例一个分片的总带宽使用（入带宽+出带宽）为100Mbits/s，其中80Mbits是由于对某个Hash类型的Key执行HGETALL所占用。</li></ul><h2 id="_3、如何排查redis的bigkey、hotkey" tabindex="-1"><a class="header-anchor" href="#_3、如何排查redis的bigkey、hotkey" aria-hidden="true">#</a> 3、如何排查Redis的bigkey、hotkey？</h2><h3 id="查找bigkey" tabindex="-1"><a class="header-anchor" href="#查找bigkey" aria-hidden="true">#</a> 查找bigkey</h3><h4 id="_1、redis-cli" tabindex="-1"><a class="header-anchor" href="#_1、redis-cli" aria-hidden="true">#</a> 1、redis-cli</h4><p>Redis 可以在执行 <code>redis-cli</code> 命令时带上 <code>–-bigkeys</code> 选项，进而对整个数据库中的键值对大小情况进行统计分析。</p><p>程序使用<code>SCAN</code>命令，因此可以在不影响操作的情况下对繁忙的服务器执行。但是，可以使用-i选项来限制每个SCAN命令的扫描时间，以便控制扫描速度。</p><ol><li><p>在输出结果的第一部分中，每个新的大键（相同类型的）都会被报告，这些键的大小都比前面遇到的大键更大。</p></li><li><p>总结部分会输出每种数据类型中最大的 bigkey 的信息，对于 String 类型来说，会输出最大 bigkey 的字节长度，对于集合类型来说，会输出最大 bigkey 的元素个数。</p></li></ol><p>**缺点：**bigkeys仅能分析并输入六种数据类型（STRING、LIST、HASH、SET、ZSET、STREAM）</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ redis-cli <span class="token parameter variable">--bigkeys</span>

<span class="token comment"># Scanning the entire keyspace to find biggest keys as well as</span>
<span class="token comment"># average sizes per key type.  You can use -i 0.01 to sleep 0.01 sec</span>
<span class="token comment"># per SCAN command (not usually needed).</span>
<span class="token comment"># 在输出结果的第一部分中，每个新的大键（相同类型的）都会被报告，这些键的大小都比前面遇到的大键更大。</span>
<span class="token punctuation">[</span>00.00%<span class="token punctuation">]</span> Biggest string found so far <span class="token string">&#39;key-419&#39;</span> with <span class="token number">3</span> bytes
<span class="token punctuation">[</span>05.14%<span class="token punctuation">]</span> Biggest list   found so far <span class="token string">&#39;mylist&#39;</span> with <span class="token number">100004</span> items
<span class="token punctuation">[</span><span class="token number">35.77</span>%<span class="token punctuation">]</span> Biggest string found so far <span class="token string">&#39;counter:__rand_int__&#39;</span> with <span class="token number">6</span> bytes
<span class="token punctuation">[</span><span class="token number">73.91</span>%<span class="token punctuation">]</span> Biggest <span class="token builtin class-name">hash</span>   found so far <span class="token string">&#39;myobject&#39;</span> with <span class="token number">3</span> fields

-------- summary -------

Sampled <span class="token number">506</span> keys <span class="token keyword">in</span> the keyspace<span class="token operator">!</span>
Total key length <span class="token keyword">in</span> bytes is <span class="token number">3452</span> <span class="token punctuation">(</span>avg len <span class="token number">6.82</span><span class="token punctuation">)</span>

Biggest string found <span class="token string">&#39;counter:__rand_int__&#39;</span> has <span class="token number">6</span> bytes
Biggest   list found <span class="token string">&#39;mylist&#39;</span> has <span class="token number">100004</span> items
Biggest   <span class="token builtin class-name">hash</span> found <span class="token string">&#39;myobject&#39;</span> has <span class="token number">3</span> fields

<span class="token number">504</span> strings with <span class="token number">1403</span> bytes <span class="token punctuation">(</span><span class="token number">99.60</span>% of keys, avg size <span class="token number">2.78</span><span class="token punctuation">)</span>
<span class="token number">1</span> lists with <span class="token number">100004</span> items <span class="token punctuation">(</span>00.20% of keys, avg size <span class="token number">100004.00</span><span class="token punctuation">)</span>
<span class="token number">0</span> sets with <span class="token number">0</span> members <span class="token punctuation">(</span>00.00% of keys, avg size <span class="token number">0.00</span><span class="token punctuation">)</span>
<span class="token number">1</span> hashs with <span class="token number">3</span> fields <span class="token punctuation">(</span>00.20% of keys, avg size <span class="token number">3.00</span><span class="token punctuation">)</span>
<span class="token number">0</span> zsets with <span class="token number">0</span> members <span class="token punctuation">(</span>00.00% of keys, avg size <span class="token number">0.00</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2、使用scan命令来寻找大key" tabindex="-1"><a class="header-anchor" href="#_2、使用scan命令来寻找大key" aria-hidden="true">#</a> 2、使用Scan命令来寻找大key</h4><h4 id="_3、redis-rdb-tools" tabindex="-1"><a class="header-anchor" href="#_3、redis-rdb-tools" aria-hidden="true">#</a> 3、redis-rdb-tools</h4><p>分析Redis RDB快照文件的开源工具。可以根据需求自定义分析Redis实例中所有Key的内存占用情况。</p><ol><li>需要提前导出实例的rdb文件，该方法时效性相较于在线分析来说较差，优势在于完全不影响现有业务。</li></ol><h3 id="查找hotkey" tabindex="-1"><a class="header-anchor" href="#查找hotkey" aria-hidden="true">#</a> 查找HotKey</h3><p><strong>1、在逻辑层面：</strong></p><ol><li>凭借业务经验，预估出哪些key是热点key。 <ul><li>优点：简单，凭经验发现热 <code>Key</code>，提早发现提早处理；</li><li>缺点：没有办法预测所有热 <code>Key</code> 出现，比如某些热点新闻事件，无法提前预测。</li></ul></li></ol><p><strong>2、在客户端层面：</strong></p><ul><li>一般我们在连接 <code>Redis</code> 服务器时都要使用专门的 SDK（比如：<code>Java</code> 的客户端工具 <code>Jedis</code>、<code>Redisson</code>），我们可以对客户端工具进行封装，在发送请求前进行收集采集，同时定时把收集到的数据上报到统一的服务进行聚合计算。</li></ul><p><strong>3、在proxy层面：</strong></p><ul><li>如果所有的 <code>Redis</code> 请求都经过 <code>Proxy</code>（代理）的话，可以考虑改动 <code>Proxy</code> 代码进行收集，思路与客户端基本类似。</li></ul><figure><img src="/assets/725429-20190516112209464-1290077151-roRyio9Q.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><strong>4、在redis层面：</strong></p><ol><li><p><code>redis-cli</code>提供了<code>hotkeys</code>参数，可以快速帮您找出业务中的热Key，该命令需要在业务实际运行期间执行，以统计运行期间的热Key。</p><ol><li>由于需要扫描整个 <code>keyspace</code>，实时性上比较差;</li><li>扫描时间与 <code>key</code> 的数量正相关，如果 <code>key</code> 的数量比较多，耗时可能会非常长。</li></ol></li><li><p><code>使用Redis扩展</code>：有一些Redis扩展可以用于自动检测和处理Hotkey。例如，Redisson扩展可以自动检测Hotkey并使用LRU算法进行清理。</p></li><li><p>使用<code>redis-cli monitor</code>来监听redis的所有命令，之后对命令进行过滤，得到跟get相关的命令，之后统计出热点key。</p><ol><li><p><code>redis-cli monitor | grep &quot;get&quot;</code></p><figure><img src="/assets/image-20230419203005705-vt6T9yX8.png" alt="image-20230419203005705" tabindex="0" loading="lazy"><figcaption>image-20230419203005705</figcaption></figure></li><li><p>缺点：该命令在高并发的条件下，有内存增暴增的隐患，还会降低 <code>Redis</code> 的性能。</p></li></ol></li></ol><p><strong>5、网络数据抓包分析：</strong></p><p><code>Redis</code> 客户端使用 <code>TCP</code> 协议与服务端进行交互，通信协议采用的是 <code>RESP</code> 协议。自己写程序监听端口，按照 <code>RESP</code> 协议规则解析数据，进行分析。或者我们可以使用一些抓包工具，比如 <code>tcpdump</code> 工具，抓取一段时间内的流量进行解析。</p><ul><li>优点：对 <code>SDK</code> 或者 <code>Proxy</code> 代理层没有入侵；</li><li>缺点： <ul><li>有一定的开发成本；</li><li>热 <code>Key</code> 节点的网络流量和系统负载已经比较高了，抓包可能会导致情况进一步恶化。</li></ul></li></ul><h2 id="_4、如何解决bigkey以及hotkey问题" tabindex="-1"><a class="header-anchor" href="#_4、如何解决bigkey以及hotkey问题" aria-hidden="true">#</a> 4、如何解决bigkey以及hotkey问题</h2><h3 id="bigkey-1" tabindex="-1"><a class="header-anchor" href="#bigkey-1" aria-hidden="true">#</a> bigkey</h3><p>要解决Big Key问题，无非就是<code>减小key对应的value值的大小</code>，也就是对于String数据结构的话，减少存储的字符串的长度；对于List、Hash、Set、ZSet数据结构则是减少集合中元素的个数。</p><ol><li><strong>对大Key进行拆分</strong><ul><li>将一个Big Key拆分为多个key-value这样的小Key，并确保每个key的成员数量或者大小在合理范围内，然后再进行存储，通过get不同的key或者使用mget批量获取。</li></ul></li><li><strong>压缩value</strong><ul><li>使用序列化、压缩算法将key的大小控制在合理范围内，但是需要注意序列化、反序列化都会带来一定的消耗。如果压缩后，value还是很大，那么可以进一步对key进行拆分。</li></ul></li><li>对大Key进行清理 <ul><li>对Redis中的大Key进行清理，从Redis中删除此类数据。</li><li>Redis4.0之前使用<code>del</code>删除大key</li><li>Redis自4.0起提供了<code>UNLINK</code>命令，该命令能够<code>以非阻塞的方式缓慢逐步的清理传入的Key</code>，通过UNLINK，你可以安全的删除大Key甚至特大Key。</li></ul></li><li>定期清理失效数据 <ul><li>如果某个Key有业务不断以增量方式写入大量的数据，并且忽略了其时效性，这样会导致大量的失效数据堆积。可以通过定时任务的方式，对失效数据进行清理。</li></ul></li></ol><h3 id="hotkey" tabindex="-1"><a class="header-anchor" href="#hotkey" aria-hidden="true">#</a> hotkey</h3><ol><li><p>使用读写分离</p><ol><li>如果热key主要是读流量大</li></ol></li><li><p><strong>使用客户端缓存/本地缓存(二级缓存)(Ehcache/HashMap)</strong></p><ol><li>当发现热key之后，将热key加载到JVM中，针对这种热key请求，会直接从jvm中取，而不会走到redis层。假设此时有十万个针对同一个key的请求过来,如果没有本地缓存，这十万个请求就直接怼到同一台redis上了。现在假设，你的应用层有50台机器，OK，你也有jvm缓存了。这十万个请求平均分散开来，每个机器有2000个请求，会从JVM中取到value值，然后返回数据。避免了十万个请求怼到同一台redis上的情形。</li><li>注意两个问题： <ol><li>如果对热 <code>Key</code> 进行本地缓存，需要防止本地缓存过大，影响系统性能；</li><li>需要处理本地缓存和 <code>Redis</code> 集群数据的一致性问题。</li></ol></li></ol></li><li><p>增加redis实例数量</p><ol><li>对于出现热 <code>Key</code> 的 <code>Redis</code> 实例，我们可以通过水平扩容增加副本数量，将读请求的压力分担到不同副本节点上。</li></ol></li><li><p>热key备份</p><ol><li><p>那么如何将对某个热 <code>Key</code> 的请求打散到不同实例上呢？我们就可以通过热 <code>Key</code> 备份的方式，基本的思路就是，我们可以给热 <code>Key</code> 加上前缀或者后缀，把一个热 <code>Key</code> 的数量变成 <code>Redis</code> 实例个数 <code>N</code> 的倍数 <code>M</code>，从而由访问一个 <code>Redis</code> <code>Key</code> 变成访问 <code>N * M</code> 个 <code>Redis</code> <code>Key</code>。 <code>N * M</code> 个 <code>Redis</code> <code>Key</code> 经过分片分布到不同的实例上，将访问量均摊到所有实例。</p></li><li><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">// N 为 Redis 实例个数，M 为 N 的 2倍</span>
const M <span class="token operator">=</span> N <span class="token operator">*</span> <span class="token number">2</span>
<span class="token comment">//生成随机数</span>
random <span class="token operator">=</span> GenRandom<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> M<span class="token punctuation">)</span>
<span class="token comment">//构造备份新 Key</span>
bakHotKey <span class="token operator">=</span> hotKey <span class="token operator">+</span> <span class="token string">&quot;_&quot;</span> <span class="token operator">+</span> random
<span class="token keyword">data</span> <span class="token operator">=</span> redis<span class="token punctuation">.</span>GET<span class="token punctuation">(</span>bakHotKey<span class="token punctuation">)</span>
<span class="token keyword">if</span> <span class="token keyword">data</span> <span class="token operator">=</span><span class="token operator">=</span> <span class="token boolean">NULL</span> {
    <span class="token keyword">data</span> <span class="token operator">=</span> redis<span class="token punctuation">.</span>GET<span class="token punctuation">(</span>hotKey<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token keyword">data</span> <span class="token operator">=</span><span class="token operator">=</span> <span class="token boolean">NULL</span> {
        <span class="token keyword">data</span> <span class="token operator">=</span> GetFromDB<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token comment">// 可以利用原子锁来写入数据保证数据一致性</span>
        redis<span class="token punctuation">.</span><span class="token keyword">SET</span><span class="token punctuation">(</span>hotKey<span class="token punctuation">,</span> <span class="token keyword">data</span><span class="token punctuation">,</span> expireTime<span class="token punctuation">)</span>
        redis<span class="token punctuation">.</span><span class="token keyword">SET</span><span class="token punctuation">(</span>bakHotKey<span class="token punctuation">,</span> <span class="token keyword">data</span><span class="token punctuation">,</span> expireTime <span class="token operator">+</span> GenRandom<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    } <span class="token keyword">else</span> {
        redis<span class="token punctuation">.</span><span class="token keyword">SET</span><span class="token punctuation">(</span>bakHotKey<span class="token punctuation">,</span> <span class="token keyword">data</span><span class="token punctuation">,</span> expireTime <span class="token operator">+</span> GenRandom<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这段代码中，通过一个大于等于 <code>1</code> 小于 <code>M</code> 的随机数，得到一个 <code>bakHotKey</code>，程序会优先访问 <code>bakHotKey</code>，在得不到数据的情况下，再访问原来的 <code>hotkey</code>，并将 <code>hotkey</code> 的内容写回 <code>bakHotKey</code>。值得注意的是，<code>bakHotKey</code> 的过期时间是 <code>hotkey</code> 的过期时间加上一个较小的随机正整数，这是通过坡度过期的方式，保证在 <code>hotkey</code> 过期时，所有 <code>bakHotKey</code> 不会同时过期而造成缓存雪崩。</p></li></ol></li><li><p>设计熔断/降级机制</p></li></ol><h2 id="_5、个人觉得redis中比较惊艳的地方" tabindex="-1"><a class="header-anchor" href="#_5、个人觉得redis中比较惊艳的地方" aria-hidden="true">#</a> 5、个人觉得Redis中比较惊艳的地方？</h2><h3 id="sds会默认会创建-0-10000的共享对象" tabindex="-1"><a class="header-anchor" href="#sds会默认会创建-0-10000的共享对象" aria-hidden="true">#</a> SDS会默认会创建 0~10000的共享对象</h3><blockquote><p>这一点可以和Java中的<em>IntegerCache</em>进行类比</p><p><strong>Byte，Short，Integer, Long 的缓存池范围默认都是: -128 到 127</strong></p></blockquote><p><code>set k2 123</code></p><p>当字符串键值的内容可以用一个64位有符号整形来表示时，Redis会将键值转化为long型来进行存储，此时即对应 OBJ_ENCODING_INT 编码类型。内部的内存结构表示如下:</p><figure><img src="/assets/image-20230906142623661-0inmzprf.png" alt="image-20230906142623661" tabindex="0" loading="lazy"><figcaption>image-20230906142623661</figcaption></figure><p>Redis 启动时会预先建立 10000 个分别存储 0~9999 的 redisObject 变量作为共享对象，这就意味着如果 set字符串的键值在 0~10000 之间的话，则可以 直接指向共享对象 而不需要再建立新对象，此时键值不占空间！</p><figure><img src="/assets/image-20230906142643556-2tC1AEOD.png" alt="image-20230906142643556" tabindex="0" loading="lazy"><figcaption>image-20230906142643556</figcaption></figure><p>redis源代码：object.c</p><figure><img src="/assets/image-20230906142711048-uiaPINDx.png" alt="image-20230906142711048" tabindex="0" loading="lazy"><figcaption>image-20230906142711048</figcaption></figure><figure><img src="/assets/image-20230906142745070-lzZjj_xg.png" alt="image-20230906142745070" tabindex="0" loading="lazy"><figcaption>image-20230906142745070</figcaption></figure><h2 id="_6、redis中的各个组成部分的关系" tabindex="-1"><a class="header-anchor" href="#_6、redis中的各个组成部分的关系" aria-hidden="true">#</a> 6、Redis中的各个组成部分的关系</h2><p>简单来说就是</p><ol><li><p>启动redis之后，就会有一个<code>redisServer</code>这样的一个结构体</p><ol><li>默认包含16个<code>redisDB</code></li></ol></li><li><p><code>redisDB</code>对应redis的一个数据库</p><ol><li><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">redisDB</span><span class="token punctuation">{</span>
    dict <span class="token operator">*</span>dict<span class="token punctuation">;</span>
    dict <span class="token operator">*</span>expires<span class="token punctuation">;</span> <span class="token comment">// 定时删除就是扫描这个dict</span>
    dict <span class="token operator">*</span>blocking_keys<span class="token punctuation">;</span>
    dict <span class="token operator">*</span>ready_keys<span class="token punctuation">;</span>
    dict <span class="token operator">*</span>watched_keys<span class="token punctuation">;</span>
    <span class="token keyword">int</span> id<span class="token punctuation">;</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> avg_ttl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol></li><li><p>每个<code>dict</code>对应一个字典</p><ol><li><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">dict</span><span class="token punctuation">{</span>
    dictType <span class="token operator">*</span>type<span class="token punctuation">;</span> <span class="token comment">// 哈希表类型(存储普通键、存储过期键等)</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">;</span>
    dictht ht<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 数组(长度为2)便于哈希表扩容</span>
    <span class="token keyword">int</span> rehashindex<span class="token punctuation">;</span> <span class="token comment">//不等于-1的时候会扩容</span>
    <span class="token keyword">int</span> iterators<span class="token punctuation">;</span> <span class="token comment">// 正在遍历该hash表的迭代器数量(有正在遍历的迭代器时不能扩容)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol></li><li><p><code>dictht</code>是<code>dict</code>字段的哈希表部分</p><ol><li><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">dictht</span><span class="token punctuation">{</span>
    dictEntry <span class="token operator">*</span><span class="token operator">*</span>table<span class="token punctuation">;</span> <span class="token comment">// 相当于dictEntry[][] table</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> size<span class="token punctuation">;</span> <span class="token comment">// 数量</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> sizemask<span class="token punctuation">;</span> <span class="token comment">//计算哈希桶的掩码</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> used<span class="token punctuation">;</span> <span class="token comment">// 用了多少？</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol></li><li><p><code>dicEntry</code>是redis中具体的<code>&lt;key , value&gt;</code></p><ol><li><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">dicEntry</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>vak<span class="token punctuation">;</span>
    dicEntry <span class="token operator">*</span>next<span class="token punctuation">;</span> <span class="token comment">//链表，解决hash冲突</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><figure><img src="/assets/image-20230908112025614-7s6idkPp.png" alt="image-20230908112025614" tabindex="0" loading="lazy"><figcaption>image-20230908112025614</figcaption></figure></li></ol></li><li><p><code>dicEntry</code>中的<code>value</code>对应的就是一个<code>redisObject</code></p><ol><li><p><code>redisObject</code>是redis中所有数据类型的父类</p></li><li><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">redisObject</span><span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> type<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment">// 数据类型</span>
    <span class="token keyword">unsigned</span> notused<span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">;</span> 
    <span class="token keyword">unsigned</span> encoding<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment">// 编码类型</span>
    <span class="token keyword">unsigned</span> lru<span class="token operator">:</span> <span class="token number">22</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> refcount<span class="token punctuation">;</span> <span class="token comment">// 引用计数</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span> <span class="token comment">// 指向底层数据结构的指针</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol></li></ol><figure><img src="/assets/3c386666e4e7638a07b230ba14b400fe-Lo-tWGt4.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h2 id="_7、redis中是如何解决hash碰撞的-和hashmap有什么区别" tabindex="-1"><a class="header-anchor" href="#_7、redis中是如何解决hash碰撞的-和hashmap有什么区别" aria-hidden="true">#</a> 7、Redis中是如何解决hash碰撞的？和HashMap有什么区别？</h2><p><code>拉链法</code></p><ol><li>Redis中并没有采用红黑树来解决链表长度过长导致的时间复杂度过高。 <ol><li>这是因为redis对内存极为敏感，而维护大量红黑树会导致内存占用过高。</li></ol></li></ol><p>还有一个地方不一样：<code>Redis中哈希表扩容与HashMap不一样</code></p><ol><li>Redis中哈希表扩容是渐进转移的。</li><li>而HashMap中扩容是一次性转移完成。</li></ol><h2 id="_8、渐进式rehash" tabindex="-1"><a class="header-anchor" href="#_8、渐进式rehash" aria-hidden="true">#</a> 8、渐进式rehash</h2><p><strong>Redis</strong>中的数据存储在字典<strong>dict</strong>数据结构中，一个<strong>dict</strong>数据结构持有两张哈希表<strong>dictht</strong>，每张<strong>dictht</strong>中持有一个存储数据的<strong>dictEntry</strong>数组，每份数据会以键值对的形式封装成一个<strong>dictEntry</strong>节点然后添加到<strong>dictEntry</strong>数组中，当存在哈希冲突时，<strong>Redis</strong>中使用拉链法解决哈希冲突，但是<strong>dictEntry</strong>数组的默认容量为4，发生哈希冲突的概率极高，如果不进行扩容，会导致哈希表的时间复杂度恶化为<code>O(logN)</code>，所以满足一定条件时，需要进行<strong>dictEntry</strong>数组的扩容，即进行<strong>Redis</strong>的扩容。</p><p><code>Redis的扩容的时机总结如下：</code></p><ul><li>如果没有<code>fork</code>子进程在执行<strong>RDB</strong>或者<strong>AOF</strong>的持久化，一旦满足<code>ht[0].used &gt;= ht[0].size</code>，此时触发扩容； <ul><li><strong>当负载因子大于等于 1 ，并且 Redis 没有在执行 bgsave 命令或者 bgrewiteaof 命令，也就是没有执行 RDB 快照或没有进行 AOF 重写的时候，就会进行 rehash 操作。</strong></li></ul></li><li>如果有<code>fork</code>子进程在执行<strong>RDB</strong>或者<strong>AOF</strong>的持久化时，则需要满足<code>ht[0].used &gt; 5 * ht[0].size</code>，此时触发扩容。 <ul><li><strong>当负载因子大于等于 5 时，此时说明哈希冲突非常严重了，不管有没有有在执行 RDB 快照或 AOF 重写，都会强制进行 rehash 操作。</strong></li></ul></li></ul><p><strong>Redis</strong>的<strong>dict</strong>数据结构通常只会使用两张哈希表中的其中一张，，即<strong>ht[0]</strong>，但是当需要进行扩容时，此时会使用到<strong>dict</strong>的另外一张哈希表<strong>ht[1]</strong>，<strong>Redis</strong>的扩容步骤如下所示。</p><ul><li>计算<strong>ht[1]<strong>的容量</strong>size</strong>，即扩容后的容量，<mark>**ht[1]**的容量为大于等于<code>ht[0].used * 2</code>且同时为2的幂次方的最小值；</mark></li><li>为<strong>ht[1]<strong>设置</strong>size</strong>，<strong>sizemask</strong>字段的值，初始化<strong>used</strong>字段为0，并为<strong>dictEntry</strong>数组分配空间；</li><li>将<strong>dict</strong>的<strong>rehashidx</strong>字段设置为0，表示此时开启渐进式<strong>rehash</strong>，<strong>Redis</strong>会通过渐进式<strong>rehash</strong>的方式逐步将<strong>ht[0]<strong>上的</strong>dictEntry</strong>以哈希桶为单位逐次迁移到**ht[1]**上；</li><li>当<strong>ht[0]<strong>的所有键值对全部存放到</strong>ht[1]<strong>中后，释放</strong>ht[0]<strong>的内存空间，然后</strong>ht[1]<strong>变为</strong>ht[0]</strong>。</li></ul><p>当<strong>dict</strong>中键值对特别多时，<strong>rehash</strong>会特别耗时，所以<strong>Redis</strong>采用一种渐进式<strong>rehash</strong>的方式来完成扩容，<strong>dict</strong>中的<strong>rehashidx</strong>字段用于记录当前已经<strong>rehash</strong>到的哈希桶的索引，而渐进式<strong>rehash</strong>就是<strong>Redis</strong>不会一次性将**ht[0]<strong>上的键值对迁移到</strong>ht[1]**上，而是会在某些时间点迁移一部分，这些时间点如下所示。</p><ul><li>当对数据进行增删改查时会从**ht[0]<strong>迁移一个哈希桶到</strong>ht[1]**上；</li><li><strong>Redis</strong>会定时的从**ht[0]<strong>迁移一部分哈希桶到</strong>ht[1]**上。</li></ul><p>特别注意，如果在渐进式<strong>rehash</strong>的过程中有新的键值对添加，那么会直接添加到**ht[1]**中。</p><blockquote><p>自我理解：</p><p>渐进式rehash就是一步一步的将所有的哈希槽都转移到新的哈希表中。</p><ol><li>dict中的<code>rehashIndex</code>表示<code>ht[0]</code>中正在顺序遍历的位置，客户端每次进行增删改查操作时，都会按顺序迁移一个哈希桶（或哈希槽）的键值对到 <code>ht[1]</code> 中，然后将 <code>rehashidx</code> 递增。</li></ol></blockquote><h2 id="_9、innodb为什么选择使用b-树而不是跳表-redis为什么选择调表而不是b-树" tabindex="-1"><a class="header-anchor" href="#_9、innodb为什么选择使用b-树而不是跳表-redis为什么选择调表而不是b-树" aria-hidden="true">#</a> 9、Innodb为什么选择使用B+树而不是跳表，Redis为什么选择调表而不是B+树？</h2><blockquote><p>为什么不用红黑树？</p><ol><li>实现比较复杂</li><li>红黑树范围查询没有跳表进行范围查询那么方便。</li></ol></blockquote><h3 id="b-树和跳表相同之处" tabindex="-1"><a class="header-anchor" href="#b-树和跳表相同之处" aria-hidden="true">#</a> B+树和跳表相同之处</h3><ul><li>B+树和跳表都是在最底层包含所有用户数据,并且都是按顺序排列,时候范围查询</li><li>B+树和跳表利用索引层实现二叉查看，从而提高性能</li></ul><h3 id="不同之处" tabindex="-1"><a class="header-anchor" href="#不同之处" aria-hidden="true">#</a> 不同之处</h3><p><strong>数据读取</strong></p><ul><li>B+ 树是多路平衡搜索树，三层高度即可容纳2kw左右的数据，相同情况下，跳表则需要大约24层，假设层高对应磁盘IO，那么B+树的读性能会比跳表要好，因此Innodb选择了B+树做索引。</li><li>redis读写全在内存中，不涉及磁盘IO，无需考虑索引层高度，同时由于跳表实现起来更加简单，相比B+ tree而言，少了选择树结构的开销，因此redis使用跳表来实现zset,而不是B+ tree。</li></ul><blockquote><p>换句话说，就是Redis操作的是内存，不需要操作磁盘IO，要知道磁盘读取和内存读取相差百万倍。而MySQL需要找到节省IO的数据结构。</p><p>这个问题在于Redis是直接操作内存的，并不需要磁盘io而MySQL需要去读取io，MySQL要使用b+树的方式减少磁盘io，B+树的原理是 叶子节点存储数据，非叶子节点存储索引，每次读取磁盘页时就会读取一整个节点,每个叶子节点还有指向前后节点的指针，为的是最大限度的降低磁盘的IO;因为数据在内存中读取耗费的时间是从磁盘的IO读取的百万分之一。</p><p>而Redis是 内存中读取数据，不涉及IO，因此使用了跳表，跳表明显是更快更简单的方式。</p></blockquote><p><strong>数据写入</strong></p><ul><li>B+树需要频繁拆分、合并数据页。</li><li>跳表则是独立插入，并且根据随机函数来确定层数，没有旋转和维持平衡带来的开销。跳表的性能比B+树要好的多。</li></ul></div><!--[--><!----><!--]--><footer class="page-meta"><!----><div class="meta-item git-info"><div class="update-time"><span class="label">上次编辑于: </span><!----></div><div class="contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: 554417388@qq.com">honyelchak</span><!--]--><!--]--></div></div></footer><nav class="vp-page-nav"><a aria-label="/interview/A3-数据库/Redis/缓存更新策略" class="vp-link nav-link prev nav-link prev" href="/interview/A3-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5.html"><div class="hint"><span class="arrow start"></span>上一页</div><div class="link"><!---->/interview/A3-数据库/Redis/缓存更新策略</div></a><!----></nav><!----><!--[--><!----><!--]--><!--]--></main><!--]--><footer class="vp-footer-wrapper"><!----><div class="vp-copyright">Copyright © 2023 Honyelchak</div></footer></div><!--]--><!----><!----><!--]--></div>
    <script type="module" src="/assets/app-_dQeDwys.js" defer></script>
  </body>
</html>
