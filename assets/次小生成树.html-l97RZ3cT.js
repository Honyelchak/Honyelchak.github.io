import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as a,c as i,f as d}from"./app-XffPLay1.js";const o={},t=d('<h1 id="次小生成树" tabindex="-1"><a class="header-anchor" href="#次小生成树" aria-hidden="true">#</a> 次小生成树</h1><blockquote><p>定义：给一个带权的图，把图的所有生成树俺权值从小到大排序，第二小的称为次小生成树。</p></blockquote><h3 id="分类" tabindex="-1"><a class="header-anchor" href="#分类" aria-hidden="true">#</a> 分类</h3><p>按照权值是否严格大于最小生成树又分为：</p><ul><li>不严格次小生成树</li><li>严格次小生成树</li></ul><h3 id="方法一" tabindex="-1"><a class="header-anchor" href="#方法一" aria-hidden="true">#</a> 方法一：</h3><p>先求最小生成树，在枚举删去最小生成树中的边求解。时间复杂度为O(mlogm + nm)</p><p>不能求严格次小生成树。</p><h3 id="方法二" tabindex="-1"><a class="header-anchor" href="#方法二" aria-hidden="true">#</a> 方法二：</h3><p>先求最小生成树，然后依次枚举非树边，然后将该边加入树中，同时从树中去掉一条边，使得最终的图仍是一颗生成树。则一定可以求出次小生成树。</p><p>设T为图G的一棵生成树，对于非树边a和树边b，插入边a，并删除边b的操作记为(+a, -b)。如果T + a - b 之后，仍然时一颗生成树，称(+a,-b)是T的一个可行交换。称由T进行一次可行变换所得到的新的生成树集合称为T的邻集。</p><p>**定理：**次小生成树一定在最小生成树的邻集中。</p><ol><li>求最小生成树，统计标记每条边是树边，还是非树边；同时把最小生成树建立出来。</li><li>预处理任意两点间的边权最大值<code>dist[a][b]</code></li><li>依次枚举所有非树边，求<code>min(sum + w - dist[a][b])</code>,满足<code>w &gt; dist[a][b]</code></li></ol>',13),r=[t];function c(l,h){return a(),i("div",null,r)}const _=e(o,[["render",c],["__file","次小生成树.html.vue"]]);export{_ as default};
