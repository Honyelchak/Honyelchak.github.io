import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as a,c as l,f as o}from"./app-_dQeDwys.js";const i={},c=o('<h2 id="高并发" tabindex="-1"><a class="header-anchor" href="#高并发" aria-hidden="true">#</a> 高并发</h2><ol><li>在对一些业务日志写入数据库的时候，日期用了sdf的静态变量，有时候会报错或者日期乱掉。 <ol><li>觉得代码没问题，后来在网上查阅资料，包括翻看阿里Java手册</li><li></li></ol></li></ol><h2 id="阅读源码学到了什么" tabindex="-1"><a class="header-anchor" href="#阅读源码学到了什么" aria-hidden="true">#</a> 阅读源码学到了什么？</h2><ol><li>学习到了很多关于方法命名的技巧 <ol><li>在Spring/JDK源码的阅读中，我发现了实际干活的基本上都是以<code>doXXX</code>开头的，方法的包装一般都是以<code>XXX</code>开头的，比如说<code>doCreateBean</code>、<code>doGetBean</code></li></ol></li><li>能够把自己学到的基础知识利用上是最令人开心的、令人兴奋的。 <ol><li>阅读JDK源码的时候会发现，在方法中经常会把实例变量赋值给局部变量之后再进行操作，</li><li>后来我才知道<code>this.data</code>和<code>data</code>的区别，<code>this.data</code>是可以分为两部的 <ol><li>先将局部变量表的第一个slot(this)放到栈中</li><li>然后执行<code>getField ....</code>才能拿到值</li></ol></li></ol></li></ol><h1 id="三、总结" tabindex="-1"><a class="header-anchor" href="#三、总结" aria-hidden="true">#</a> 三、总结</h1><ol><li>我们经常会听到GC调优，实际不管什么垃圾回收器和回收算法，首先得理解垃圾回收原理，然后保证写出的代码没有问题，不然换垃圾回收器和算法都无法阻止内存溢出问题，加jvm大内存也只不过延迟出现问题时间；</li><li>擅于借助工具的使用，如果没有grafana监控后台、hulk的监控wonder后台、java自带工具、mat分析工具很难快速解决问题，在这里还推荐一个阿里的jvm监控工具Arthas，也是一个不错的选择</li><li>查看数据指标作为依据，不能凭空猜测和先入为主（由于当时先入为主，认为是服务器系统的问题而走了弯路，导致解决问题的时间延长），定位问题，还必须要知道java常见的问题和对应的数据指标现象，综合分析便能迅速找到原因。</li></ol><p>例如：</p><p>内存泄露：应用占用cpu高，运行一段时间，频繁fullGC，但不马上抛内存溢出；</p><p>死锁：应用占用cpu高，gc无明显异常，jstack 命令可以发现deadlock</p><p>OOM: 这个看日志就能看出来，线程过多unable to create Thread，堆溢出：java heap space</p><p>某线程占用cpu高： 通过top命令查找java线程占用cpu最高的， jstack命令分析线程栈信息</p><h3 id="伪共享" tabindex="-1"><a class="header-anchor" href="#伪共享" aria-hidden="true">#</a> 伪共享</h3><p>Netty 利用数组实现的自定义 SelectedSelectionKeySet 类型替换掉了 JDK 利用 HashSet 类型实现的 sun.nio.ch.SelectorImpl#selectedKeys。目的就是利用 CPU 缓存的优势来提高 IO 活跃的 SelectionKeys 集合的遍历性能。</p>',13),d=[c];function t(r,h){return a(),l("div",null,d)}const p=e(i,[["render",t],["__file","简历埋点.html.vue"]]);export{p as default};
