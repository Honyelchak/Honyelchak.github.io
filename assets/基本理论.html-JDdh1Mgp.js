import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as a,c as r,f as i}from"./app-XffPLay1.js";const d={},c=i('<h1 id="最小生成树" tabindex="-1"><a class="header-anchor" href="#最小生成树" aria-hidden="true">#</a> 最小生成树</h1><p>最小生成树部分最基本的两个算法：</p><ul><li>Prim算法</li><li>Kruskal算法</li></ul><p>可以用Prim的，一定可以用Kruskal算法。</p><p>最小生成树的理论基础：</p><ol><li>任意一颗最小生成树一定可以包含无向图中权值最小的边。</li><li>给定一张无向图<code>G=(v,e), n = |V|, m = |E|</code>。从<code>E</code>中选出<code>k &lt; n - 1</code>条边构成<code>G</code>的加一个生成森林。</li></ol><h2 id="prim算法" tabindex="-1"><a class="header-anchor" href="#prim算法" aria-hidden="true">#</a> Prim算法</h2><h3 id="朴素版本" tabindex="-1"><a class="header-anchor" href="#朴素版本" aria-hidden="true">#</a> 朴素版本</h3><p>维护一个数组，用</p><h3 id="堆优化版本" tabindex="-1"><a class="header-anchor" href="#堆优化版本" aria-hidden="true">#</a> 堆优化版本</h3><h2 id="kruskal算法" tabindex="-1"><a class="header-anchor" href="#kruskal算法" aria-hidden="true">#</a> Kruskal算法</h2><p>Kruskal算法不仅可以求所有边权之和最小、还可以求最大的边权最小。</p>',12),h=[c];function l(o,t){return a(),r("div",null,h)}const _=e(d,[["render",l],["__file","基本理论.html.vue"]]);export{_ as default};
