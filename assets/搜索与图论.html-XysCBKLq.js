import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as a,c as d,f as r}from"./app-XffPLay1.js";const i={},t=r('<h1 id="搜索与" tabindex="-1"><a class="header-anchor" href="#搜索与" aria-hidden="true">#</a> 搜索与</h1><h2 id="dfs" tabindex="-1"><a class="header-anchor" href="#dfs" aria-hidden="true">#</a> DFS</h2><p>深度优先(Depth-First)遍历</p><ul><li>回溯</li><li>剪枝</li></ul><p>每个DFS都对应一个搜索树</p><h2 id="bfs" tabindex="-1"><a class="header-anchor" href="#bfs" aria-hidden="true">#</a> BFS</h2><p>宽度优先(Breadth-First)遍历。</p><h2 id="树和图的深度优先遍历" tabindex="-1"><a class="header-anchor" href="#树和图的深度优先遍历" aria-hidden="true">#</a> 树和图的深度优先遍历</h2><p>树是一种特殊的图，与图的遍历方式相同。</p><p>对于无向图中的边ab，存储两条有向边<code>a -&gt; b</code>, <code>b -&gt; a</code></p><p>所以，我们可以只考虑有向图的存储。</p><ul><li>邻接矩阵：<code>g[a][b]</code>存储边<code>a -&gt; b</code></li><li>邻接表：</li></ul><p>深度优先遍历可以求出子树中节点的个数。</p><h2 id="树和图的广度优先遍历" tabindex="-1"><a class="header-anchor" href="#树和图的广度优先遍历" aria-hidden="true">#</a> 树和图的广度优先遍历</h2>',14),h=[t];function c(o,s){return a(),d("div",null,h)}const _=e(i,[["render",c],["__file","搜索与图论.html.vue"]]);export{_ as default};
