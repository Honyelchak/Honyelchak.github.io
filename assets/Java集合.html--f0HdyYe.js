import{_ as n}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as a,c as s,f as t}from"./app-2Xbp2Heq.js";const e="/assets/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383232303934383038342e706e67-QnvgxC4h.png",p="/assets/image-20210407145915992-wxl97pPm.png",o="/assets/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383233353235383634332e706e67-FKAA6eek.png",c="/assets/4d8022db-Vsja2ljJ.png",l="/assets/d773f86e-16A_Brt9.png",i="/assets/640-O-8bT7LT.jpeg",u="/assets/image-20201109165808848-SKo4vltz.png",r="/assets/image-20201109165820466-pAEnad1X.png",d="/assets/image-20201109165840129-8jCQkKsR.png",k="/assets/SouthEast-1678611259449-7-K4s0CpgH.png",h="/assets/SouthEast-e4Ww8HsX.png",m="/assets/image-20200304231000271-_FZ5HmY-.png",v="/assets/image-20200304231156504-gMUZHVEd.png",b="/assets/image-20200304231547030-P-QMDAvM.png",g="/assets/image-20200304231427865-1eDeWNxo.png",y="/assets/image-20200305110337107-id-gL51T.png",f={},w=t('<h2 id="java容器概述" tabindex="-1"><a class="header-anchor" href="#java容器概述" aria-hidden="true">#</a> Java容器概述</h2><p>容器主要包括<code>Collection</code>和<code>Map</code>两种，Collection存储着对象的集合，而Map存储着键值对的映射表。</p><h2 id="collection" tabindex="-1"><a class="header-anchor" href="#collection" aria-hidden="true">#</a> Collection</h2><figure><img src="'+e+`" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="_1-set" tabindex="-1"><a class="header-anchor" href="#_1-set" aria-hidden="true">#</a> 1. Set</h3><ul><li><p><code>TreeSet</code>：基于<mark>红黑树</mark>实现，支持<strong>有序性</strong>操作，例如根据一个范围查找元素的操作。<strong>但是查找效率不如 HashSet</strong>，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。</p><ul><li><p>注意，她是实现了<code>SortedSet</code>接口，所以有序。</p></li><li><p>**底层实现调用<code>TreeMap</code>的构造方法，**key为set中的值，Value为object对象。</p><ul><li><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// Dummy value to associate with an Object in the backing Map</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> <span class="token constant">PRESENT</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p>添加、删除、包含等操作时间复杂度<code>O(logN)</code></p></li></ul></li><li><p><strong>HashSet</strong>：基于<mark>哈希表</mark>实现，支持快速查找，但不支持有序性操作。<strong>并且失去了元素的插入顺序信息</strong>，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。</p><ul><li><strong>元素都存到HashMap键值对的Key上面，而Value时有一个统一的值<code>private static final Object PRESENT = new Object();</code></strong>，(定义一个虚拟的Object对象作为HashMap的value，将此对象定义为static final。)</li><li>实际底层会初始化一个空的HashMap，并使用默认初始容量为<strong>16</strong>和加载因子<strong>0.75</strong>。<code>max((old*0.75)+1),16)</code></li><li>添加、删除、查找效率都是<code>O（1）</code></li></ul></li><li><p><strong>LinkedHashSet</strong>：具有 HashSet 的查找效率，并且<strong>内部使用双向链表维护元素的插入顺序</strong>。</p><ul><li><p>继承了<code>HashSet</code>的构造方法，该方法是包访问权限，外部不能访问。</p></li><li><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">HashSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">,</span> <span class="token keyword">boolean</span> dummy<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>添加、删除、查找效率都是O（1）</code></p></li></ul></li></ul><h3 id="_2-list" tabindex="-1"><a class="header-anchor" href="#_2-list" aria-hidden="true">#</a> 2. List</h3><ul><li><p><strong>ArrayList</strong>：基于<strong>动态数组</strong>实现，支持随机访问(下标)。</p><ul><li><p>默认容量是10(第一次添加元素的时候)，再次扩容则扩容到当前容量的1.5倍</p><ul><li>扩容操作需要调用 <code>Arrays.copyOf()</code> 把原数组整个复制到新数组中，这个<strong>操作代价很高</strong>，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。</li></ul></li><li><p>继承<code>Abstract类</code>,实现了<code>RandomAccess</code>接口(实现该接口的list支持快速随机访问)</p></li><li><p><code>Collections.synchronizedList()</code>实现线程安全。</p></li><li><p><code>modCount</code> 用来记录 ArrayList 结构发生变化的次数。结构发生变化是<code>指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小</code>，仅仅只是设置元素的值不算结构发生变化。</p><p>在进行<strong>序列化或者迭代</strong>等操作时，<strong>需要比较操作前后 modCount 是否改变</strong>，如果改变了需要抛出 ConcurrentModificationException。代码参考上节序列化中的 writeObject() 方法。</p></li></ul></li><li><p><strong>Vector</strong>：和 ArrayList 类似，但它是线程安全的。</p><ul><li>大多数方法都是用了<code>synchronized</code></li><li>默认初始容量为10, 每次扩容会增加一倍</li><li>Stack继承了Vector</li></ul></li><li><p><strong>LinkedList</strong>：基于<strong>双向链表</strong>实现，<strong>只能顺序访问</strong>，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。</p><ul><li>插入和删除容易，查找和修改难。(ArrayList与其相反)。</li></ul></li></ul><h4 id="arrayslist" tabindex="-1"><a class="header-anchor" href="#arrayslist" aria-hidden="true">#</a> ArraysList</h4><h5 id="自动扩容" tabindex="-1"><a class="header-anchor" href="#自动扩容" aria-hidden="true">#</a> 自动扩容</h5><p>每当向数组中添加元素时，都会去检查添加后元素的个数是否会超出当前数组的长度。如果超出，数组会进行自动扩容，以满足添加数据的需求。</p><p>数组扩容通过<code>ensureCapacity(int minCapacity)</code>方法实现。也可以通过手动增加<code>ArrayList</code>实例的容量，以减少递增式再分配的数量。</p><p>数组进行扩容时，会将老数组中的元素重新拷贝一份到新的数组中，<strong>每次数组容量的增长是其原容量的1.5倍。这种操作的代价是很高的。</strong></p><p>因此在实际使用时，我们应该尽量避免数组容量的扩张。当我们可预知要保存的元素的多少时，要在构造ArrayList实例时，就指定其容量，以避免数组扩容的发生。或者根据实际需求，通过调用ensureCapacity方法来手动增加ArrayList实例的容量。</p><h5 id="arraylist-和-linkedlist-的区别是什么" tabindex="-1"><a class="header-anchor" href="#arraylist-和-linkedlist-的区别是什么" aria-hidden="true">#</a> ArrayList 和 LinkedList 的区别是什么？</h5><ul><li>数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。</li><li>随机访问效率：<code>ArrayList 比 LinkedList 在随机访问的时候效率要高</code>，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</li><li>增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。</li><li>内存空间占用：<code>LinkedList 比 ArrayList 更占内存</code>，因为 LinkedList 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。</li><li>线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</li></ul><p>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</p><h3 id="_3-queue" tabindex="-1"><a class="header-anchor" href="#_3-queue" aria-hidden="true">#</a> 3. Queue</h3><ul><li><strong>PriorityQueue</strong>：基于堆结构实现，可以用它来实现优先队列。</li><li>Deque <ul><li><strong>LinkedList</strong>：<strong>可以用它来实现双向队列</strong>。</li><li><strong>ArrayDeque</strong></li></ul></li></ul><h2 id="map" tabindex="-1"><a class="header-anchor" href="#map" aria-hidden="true">#</a> Map</h2><blockquote><p>常用的哈希表为了解决哈希冲突，实现方式有以下两种：<strong>链表法</strong>和<strong>开放地址法</strong>。</p><p>开放地址法就是遇到冲突时，采用某种探测方法寻找下一个槽位。</p></blockquote><figure><img src="`+p+'" alt="image-20210407145915992" tabindex="0" loading="lazy"><figcaption>image-20210407145915992</figcaption></figure><ul><li>TreeMap：基于<strong>红黑树</strong>实现。 <ul><li><code>extends AbstractMap</code></li><li><code>containsKey()、get()、put()、remove()的时间复杂度是log(n)</code></li><li>TreeMap是非同步的</li></ul></li><li>HashMap：基于<strong>哈希表</strong>实现。 <ul><li>源码中有<strong>静态内部类</strong><code>entry</code>。</li><li>初始长度为<strong>16</strong>(需要是2的次幂)，默认负载因子<code>DEFAULT_LOAD_FACTOR</code>是0.75</li><li>懒加载机制，<code>只有在第一次put数据的时候才会创建hash表</code>。</li><li>利用单链表解决哈希冲突问题，容量不足会自动扩容</li></ul></li><li>HashTable：和 HashMap 类似，<strong>但它是线程安全的</strong>，这意味着同一时刻多个线程同时写入 HashTable 不会导致数据不一致。它是遗留类，不应该去使用它，而是使用 ConcurrentHashMap 来支持线程安全，ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。</li><li>LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。</li></ul><h3 id="_1-hashmap" tabindex="-1"><a class="header-anchor" href="#_1-hashmap" aria-hidden="true">#</a> 1. HashMap</h3><p>内部包含了一个 Entry 类型的数组 table。Entry 存储着键值对。它包含了四个字段，从 next 字段我们可以看出 Entry 是一个链表。即数组中的每个位置被当成一个桶，一个桶存放一个链表。HashMap 使用拉链法来解决冲突，同一个链表中存放哈希值和散列桶取模运算结果相同的 Entry。</p><figure><img src="'+o+`" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h4 id="插入-头插法" tabindex="-1"><a class="header-anchor" href="#插入-头插法" aria-hidden="true">#</a> 插入(头插法)</h4><ul><li>查找时分为两步 <ol><li><p>计算key值的hash值</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> h<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为什么需要<code>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>,<strong>这段代码将高位、低位的信息混合在了一起，打乱 hashCode 真正参与运算的低 16 位</strong></p><p>具体来讲：如果两个不同的对象的哈希码只有高位信息不同，那么它们在HashMap中的位置可能是相邻的，从而导致哈希冲突。通过将高位信息与低位信息混合在一起，可以减少这种情况的发生，从而降低哈希冲突的概率。</p></li><li><p>判断Node数组是否为空，如果为空的话，需要先进行初始化(懒加载)</p></li><li><p>根据<code>(n - 1) &amp; hash</code>计算桶的下标</p><ol><li>它通过h &amp; (table.length -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是<strong>HashMap在速度上的优化</strong>。当length总是2的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。</li></ol></li><li><p>如果该桶为空，那么就创建Node，放入桶里。</p></li><li><p>否则先判断该节点的key是否和桶里的头节点的key相同，相同的话就直接更新value</p></li><li><p>如果上边的都不成立，那么就判断是否为红黑树节点，若是，就调用红黑树的插入方式</p></li><li><p>如果是链表，那就遍历链表，看是否有与该key相同的节点，如果有，直接更新value，如果没有就插入，并判断插入后是否需要转红黑树。</p></li><li><p>最后判断hashmap中的元素数量是否大于threshold阈值，如果大于的话，就需要扩容。</p></li></ol></li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code> <span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span>
                   <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token comment">//1、判断当 table 为 null 或者 tab 的长度为 0 时，即 table 尚未初始化，此时通过 resize() 方法得到初始化的 table</span>
            n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
<span class="token comment">//1.1、此处通过（n - 1） &amp; hash 计算出的值作为 tab 的下标 i，并另 p 表示 tab[i]，也就是该链表第一个节点的位置。并判断 p 是否为 null</span>
            tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//1.1.1、当 p 为 null 时，表明 tab[i] 上没有任何元素，那么接下来就 new 第一个 Node 节点，调用 newNode 方法返回新节点赋值给 tab[i]</span>
        <span class="token keyword">else</span> <span class="token punctuation">{</span>
<span class="token comment">//2.1 下面进入 p 不为 null 的情况，有三种情况：p 为链表节点；p 为红黑树节点；p 是链表节点但长度为临界长度 TREEIFY_THRESHOLD，再插入任何元素就要变成红黑树了。</span>
            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span> <span class="token class-name">K</span> k<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
                <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">//2.1.1HashMap 中判断 key 相同的条件是 key 的 hash 相同，并且符合 equals 方法。这里判断了 p.key 是否和插入的 key 相等，如果相等，则将 p 的引用赋给 e</span>
 
                e <span class="token operator">=</span> p<span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>
<span class="token comment">//2.1.2 现在开始了第一种情况，p 是红黑树节点，那么肯定插入后仍然是红黑树节点，所以我们直接强制转型 p 后调用 TreeNode.putTreeVal 方法，返回的引用赋给 e</span>
                e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token punctuation">{</span>
<span class="token comment">//2.1.3 接下里就是 p 为链表节点的情形，也就是上述说的另外两类情况：插入后还是链表 / 插入后转红黑树。另外，上行转型代码也说明了 TreeNode 是 Node 的一个子类</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token comment">// 我们需要一个计数器来计算当前链表的元素个数，并遍历链表，binCount 就是这个计数器</span>
 
                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">&gt;=</span> <span class="token constant">TREEIFY_THRESHOLD</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> 
<span class="token comment">// 插入成功后，要判断是否需要转换为红黑树，因为插入后链表长度加 1，而 binCount 并不包含新节点，所以判断时要将临界阈值减 1</span>
                            <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 当新长度满足转换条件时，调用 treeifyBin 方法，将该链表转换为红黑树</span>
                        <span class="token keyword">break</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
                        <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                        <span class="token keyword">break</span><span class="token punctuation">;</span>
                    p <span class="token operator">=</span> e<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// existing mapping for key</span>
                <span class="token class-name">V</span> oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                    e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
                <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token operator">++</span>modCount<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">&gt;</span> threshold<span class="token punctuation">)</span>
            <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="扩容-基本原理" tabindex="-1"><a class="header-anchor" href="#扩容-基本原理" aria-hidden="true">#</a> 扩容-基本原理</h4><p>设 HashMap 的 table 长度为 M，需要存储的键值对数量为 N，如果哈希函数满足均匀性的要求，那么每条链表的长度大约为 N/M，因此查找的复杂度为 O(N/M)。</p><p>为了让查找的成本降低，<strong>应该使 N/M 尽可能小</strong>，因此需要保证 M 尽可能大，也就是说 table 要尽可能大。HashMap <strong>采用动态扩容来根据当前的 N 值来调整 M 值</strong>，使得空间效率和时间效率都能得到保证。</p><p>扩容使用<code>resize()</code> 实现，需要注意的是，扩容操作同样需要把 <code>oldTable</code> 的所有键值对重新插入 newTable 中，因此这一步是很费时的。</p><p>JDK8中HashMap的扩容相比JDK7时多了两个优化：</p><ol><li><p><strong>优化一：不需要重新计算hash</strong></p><ul><li><p>在JDK7时，数组扩容之后，需要对所有的键值重新计算hash，并插入到newTable中。但是通过分析，可以得出一个阶段，我们使用2次幂进行扩容，<code>元素的位置要么不变，要么就是原位置再次移动2次幂的位置(new = old &lt;&lt; 1)</code>。</p></li><li><p>所以在JDK8中，我们不用像之前那样重新计算hash，只需要看看原来的hash对应的那个bit(新增的那个)是1还是0，如果是0的话索引就不变，否则就变成<code>原索引 + oldCap</code></p><figure><img src="`+c+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><figure><img src="'+l+`" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure></li></ul></li><li><p><strong>优化二：扩容之后，链表中的元素不会倒置。</strong></p></li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTab <span class="token operator">=</span> table<span class="token punctuation">;</span>
        <span class="token keyword">int</span> oldCap <span class="token operator">=</span> <span class="token punctuation">(</span>oldTab <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> oldTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token keyword">int</span> oldThr <span class="token operator">=</span> threshold<span class="token punctuation">;</span>
        <span class="token keyword">int</span> newCap<span class="token punctuation">,</span> newThr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 超过最大值就不再扩充了，随便你碰撞吧 2^30</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">&gt;=</span> <span class="token constant">MAXIMUM_CAPACITY</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                threshold <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> oldTab<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 没超过最大值，就扩充为原来的两倍</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newCap <span class="token operator">=</span> oldCap <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token constant">MAXIMUM_CAPACITY</span> <span class="token operator">&amp;&amp;</span>
                     oldCap <span class="token operator">&gt;=</span> <span class="token constant">DEFAULT_INITIAL_CAPACITY</span><span class="token punctuation">)</span>
                newThr <span class="token operator">=</span> oldThr <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// double threshold</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldThr <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// initial capacity was placed in threshold</span>
            newCap <span class="token operator">=</span> oldThr<span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token punctuation">{</span>               <span class="token comment">// zero initial threshold signifies using defaults</span>
            newCap <span class="token operator">=</span> <span class="token constant">DEFAULT_INITIAL_CAPACITY</span><span class="token punctuation">;</span>
            newThr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token constant">DEFAULT_LOAD_FACTOR</span> <span class="token operator">*</span> <span class="token constant">DEFAULT_INITIAL_CAPACITY</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    	<span class="token comment">// 计算新的threshold</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>newThr <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">float</span> ft <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>newCap <span class="token operator">*</span> loadFactor<span class="token punctuation">;</span>
            newThr <span class="token operator">=</span> <span class="token punctuation">(</span>newCap <span class="token operator">&lt;</span> <span class="token constant">MAXIMUM_CAPACITY</span> <span class="token operator">&amp;&amp;</span> ft <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token constant">MAXIMUM_CAPACITY</span> <span class="token operator">?</span>
                      <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ft <span class="token operator">:</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        threshold <span class="token operator">=</span> newThr<span class="token punctuation">;</span>
        <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">&quot;rawtypes&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;unchecked&quot;</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTab <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>newCap<span class="token punctuation">]</span><span class="token punctuation">;</span>
        table <span class="token operator">=</span> newTab<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldTab <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 把每个bucket都移动到新的buckets中</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> oldCap<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span>
                <span class="token comment">// 桶不为空</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 避免内存泄漏</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// 链表上只有一个元素</span>
                        newTab<span class="token punctuation">[</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newCap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>
                        <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> newTab<span class="token punctuation">,</span> j<span class="token punctuation">,</span> oldCap<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// preserve order</span>
                        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> loHead <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> loTail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> hiHead <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> hiTail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">;</span>
                        <span class="token keyword">do</span> <span class="token punctuation">{</span>
                            next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment">// 获取到下一个元素</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> oldCap<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果新增的那一位为0，那么位置不变</span>
                                <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// 尾插法</span>
                                    loHead <span class="token operator">=</span> e<span class="token punctuation">;</span>
                                <span class="token keyword">else</span>
                                    loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>
                                loTail <span class="token operator">=</span> e<span class="token punctuation">;</span>
                            <span class="token punctuation">}</span>
                            <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 如果新增的那一位为1，那么位置变为(原位置 + oldCap)</span>
                                <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// 尾插法</span>
                                    hiHead <span class="token operator">=</span> e<span class="token punctuation">;</span>
                                <span class="token keyword">else</span>
                                    hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>
                                hiTail <span class="token operator">=</span> e<span class="token punctuation">;</span>
                            <span class="token punctuation">}</span>
                        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                            loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                            newTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                            hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                            newTab<span class="token punctuation">[</span>j <span class="token operator">+</span> oldCap<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> newTab<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="扩容-重新计算下标" tabindex="-1"><a class="header-anchor" href="#扩容-重新计算下标" aria-hidden="true">#</a> 扩容--重新计算下标</h4><blockquote><p>取余运算符为“%”。但在以前，CPU采用如下方法计算余数（注意，该方法<strong>只对2的N次方数</strong>系有效）： X &amp; (2^N - 1)</p></blockquote><p>因为上边所说的对2的N次方数可以采用位运算进行取余，所以capacity需要满足是2的n次方。</p><p>假设原数组长度 capacity 为 16，扩容之后 new capacity 为 32：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>capacity     : 00010000
new capacity : 00100000
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>对于一个 Key，它的哈希值 hash 在第 5 位：</p><ul><li>为 0，那么 hash%00010000 = hash%00100000，桶位置和原来一致；</li><li>为 1，hash%00010000 = hash%00100000 + 16，桶位置是原位置 + 16。</li></ul><p>**PS：**如果在初始化时，传入的容量值不是2的n次方，它可以自动的将传入的容量转为2的n次方</p><h4 id="桶下标如何计算" tabindex="-1"><a class="header-anchor" href="#桶下标如何计算" aria-hidden="true">#</a> 桶下标如何计算</h4><p>先算出hash，然后(n - 1) &amp; hash</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> h<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>计算key的hashCode()并将散列的高位（异或）散列的低位。由于该表使用两个掩码的幂，因此仅在当前掩码上方的位上变化的哈希集将始终发生冲突。（在已知的例子中有一组在小表格中保持连续整数的浮点键。）</p><p>因此我们应用了一种向下扩展高位影响的变换。在速度、实用性和位扩展质量之间存在一种折衷。因为许多常见的散列集已经被合理地分布（因此不能从散播中受益），而且因为我们使用树来处理容器中的大量冲突，所以我们只是以最便宜的方式对一些移位的位进行异或，以减少系统损失，以及合并最高位的影响，否则由于表边界，这些最高位将永远不会用于索引计算。</p></blockquote><h4 id="链表转红黑树" tabindex="-1"><a class="header-anchor" href="#链表转红黑树" aria-hidden="true">#</a> 链表转红黑树</h4><p>从 JDK 1.8 开始，一个桶存储的链表长度<strong>大于等于 8</strong> , 并且数组长度大于64 时会将链表转换为红黑树。</p><p>1、hashMap并不是在链表元素个数大于8就一定会转换为红黑树，而是先考虑扩容，扩容达到默认限制后才转换。 2、hashMap的红黑树不一定小于6的时候才会转换为链表，而是只有在resize的时候才会根据 UNTREEIFY_THRESHOLD 进行转换。</p><h4 id="与-hashtable-的比较" tabindex="-1"><a class="header-anchor" href="#与-hashtable-的比较" aria-hidden="true">#</a> 与 Hashtable 的比较</h4><ul><li><p>HashMap是HashTable的轻量级实现(非线程安全的实现)</p></li><li><p>HashMap继承AbstractMap，HashTable继承Dictionary(现已荒废)</p></li><li><p>Hashtable 使用 <strong>synchronized</strong> 来进行同步。</p></li><li><p>HashMap 可以插入键为 null 的 Entry(<strong>HashTable不可以</strong>)。</p><ul><li>null放到0号位置。</li></ul></li><li><p>HashMap 的迭代器是 <code>fail-fast</code> 迭代器。</p></li><li><p>HashMap <code>不能保证随着时间的推移 Map 中的元素次序是不变的</code>。</p></li></ul><h4 id="与threadlocalmap比较" tabindex="-1"><a class="header-anchor" href="#与threadlocalmap比较" aria-hidden="true">#</a> 与ThreadLocalMap比较</h4><ul><li><p>HashMap 的数据结构是<code>数组+链表</code>, ThreadLocalMap的数据结构仅仅是<code>数组</code></p></li><li><p>HashMap 是通过<code>链地址法</code>解决hash冲突的问题,ThreadLocalMap 是通过<code>开放地址法</code>来解决hash 冲突的问题</p></li><li><p>HashMap 里面的<code>Entry内部类</code>的引用都是强引用, ThreadLocalMap里面的Entry 内部类中的key 是弱引用，value 是强引用</p></li></ul><p>Ps：Thread中有一个ThreadLocalMap，ThreadLocalMap中存放的是Entry数组，Entry是键值对<code>&lt;ThreadLocal, Object&gt;</code></p><h4 id="链地址法和开放地址法的优缺点" tabindex="-1"><a class="header-anchor" href="#链地址法和开放地址法的优缺点" aria-hidden="true">#</a> 链地址法和开放地址法的优缺点</h4><p>开放地址法：</p><ol><li>容易产生堆积问题，不适于大规模的数据存储。</li><li>散列函数的设计对冲突会有很大的影响，插入时可能会出现多次冲突的现象。</li><li>删除的元素是多个冲突元素中的一个，需要对后面的元素作处理，实现较复杂。</li></ol><p>链地址法：</p><ol><li>处理冲突简单，且无堆积现象，平均查找长度短。</li><li>链表中的结点是动态申请的，适合构造表不能确定长度的情况。</li><li>删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。</li><li>指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间。</li></ol><blockquote><p><strong>为什么ThreadLocalMap 采用开放地址法来解决哈希冲突?</strong></p><ul><li><p>ThreadLocal 中看到一个属性 HASH_INCREMENT = <code>0x61c88647</code> ，0x61c88647 是一个神奇的数字，让哈希码能均匀的分布在2的N次方的数组里, 即 Entry[] table，关于这个神奇的数字google 有很多解析，这里就不重复说了</p><ul><li>每次实例化ThreadLocal，那么就会生成不同的<code>threadLocalHashCode</code>,从而将Entry均匀的分布到数组table中。</li><li>生成hashcode的方法：<code>nextHashCode.getAndAdd(HASH_INCREMENT)</code>，nextHashCode是静态原子类，从0开始的。</li></ul></li><li><p>ThreadLocal 往往存放的数据量不会特别大（而且key 是弱引用又会被垃圾回收，及时让数据量更小），这个时候开放地址法简单的结构会显得更省空间，同时数组的查询效率也是非常高，加上第一点的保障，冲突概率也低。</p></li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>expungeStaleEntry方法是用来清楚无用的entry的
1. 从指定位置往下扫描entry数组，知道entry为null
1.1 如果遇到当前key被回收的entry，就执行删除，
1.2 否则重新计算hash，将其放在正确的位置上。

set方法：
1. 首先计算在entry数组中对应的位置，如果当前entry不为空，那就往下扫描：
2. 若找到相同的key，更新值并返回
3. 否则找到第一个过期的enty，执行替换操作。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><h4 id="两个线程并发的put元素-且这两个元素存在hash冲突-会造成问题吗" tabindex="-1"><a class="header-anchor" href="#两个线程并发的put元素-且这两个元素存在hash冲突-会造成问题吗" aria-hidden="true">#</a> 两个线程并发的put元素，且这两个元素存在hash冲突，会造成问题吗？</h4><p>主要原因在于并发下的 Rehash <code>会造成元素之间会形成一个循环链表</code>。不过，jdk 1.8 后解决了这个问题，但是还是不建议在多线程下使用 HashMap,因为多线程下使用 HashMap 还是会存在其他问题比如数据丢失。并发环境下推荐使用 ConcurrentHashMap 。</p><ol><li>HashMap在并发情况下的put操作会造成死循环。</li></ol><hr><h3 id="_2-concurrenthashmap" tabindex="-1"><a class="header-anchor" href="#_2-concurrenthashmap" aria-hidden="true">#</a> 2. ConcurrentHashMap</h3><h4 id="_1-7之前" tabindex="-1"><a class="header-anchor" href="#_1-7之前" aria-hidden="true">#</a> 1.7之前</h4><figure><img src="`+i+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h4 id="是否允许为null" tabindex="-1"><a class="header-anchor" href="#是否允许为null" aria-hidden="true">#</a> 是否允许为null</h4><p>key和value不可以为Null。</p><h4 id="线程安全" tabindex="-1"><a class="header-anchor" href="#线程安全" aria-hidden="true">#</a> 线程安全</h4><p>JDK1.8之前：数组+链表，采用<code>分段锁</code> Segment(继承 ReentrantLock)。</p><p>JDK1.8以后：数组+链表+红黑树，采用<code>CAS+synchronized</code></p><p><strong>锁分段技术</strong></p><p>HashTable容器在竞争激烈的并发环境下表现出效率低下的原因是所有访问HashTable的线程都必须竞争同一把锁，那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p><h4 id="concurrenthashmap-和-hashtable-的区别" tabindex="-1"><a class="header-anchor" href="#concurrenthashmap-和-hashtable-的区别" aria-hidden="true">#</a> ConcurrentHashMap 和 Hashtable 的区别？</h4><p>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现<code>线程安全的方式上</code>不同。</p><p>底层数据结构：</p><ul><li>JDK1.7的 ConcurrentHashMap 底层采用 <code>分段的数组+链表</code> 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。</li><li>Hashtable 和 JDK1.7 的 HashMap 的底层数据结构类似都是采用 数组+链表 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li></ul><p>实现线程安全的方式（重要）：</p><ul><li>在JDK1.7的时候，ConcurrentHashMap（分段锁） <code>对整个桶数组进行了分割分段(Segment)</code>，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。（<code>默认分配16个Segment</code>，比Hashtable效率提高16倍。）</li><li>JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 <code>Node数组+链表+红黑树的数据结构来实现</code>，并发控制使用 <code>synchronized </code>和<code>CAS</code>来操作。（JDK1.6以后对 synchronized锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；②</li><li>Hashtable(同一把锁) :使用 <code>synchronized</code> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li></ul><p>两者的对比图：</p><p>HashTable:</p><figure><img src="'+u+'" alt="image-20201109165808848" tabindex="0" loading="lazy"><figcaption>image-20201109165808848</figcaption></figure><p>JDK1.7的ConcurrentHashMap：</p><figure><img src="'+r+'" alt="image-20201109165820466" tabindex="0" loading="lazy"><figcaption>image-20201109165820466</figcaption></figure><p>JDK1.8的ConcurrentHashMap（TreeBin: 红黑二叉树节点 Node: 链表节点）：</p><figure><img src="'+d+`" alt="image-20201109165840129" tabindex="0" loading="lazy"><figcaption>image-20201109165840129</figcaption></figure><p>答：ConcurrentHashMap 结合了 <code>HashMap 和 HashTable </code>二者的优势。</p><p>HashMap 没有考虑同步，HashTable 考虑了同步的问题。但是 HashTable 在每次同步执行时都要锁住整个结构。 ConcurrentHashMap 锁的方式是稍微细粒度的。</p><h3 id="_3-linkedhashmap" tabindex="-1"><a class="header-anchor" href="#_3-linkedhashmap" aria-hidden="true">#</a> 3. LinkedHashMap</h3><h4 id="_1-存储结构" tabindex="-1"><a class="header-anchor" href="#_1-存储结构" aria-hidden="true">#</a> 1. 存储结构</h4><p>继承自 HashMap，因此具有和 HashMap 一样的快速查找特性。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>内部维护了一个双向链表，用来维护<strong>插入顺序</strong>或者 <strong>LRU</strong> 顺序。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * The head (eldest) of the doubly linked list.
 */</span>
<span class="token keyword">transient</span> <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> head<span class="token punctuation">;</span>

<span class="token doc-comment comment">/**
 * The tail (youngest) of the doubly linked list.
 */</span>
<span class="token keyword">transient</span> <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> tail<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但由于它又额外定义了一个以head为头结点的双向链表(如下面第二个图所示)，因此对于每次put进来Entry，除了将其保存到哈希表中对应的位置上之外，还会将其插入到双向链表的尾部。</p><figure><img src="`+k+'" alt="这里写图片描述" tabindex="0" loading="lazy"><figcaption>这里写图片描述</figcaption></figure><p>其中，HashMap与LinkedHashMap的Entry结构示意图如下图所示：</p><figure><img src="'+h+`" alt="这里写图片描述" tabindex="0" loading="lazy"><figcaption>这里写图片描述</figcaption></figure><h4 id="_2-成员变量定义" tabindex="-1"><a class="header-anchor" href="#_2-成员变量定义" aria-hidden="true">#</a> 2. 成员变量定义</h4><p>与HashMap相比，LinkedHashMap增加了两个属性用于保证迭代顺序，分别是 <strong>双向链表头结点header</strong> 和 <strong>标志位accessOrder</strong> (值为true时，表示按照访问顺序迭代；值为false时，表示按照插入顺序迭代)。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * The head of the doubly linked list.
 */</span>
<span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> header<span class="token punctuation">;</span>  <span class="token comment">// 双向链表的表头元素</span>

<span class="token doc-comment comment">/**
 * The iteration ordering method for this linked hash map: <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tt</span><span class="token punctuation">&gt;</span></span><span class="token code-section"><span class="token line"><span class="token code language-java"><span class="token boolean">true</span></span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tt</span><span class="token punctuation">&gt;</span></span>
 * for access-order, <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tt</span><span class="token punctuation">&gt;</span></span><span class="token code-section"><span class="token line"><span class="token code language-java"><span class="token boolean">false</span></span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tt</span><span class="token punctuation">&gt;</span></span> for insertion-order.
 *
 * <span class="token keyword">@serial</span>
 */</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> accessOrder<span class="token punctuation">;</span>  <span class="token comment">//true表示按照访问顺序迭代，false时表示按照插入顺序 </span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_3-数据结构" tabindex="-1"><a class="header-anchor" href="#_3-数据结构" aria-hidden="true">#</a> 3. 数据结构</h4><p>本质上，LinkedHashMap = HashMap + <strong>双向链表</strong>，也就是说，HashMap和双向链表合二为一即是LinkedHashMap。也可以这样理解，LinkedHashMap 在不对HashMap做任何改变的基础上，给HashMap的任意两个节点间加了两条连线(before指针和after指针)，使这些节点形成一个双向链表。在LinkedHashMapMap中，所有put进来的Entry都保存在HashMap中，但由于它又额外定义了一个以head为头结点的空的双向链表，因此对于每次put进来Entry还会将其插入到双向链表的尾部。</p><p>他重写了HashMap的createREntry方法</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>    <span class="token keyword">void</span> <span class="token function">createEntry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token keyword">int</span> bucketIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        <span class="token comment">// 向哈希表中插入Entry，这点与HashMap中相同 </span>
        <span class="token comment">//创建新的Entry并将其链入到数组对应桶的链表的头结点处， </span>
        <span class="token class-name">HashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> old <span class="token operator">=</span> table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>  
        <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> old<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>     

        <span class="token comment">//在每次向哈希表插入Entry的同时，都会将其插入到双向链表的尾部，  </span>
        <span class="token comment">//这样就按照Entry插入LinkedHashMap的先后顺序来迭代元素(LinkedHashMap根据双向链表重写了迭代器)</span>
        <span class="token comment">//同时，新put进来的Entry是最近访问的Entry，把其放在链表末尾 ，也符合LRU算法的实现  </span>
        e<span class="token punctuation">.</span><span class="token function">addBefore</span><span class="token punctuation">(</span>header<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        size<span class="token operator">++</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由以上源码我们可以知道，在LinkedHashMap中向哈希表中插入新Entry的同时，还会通过Entry的addBefore方法将其链入到双向链表中。其中，addBefore方法本质上是一个双向链表的插入操作，其源码如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>    <span class="token comment">//在双向链表中，将当前的Entry插入到existingEntry(header)的前面  </span>
    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">addBefore</span><span class="token punctuation">(</span><span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> existingEntry<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        after  <span class="token operator">=</span> existingEntry<span class="token punctuation">;</span>
        before <span class="token operator">=</span> existingEntry<span class="token punctuation">.</span>before<span class="token punctuation">;</span>
        before<span class="token punctuation">.</span>after <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
        after<span class="token punctuation">.</span>before <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>  
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_4-扩容" tabindex="-1"><a class="header-anchor" href="#_4-扩容" aria-hidden="true">#</a> 4. 扩容</h4><p>桶HashMap扩容相似，只是简单的修改了复制数组的方法<code>transfer()</code></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>    <span class="token doc-comment comment">/**
     * Transfers all entries to new table array.  This method is called
     * by superclass resize.  It is overridden for performance, as it is
     * faster to iterate using our linked list.
     */</span>
    <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token class-name">HashMap<span class="token punctuation">.</span>Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTable<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> newTable<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token comment">// 与HashMap相比，借助于双向链表的特点进行重哈希使得代码更加简洁</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e <span class="token operator">=</span> header<span class="token punctuation">.</span>after<span class="token punctuation">;</span> e <span class="token operator">!=</span> header<span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>after<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 计算每个Entry所在的桶</span>
            <span class="token comment">// 将其链入桶中的链表</span>
            e<span class="token punctuation">.</span>next <span class="token operator">=</span> newTable<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
            newTable<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-treemap" tabindex="-1"><a class="header-anchor" href="#_4-treemap" aria-hidden="true">#</a> 4. TreeMap</h3><ul><li>按照key的自然排序排列</li></ul><h3 id="_5-hashtable与hashmap的区别" tabindex="-1"><a class="header-anchor" href="#_5-hashtable与hashmap的区别" aria-hidden="true">#</a> 5. HashTable与HashMap的区别</h3><h4 id="计算索引位置方法不同" tabindex="-1"><a class="header-anchor" href="#计算索引位置方法不同" aria-hidden="true">#</a> 计算索引位置方法不同</h4><ul><li>HashMap <ul><li><code>index = (n - 1) &amp; hash</code></li><li>因<code>n-1</code>为2的幂次，所以利用位运算高效算出索引</li></ul></li><li>HashTable <ul><li><code>int index = (hash &amp; 0x7FFFFFFF) % tab.length; </code></li><li>&amp;0x7FFFFFFF的目的是为了将负的hash值转化为正值(只有符号位改变)</li></ul></li></ul><h4 id="扩容方式不一样" tabindex="-1"><a class="header-anchor" href="#扩容方式不一样" aria-hidden="true">#</a> 扩容方式不一样</h4><ul><li>HashMap容量不足resize时，扩容必须要求原容量的2倍，且扩容结果一定是2的n次幂。</li><li>HashTable则扩到原容量的2倍+1。</li></ul><h4 id="解决hash冲突方式不容" tabindex="-1"><a class="header-anchor" href="#解决hash冲突方式不容" aria-hidden="true">#</a> 解决hash冲突方式不容</h4><ul><li>HashMap在Java8中，当出现冲突时，一个桶存储的链表长度大于等于 8 时会将链表转换为红黑树。</li><li>而在HashTable中， <strong>都是以链表方式存储。</strong></li></ul><h4 id="是否允许null值" tabindex="-1"><a class="header-anchor" href="#是否允许null值" aria-hidden="true">#</a> 是否允许null值</h4><ul><li>HashMap允许key、value为null值</li><li>HashTable不允许，会报空指针异常</li></ul><h4 id="线程安全-1" tabindex="-1"><a class="header-anchor" href="#线程安全-1" aria-hidden="true">#</a> 线程安全</h4><ul><li>HashMap不安全</li><li>HashTable安全，HashTable实现线程安全的代价就是<strong>效率变低</strong>，因为会<strong>锁住整个HashTable</strong>,而ConcurrentHashMap做了相关优化,因为ConcurrentHashMap使用了<strong>分段锁</strong>，并不对整个数据进行锁定,效率比HashTable高很多。</li></ul><h3 id="_6-解决哈希冲突的方法" tabindex="-1"><a class="header-anchor" href="#_6-解决哈希冲突的方法" aria-hidden="true">#</a> 6. 解决哈希冲突的方法</h3><ul><li>**拉链法(链地址法)：**采用数组+链表，数组的每一格就是一个链表，如果发生了哈希冲突就加在链表上。</li><li>**线性探测法：**如果发生了哈希冲突，就向后查找，直至找到一个空位置插入。</li></ul><h2 id="vector真的同步吗" tabindex="-1"><a class="header-anchor" href="#vector真的同步吗" aria-hidden="true">#</a> Vector真的同步吗？</h2><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>vector<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">)</span> 
vector<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
<span class="token comment">//这是经典的 put-if-absent 情况，尽管 contains, add 方法都正确地同步了，但作为 vector 之外的使用环境，仍然存在 race condition（锁竞争）: 因为虽然条件判断contains与add都是原子性的操作 (atomic)，但在 if 条件判断为真后，那个用来访问vector.contains 方法的锁已经释放，在即将的 vector.add 方法调用 之间有间隙，在多线程环境中，完全有可能被其他线程获得 vector的 lock 并改变其状态, 此时当前线程的vector.add(element); 正在等待（只不过我们不知道而已）。只有当其他线程释放了 vector 的 lock 后，vector.add(element); 继续，但此时它已经基于一个错误的假设了。</span>
<span class="token comment">//单个的方法 synchronized 了并不代表组合（compound）的方法调用具有原子性，使 compound actions 成为线程安全的可能解决办法之一还是离不开intrinsic lock (这个锁应该是 vector 的，但由 client 维护)：</span>
<span class="token comment">// 所有的 Vector 的方法都具有 synchronized 关键修饰。但对于复合操作，Vector 仍然需要进行同步处理。</span>
<span class="token comment">// 参考链接：https://yuanfentiank789.github.io/2016/11/25/vectorsafe/</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="替代方案" tabindex="-1"><a class="header-anchor" href="#替代方案" aria-hidden="true">#</a> 替代方案</h3><p>尽量使用ArrayList，少用Vector。</p><p>可以使用 <code>Collections.synchronizedList();</code> 得到一个线程安全的 ArrayList。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> synList <span class="token operator">=</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">synchronizedList</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>也可以使用 concurrent 并发包下的 CopyOnWriteArrayList 类。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CopyOnWriteArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="copyonwritearraylist" tabindex="-1"><a class="header-anchor" href="#copyonwritearraylist" aria-hidden="true">#</a> CopyOnWriteArrayList</h4><h5 id="_1-读写分离" tabindex="-1"><a class="header-anchor" href="#_1-读写分离" aria-hidden="true">#</a> 1. 读写分离</h5><p>写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。</p><p>写操作需要加锁，防止并发写入时导致写入数据丢失。</p><p>写操作结束之后需要把原始数组指向新的复制数组。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>
    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elements <span class="token operator">=</span> <span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> len <span class="token operator">=</span> elements<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newElements <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        newElements<span class="token punctuation">[</span>len<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
        <span class="token function">setArray</span><span class="token punctuation">(</span>newElements<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">setArray</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    array <span class="token operator">=</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">&quot;unchecked&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">private</span> <span class="token class-name">E</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> a<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="_2-使用场景" tabindex="-1"><a class="header-anchor" href="#_2-使用场景" aria-hidden="true">#</a> 2. 使用场景</h5><p><code>白名单，黑名单，商品类目的访问和更新场景</code></p><p>CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。</p><p>但是 CopyOnWriteArrayList 有其缺陷：</p><ul><li>内存占用：在写操作时需要复制一个新的数组，<strong>使得内存占用为原来的两倍左右；</strong></li><li>数据不一致：<strong>读操作不能读取实时性的数据</strong>，因为部分写操作的数据还未同步到读数组中。</li></ul><p>所以 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景。</p><h2 id="快速失败-fail-fast-和安全失败-fail-safe" tabindex="-1"><a class="header-anchor" href="#快速失败-fail-fast-和安全失败-fail-safe" aria-hidden="true">#</a> 快速失败(fail-fast)和安全失败(fail-safe)</h2><ul><li><ul><li><p>快速失败： 在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出Concurrent Modification Exception。java.util中的集合类都是快速失败的。</p></li><li><ul><li>在这些集合类中都有一个modCount变量，用来记录集合修改的次数，如果在迭代过程中modCount发生了变化，就会抛出异常。</li></ul></li><li><p>安全失败： 迭代的时候先复制原有集合内容，在拷贝的集合上进行遍历，所以即使原来的集合被修改了，迭代器也不知道。java.util.concurrent包内的容器都是安全失败的，可以在多线程下使用。</p></li></ul></li></ul><h2 id="list集合的三种遍历方式、效率如何" tabindex="-1"><a class="header-anchor" href="#list集合的三种遍历方式、效率如何" aria-hidden="true">#</a> List集合的三种遍历方式、效率如何？</h2><ul><li>迭代器遍历</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span>  it  <span class="token operator">=</span>  list<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  it<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">)</span>  <span class="token punctuation">{</span>  
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  
  <span class="token punctuation">}</span>  
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>这种方式在循环执行过程中会进行数据锁定，性能稍差</strong>，同时如果你想在循环过程中去掉某个元素，<code>只能调用it.remove方法</code>，不能使用list.remove方法，否则一定出现并发访问的错误。</p><ul><li>增强for循环</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code> <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">String</span>  data   <span class="token operator">:</span>  list<span class="token punctuation">)</span>  <span class="token punctuation">{</span>  
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  
  <span class="token punctuation">}</span>  
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>内部调用第一种</strong>，换汤不换药，因此比Iterator慢，这种循环方式还有其他限制，不建议使用它</p><p>第三种：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code> <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span>  i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>  i<span class="token operator">&lt;</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>  
    <span class="token class-name">A</span>  a  <span class="token operator">=</span>  list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  
  <span class="token punctuation">}</span>  
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>内部不锁定, 效率最高, 但是当写多线程时要考虑并发操作的问题</p><h2 id="map集合的几种遍历方式" tabindex="-1"><a class="header-anchor" href="#map集合的几种遍历方式" aria-hidden="true">#</a> Map集合的几种遍历方式</h2><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;1&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;nice&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;2&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;3&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;bucuo&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>**推荐第一种：**第二种还需要用get方法获取，效率低。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 第一种：获取map的entrySet</span>
<span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> it <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> entry <span class="token operator">=</span> it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;key = &quot;</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot; value = &quot;</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 第二种：获取map的keySet，然后再用get方法获取</span>
<span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> it1 <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>it1<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">String</span> key <span class="token operator">=</span> it1<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;key = &quot;</span> <span class="token operator">+</span> key <span class="token operator">+</span> <span class="token string">&quot; value = &quot;</span> <span class="token operator">+</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="如何实现数组和list之间的转换" tabindex="-1"><a class="header-anchor" href="#如何实现数组和list之间的转换" aria-hidden="true">#</a> 如何实现数组和List之间的转换</h2><p>详见<a href="Java疑难点.md">Java疑难点.md#2. 集合</a></p><h2 id="如何确保一个集合不能被修改" tabindex="-1"><a class="header-anchor" href="#如何确保一个集合不能被修改" aria-hidden="true">#</a> 如何确保一个集合不能被修改</h2><figure><img src="`+m+'" alt="image-20200304231000271" tabindex="0" loading="lazy"><figcaption>image-20200304231000271</figcaption></figure><p><code>Collections.xxx</code></p><figure><img src="'+v+`" alt="image-20200304231156504" tabindex="0" loading="lazy"><figcaption>image-20200304231156504</figcaption></figure><p>修改则抛出异常<code>UnsupportOperationException()</code></p><p>**PS：**不能用final，因为集合是引用类型，所以只是让这个引用不能引用其他对象。</p><h2 id="如何获取线程安全容器" tabindex="-1"><a class="header-anchor" href="#如何获取线程安全容器" aria-hidden="true">#</a> 如何获取线程安全容器</h2><h3 id="使用juc下的集合类" tabindex="-1"><a class="header-anchor" href="#使用juc下的集合类" aria-hidden="true">#</a> 使用JUC下的集合类</h3><h4 id="list和set" tabindex="-1"><a class="header-anchor" href="#list和set" aria-hidden="true">#</a> List和Set</h4><ul><li>CopyOnWriteArrayList</li><li>CopyOnWriteArraySet <ul><li>相当于线程安全的HashSet。</li><li>底层通过CopyOnWriteArrayList实现的</li></ul></li><li>ConcurrentSkipListSet</li></ul><p>*第一，在”添加操作“开始前，<strong>获取独占锁(lock)</strong>，若此时有需要线程要获取锁，则必须等待；在操作完毕后，释放独占锁(lock)，此时其它线程才能获取锁。通过独占锁，来防止多线程同时修改数据！lock的定义如下： <code>transient final ReentrantLock lock = new ReentrantLock();</code></p><pre><code>第二，操作完毕时，会通过setArray()来更新”volatile数组“。而且，前面我们提过”即对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入“；这样**，每次添加元素之后，其它线程都能看到新添加的元素.**
</code></pre><h4 id="map-1" tabindex="-1"><a class="header-anchor" href="#map-1" aria-hidden="true">#</a> Map</h4><ul><li>ConcurrentHashMap <ul><li>相当于线程安全的HashMap</li><li>通过<strong>锁分段</strong>来实现的。</li></ul></li><li>ConcurrentSkipListMap <ul><li>线程安全的<strong>有序</strong>的哈希表(相当于线程安全的TreeMap);</li><li>它继承于AbstractMap类，并且实现ConcurrentNavigableMap接口。ConcurrentSkipListMap是通过“跳表”来实现的，它支持并发。</li></ul></li><li>ConcurrentSkipListSet <ul><li>线程安全的<strong>有序</strong>的集合(相当于线程安全的TreeSet)；它继承于AbstractSet，并实现了NavigableSet接口。</li><li>ConcurrentSkipListSet是通过ConcurrentSkipListMap实现的，它也支持并发。</li></ul></li></ul><h3 id="使用collections工具类" tabindex="-1"><a class="header-anchor" href="#使用collections工具类" aria-hidden="true">#</a> 使用Collections工具类</h3><figure><img src="`+b+'" alt="image-20200304231547030" tabindex="0" loading="lazy"><figcaption>image-20200304231547030</figcaption></figure><figure><img src="'+g+`" alt="image-20200304231427865" tabindex="0" loading="lazy"><figcaption>image-20200304231427865</figcaption></figure><p>使用synchronized加锁。</p><p>但是这些同步类的并发效率并不是很高。</p><h3 id="常见的几个集合类" tabindex="-1"><a class="header-anchor" href="#常见的几个集合类" aria-hidden="true">#</a> 常见的几个集合类</h3><p><code>Vector</code>，<code>stack</code>,<code>hashtable</code></p><h2 id="迭代器-itertor-是什么" tabindex="-1"><a class="header-anchor" href="#迭代器-itertor-是什么" aria-hidden="true">#</a> 迭代器 Itertor 是什么</h2><h3 id="迭代器模式" tabindex="-1"><a class="header-anchor" href="#迭代器模式" aria-hidden="true">#</a> 迭代器模式</h3><p>它是 Java 中常用的设计模式之一。用于<strong>顺序访问集合对象的元素</strong>，无需知道集合对象的底层实现。</p><h3 id="iterable与iterator" tabindex="-1"><a class="header-anchor" href="#iterable与iterator" aria-hidden="true">#</a> Iterable与Iterator</h3><ul><li><strong>Iterable</strong> 实现这个接口的集合对象支持迭代，是可以迭代的。实现了这个可以配合foreach使用 <ul><li>util.collection继承Iterable</li></ul></li><li><strong>Iterator</strong> 迭代器，提供迭代机制的对象，具体如何迭代是这个Iterator接口规范的。</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">//Iterable JDK源码</span>
<span class="token comment">//可以通过成员内部类，方法内部类，甚至匿名内部类去实现Iterator</span>

<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Iterable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span>
<span class="token punctuation">{</span>

    <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="foreach和iterator的关系" tabindex="-1"><a class="header-anchor" href="#foreach和iterator的关系" aria-hidden="true">#</a> foreach和Iterator的关系：</h3><ul><li><code>for each</code>以用来处理集合中的每个元素而不用考虑集合定下标。就是为了让用Iterator简单。但是删除的时候，区别就是在remove，循环中调用集合remove会导致原集合变化导致错误，而应该用迭代器的remove方法。</li></ul><h3 id="使用for循环还是迭代器iterator" tabindex="-1"><a class="header-anchor" href="#使用for循环还是迭代器iterator" aria-hidden="true">#</a> 使用for循环还是迭代器Iterator？</h3><ul><li><strong>采用ArrayList对随机访问比较快，而for循环中的get()方法，采用的即是随机访问的方法，因此在ArrayList里，for循环较快</strong></li><li><strong>采用LinkedList则是顺序访问比较快，iterator中的next()方法，采用的即是顺序访问的方法，因此在LinkedList里，使用iterator较快</strong></li></ul><p>for循环适合访问顺序结构,可以根据下标快速获取指定元素.而Iterator 适合访问链式结构,因为迭代器是通过next()和Pre()来定位的.可以访问没有顺序的集合.</p><h3 id="iterator、listiterator" tabindex="-1"><a class="header-anchor" href="#iterator、listiterator" aria-hidden="true">#</a> Iterator、ListIterator</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ListIterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+y+'" alt="image-20200305110337107" tabindex="0" loading="lazy"><figcaption>image-20200305110337107</figcaption></figure><ul><li>都是接口，ListIterator继承Iterator</li><li>ListIterator可以双向移动。Iterator只能单项移动</li><li>且ListIterator可以添加、修改，而Iterator不能。</li></ul><h2 id="为什么基本类型不能做为hashmap的键值" tabindex="-1"><a class="header-anchor" href="#为什么基本类型不能做为hashmap的键值" aria-hidden="true">#</a> 为什么基本类型不能做为HashMap的键值？</h2><ul><li>Java中<strong>是使用泛型来约束 HashMap 中的key和value的类型的</strong>，HashMap&lt;K, V&gt;</li><li>泛型在Java的规定中必须是对象Object类型的，基本数据类型不是Object类型，不能作为键值</li><li>map.put(0, &quot;ConstXiong&quot;)中编译器已将 key 值 0 进行了自动装箱，变为了 Integer 类型</li></ul><h2 id="array-、arrays的关系" tabindex="-1"><a class="header-anchor" href="#array-、arrays的关系" aria-hidden="true">#</a> Array 、Arrays的关系</h2><p>Array是Java.lang,reflect</p><p>Arrays是数组工具类。</p><h2 id="同步容器-与-并发容器" tabindex="-1"><a class="header-anchor" href="#同步容器-与-并发容器" aria-hidden="true">#</a> 同步容器 与 并发容器</h2><h3 id="同步容器" tabindex="-1"><a class="header-anchor" href="#同步容器" aria-hidden="true">#</a> 同步容器</h3><p>同步容器直接保证了单个操作的线程安全性，但是无法保证复合操作的线程安全性。</p><p>虽然同步容器的所有方法都加了锁，但是对这些容器的复合操作无法保证其线程安全性。<strong>需要客户端通过主动加锁来保证。</strong></p><p>因为同步容器每一个方法都加锁，所以他的并发度较低。</p><p><strong>典型代表：</strong></p><ul><li>Vector</li><li>HashTable</li><li>Collections提供的静态方法创建的类synchronizedxxx</li></ul><h3 id="并发容器" tabindex="-1"><a class="header-anchor" href="#并发容器" aria-hidden="true">#</a> 并发容器</h3><p><strong>典型代表：</strong></p><ul><li>JUC下提供大量支持高效并发访问集合类。</li><li>Concurrentxxxx</li><li>CopyOnWritexxx</li></ul><p>Copy-On-Write容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。</p>',218),x=[w];function H(M,L){return a(),s("div",null,x)}const j=n(f,[["render",H],["__file","Java集合.html.vue"]]);export{j as default};
