import{_ as p}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as i,c,f as e}from"./app-_dQeDwys.js";const o="/assets/1394693-20190313112404138-453699301-Z48zGGu7.jpg",a="/assets/1394693-20190313144428316-1876685181-IZFimke2.jpg",t="/assets/1394693-20190313144444907-587721816-dEuKyopH.jpg",s="/assets/1394693-20190313144459679-1788954851-vtRuTLeg.jpg",r="/assets/1394693-20190313144510829-783768688-3xu1wvai.jpg",n={},u=e('<p>在linux系统中，提供了/proc目录下文件，显示系统的软硬件信息。如果想了解系统中CPU的提供商和相关配置信息，则可以查/proc/cpuinfo。但是此文件输出项较多，不易理解。例如我们想获取，有多少颗物理CPU，每个物理cpu核心数，以及超线程是否开启等信息，下面我们就看来一步一步的去探索。</p><h2 id="物理cpu、核数、逻辑cpu数的概念" tabindex="-1"><a class="header-anchor" href="#物理cpu、核数、逻辑cpu数的概念" aria-hidden="true">#</a> 物理CPU、核数、逻辑cpu数的概念</h2><p>①物理CPU数（physical id）：主板上实际插入的cpu数量，可以数不重复的 physical id 有几个</p><p>②CPU核心数（cpu cores）：单块CPU上面能处理数据的芯片组的数量，如双核、四核等</p><p>③逻辑CPU数：一般情况下，</p><p>逻辑CPU=物理CPU个数×每颗核数 　#不支持超线程技术或没有开启次技术</p><p>逻辑CPU=物理CPU个数×每颗核数 *2 　 #表示服务器的CPU支持超线程技术（简单来说，它可使处理器中的1 颗内核如2 颗内核那样在操作系统中发挥作用。这样一来，操作系统可使用的执行资源扩大了一倍，大幅提高了系统的整体性能）</p><h2 id="cpuinfo文件内容-涉及的项目解读" tabindex="-1"><a class="header-anchor" href="#cpuinfo文件内容-涉及的项目解读" aria-hidden="true">#</a> cpuinfo文件内容，涉及的项目解读</h2><p>话不多少，看图说话。下图是我负责维护的一台服务器的CPU信息。使用cat /proc/cpuinfo。足足输出1500+条记录。其中内容均和下图相似，不同的是“：”右边的信息不同。</p><figure><img src="'+o+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>下面对上图的输出内容进行相应解释</p><p>processor　：系统中逻辑处理核心数的编号，从0开始排序。</p><p>vendor_id　：CPU制造商</p><p>cpu family　：CPU产品系列代号</p><p>model　　　：CPU属于其系列中的哪一代的代号</p><p>model name：CPU属于的名字及其编号、标称主频</p><p>stepping　 ：CPU属于制作更新版本</p><p>cpu MHz　 ：CPU的实际使用主频</p><p>cache size ：CPU二级缓存大小</p><p>physical id ：单个物理CPU的标号</p><p>siblings ：单个物理CPU的逻辑CPU数。siblings=cpu cores [*2]。</p><p>core id ：当前物理核在其所处CPU中的编号，这个编号不一定连续。</p><p>cpu cores ：该逻辑核所处CPU的物理核数。比如此处cpu cores 是4个，那么对应core id 可能是 1、3、4、5。</p><p>apicid ：用来区分不同逻辑核的编号，系统中每个逻辑核的此编号必然不同，此编号不一定连续</p><p>fpu ：是否具有浮点运算单元（Floating Point Unit）</p><p>fpu_exception ：是否支持浮点计算异常</p><p>cpuid level ：执行cpuid指令前，eax寄存器中的值，根据不同的值cpuid指令会返回不同的内容</p><p>wp ：表明当前CPU是否在内核态支持对用户空间的写保护（Write Protection）</p><p>flags ：当前CPU支持的功能</p><p>bogomips：在系统内核启动时粗略测算的CPU速度（Million Instructions Per Second</p><p>clflush size ：每次刷新缓存的大小单位</p><p>cache_alignment ：缓存地址对齐单位</p><p>address sizes ：可访问地址空间位数</p><p>power management ：对能源管理的支持</p><h2 id="快速查询想要获取的信息" tabindex="-1"><a class="header-anchor" href="#快速查询想要获取的信息" aria-hidden="true">#</a> 快速查询想要获取的信息</h2><p>①查询系统有几颗物理CPU：cat /proc/cpuinfo | grep &quot;physical id&quot; |sort |uniq</p><figure><img src="'+a+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>②查询系统每颗物理CPU的核心数：cat /proc/cpuinfo | grep &quot;cpu cores&quot; | uniq</p><figure><img src="'+t+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>③查询系统的每颗物理CPU核心是否启用超线程技术。如果启用此技术那么，每个物理核心又可分为两个逻辑处理器。</p><p>cat /proc/cpuinfo | grep -e &quot;cpu cores&quot; -e &quot;siblings&quot; | sort | uniq</p><figure><img src="'+s+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>如果cpu cores数量和siblings数量一致，则没有启用超线程，否则超线程被启用。</p><p>④查询系统具有多少个逻辑CPU：cat /proc/cpuinfo | grep &quot;processor&quot; | wc -l</p><figure><img src="'+r+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure>',45),g=[u];function d(l,f){return i(),c("div",null,g)}const U=p(n,[["render",d],["__file","CPU.html.vue"]]);export{U as default};
