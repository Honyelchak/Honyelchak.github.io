import{_ as n}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as a,c as s,f as e}from"./app-2Xbp2Heq.js";const t="/assets/image-20230814160814970-KwcpQ7lH.png",o="/assets/image-20230814161358152-KBC6X-Ud.png",i="/assets/image-20230816223225645-N02rY2sJ.png",p="/assets/image-20230816215631442-wM5YOWeM.png",c={},r=e(`<p>通常，我们说的Spring启动，就是构造ApplicationContext对象以及调用refresh()方法的过程。</p><blockquote><p>创建一个BeanFactory</p><ol><li>BeanDefinition -&gt; beanDefinitionMap</li><li>beanpostProcessor -&gt; beanpostProcessors</li><li>单例池等</li></ol><p>解析配置类， 扫描，</p></blockquote><p>首先，Spring启动过程主要做了这么几 件事情：</p><ol><li><p><code>this()</code>执行时，会先调父类构造方法，构造一个BeanFactory对象</p><ol><li><p>默认在父类<code>GenerircApplicationContext</code>的无参构造方法中，会创建一个<code>DefaultListableBeanFactory</code></p><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code>	public GenericApplicationContext() {
		this.beanFactory = new DefaultListableBeanFactory();
	}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>DefaultListableBeanFactory类中有<code>BeanDefinitionMap</code></p></li></ol></li><li><p><code>register(componentClasses);</code>将类注册为BeanDefinition，并保存在BeanDefinitionMap中</p></li><li><p>解析配置类，得到BeanDefinition，并注册到BeanFactory中</p><ol><li>解析@ComponentScan，此时就会完成扫描</li><li>解析@Import</li><li>解析@Bean</li></ol></li><li><p>因为ApplicationContext还支持国际化，所以还需要初始化MessageSource对象</p></li><li><p>因为ApplicationC ontext还支持事件机制，所以还需要初始化ApplicationEventMulticaster对象</p></li><li><p>把用户定义的ApplicationListener对象添加到ApplicationContext中，等Spring启动完了就要发布事件了</p></li><li><p>创建非懒加载的单例Bean对象，并存在BeanFactory的单例池中。</p></li><li><p>调用Lifecycle Bean的start()方法</p></li><li><p>发布ContextRefreshedEvent事件</p></li></ol><p>由于Spring启动过程中要创建非懒加载的单例Bean对象，那么就需要用到BeanPostProcessor，所以Spring在启动过程中就需要做两件事：</p><ol><li>生成默认的BeanPostProcessor对象，并添加到BeanFactory中 <ol><li>AutowiredAnnotationBeanPostProcessor：处理@Autowired、@Value</li><li>CommonAnnotationBeanPostProcessor：处理@Resource、@PostConstruct、@PreDestroy</li><li>ApplicationContextAwareProcessor：处理ApplicationContextAware等回调</li></ol></li><li>找到外部用户所定义的BeanPostProcessor对象（类型为BeanPostProcessor的Bean对象），并添加到BeanFactory中</li></ol><h2 id="beanfactorypostprocessor" tabindex="-1"><a class="header-anchor" href="#beanfactorypostprocessor" aria-hidden="true">#</a> BeanFactoryPostProcessor</h2><ul><li>BeanPostProcessor表示Bean的后置处理器，是用来对Bean进行加工的</li><li>BeanFactoryPostProcessor理解为BeanFactory的后置处理器，用来用对BeanFactory进行加工的</li></ul><p>Spring支持用户定义BeanFactoryPostProcessor的实现类Bean，来对BeanFactory进行加工，比如：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ZhouyuBeanFactoryPostProcessor</span> <span class="token keyword">implements</span> <span class="token class-name">BeanFactoryPostProcessor</span> <span class="token punctuation">{</span>

	<span class="token annotation punctuation">@Override</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">postProcessBeanFactory</span><span class="token punctuation">(</span><span class="token class-name">ConfigurableListableBeanFactory</span> beanFactory<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">{</span>
		<span class="token class-name">BeanDefinition</span> beanDefinition <span class="token operator">=</span> beanFactory<span class="token punctuation">.</span><span class="token function">getBeanDefinition</span><span class="token punctuation">(</span><span class="token string">&quot;userService&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		beanDefinition<span class="token punctuation">.</span><span class="token function">setAutowireCandidate</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上代码，就利用了BeanFactoryPostProcessor来拿到BeanFactory，然后获取BeanFactory内的某个BeanDefinition对象并进行修改，注意这一步是发生在Spring启动时，创建单例Bean之前的，所以此时对BeanDefinition就行修改是会生效的。</p><p>注意：在ApplicationContext内部有一个核心的<code>DefaultListableBeanFactory</code>，它实现了<code>ConfigurableListableBeanFactory</code>和<code>BeanDefinitionRegistry</code>接口，所以ApplicationContext和<code>DefaultListableBeanFactory</code>是可以注册BeanDefinition的，但是<code>ConfigurableListableBeanFactory</code>是不能注册BeanDefinition的，只能获取BeanDefinition，然后做修改。</p><p>所以Spring还提供了一个BeanFactoryPostProcessor的子接口：BeanDefinitionRegistryPostProcessor</p><h3 id="beandefinitionregistrypostprocessor" tabindex="-1"><a class="header-anchor" href="#beandefinitionregistrypostprocessor" aria-hidden="true">#</a> BeanDefinitionRegistryPostProcessor</h3><p>我们可以看到BeanDefinitionRegistryPostProcessor继承了BeanFactoryPostProcessor接口，并新增了一个方法，注意方法的参数为BeanDefinitionRegistry，所以如果我们提供一个类来实现BeanDefinitionRegistryPostProcessor，那么在postProcessBeanDefinitionRegistry()方法中就可以注册BeanDefinition了。比如：</p><h2 id="如何理解refresh" tabindex="-1"><a class="header-anchor" href="#如何理解refresh" aria-hidden="true">#</a> 如何理解refresh()？</h2><p>这是ConfigurableApplicationContext接口上refresh()方法的注释，意思是：</p><blockquote><p>加载或刷新持久化的配置，可能是XML文件、属性文件或关系数据库中存储的。由于这是一个启动方法，如果失败，它应该销毁已经创建的单例，以避免暂用资源。换句话说，<code>在调用该方法之后，应该实例化所有的单例，或者根本不实例化单例 。</code></p></blockquote><p>有个理念需要注意：</p><blockquote><p>ApplicationContext关闭之后不代表JVM也关闭了，ApplicationContext是属于JVM的，说白了ApplicationContext也是JVM中的一个对象。</p><p>在Spring的设计中，也提供可以刷新的ApplicationContext和不可以刷新的ApplicationContext。</p><p>比如：</p><ul><li><code>AbstractRefreshableApplicationContext extends AbstractApplicationContext</code>就是可以刷新的</li><li><code>GenericApplicationContext extends AbstractApplicationContext</code>就是不可以刷新的 <ul><li>默认<code>AnnotationConfigApplicationContext</code>就是不可以二次刷新的。</li></ul></li></ul><figure><img src="`+t+'" alt="image-20230814160814970" tabindex="0" loading="lazy"><figcaption>image-20230814160814970</figcaption></figure><p><strong>Ps：<strong>上面说的</strong>不能刷新是指不能重复刷新，只能调用一次refresh方法，第二次时会报错。</strong></p><p>还有一个小细节：</p><ol><li>上边这个执行的过程中会创建好BeanFactory，下边那个不会创建Bean工厂。</li><li><img src="'+o+`" alt="image-20230814161358152" tabindex="0" loading="lazy"><figcaption>image-20230814161358152</figcaption></li></ol></blockquote><p>就是不可以刷新的。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">AnnotationConfigApplicationContext</span>继承的是<span class="token class-name">GenericApplicationContext</span>，所以它是不能刷新的。

<span class="token class-name">AnnotationConfigWebApplicationContext</span>继承的是<span class="token class-name">AbstractRefreshableWebApplicationContext</span>，所以它是可以刷的。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>AnnotationConfigApplicationContext继承的是GenericApplicationContext，所以它是不能刷新的。</p><p>AnnotationConfigWebApplicationContext继承的是AbstractRefreshableWebApplicationContext，所以它是可以刷的。</p><p>上面说的不能刷新是指不能重复刷新，只能调用一次refresh方法，第二次时会报错。</p><p>refresh()底层原理流程</p><p>底层原理流程图：https://www.processon.com/view/link/5f60a7d71e08531edf26a919</p><p>下面以AnnotationConfigApplicationContext为例子，来介绍refresh的底层原理。</p><p>1在调用AnnotationConfigApplicationContext的构造方法之前，会调用父类GenericApplicationContext的无参构造方法，会构造一个BeanFactory，为DefaultListableBeanFactory。</p><p>2构造AnnotatedBeanDefinitionReader（主要作用添加一些基础的PostProcessor，同时可以通过reader进行BeanDefinition的注册），同时对BeanFactory进行设置和添加PostProcessor（后置处理器）</p><p>a设置dependencyComparator：AnnotationAwareOrderComparator，它是一个Comparator，是用来进行排序的，会获取某个对象上的Order注解或者通过实现Ordered接口所定义的值进行排序，在日常开发中可以利用这个类来进行排序。</p><p>b设置autowireCandidateResolver：ContextAnnotationAutowireCandidateResolver，用来解析某个Bean能不能进行自动注入，比如某个Bean的autowireCandidate属性是否等于true</p><p>c向BeanFactory中添加ConfigurationClassPostProcessor对应的BeanDefinition，它是一个BeanDefinitionRegistryPostProcessor，并且实现了PriorityOrdered接口</p><p>d向BeanFactory中添加AutowiredAnnotationBeanPostProcessor对应的BeanDefinition，它是一个InstantiationAwareBeanPostProcessorAdapter，MergedBeanDefinitionPostProcessor</p><p>e向BeanFactory中添加CommonAnnotationBeanPostProcessor对应的BeanDefinition，它是一个InstantiationAwareBeanPostProcessor，InitDestroyAnnotationBeanPostProcessor</p><p>f向BeanFactory中添加EventListenerMethodProcessor对应的BeanDefinition，它是一个BeanFactoryPostProcessor，SmartInitializingSingleton</p><p>g向BeanFactory中添加DefaultEventListenerFactory对应的BeanDefinition，它是一个EventListenerFactory</p><p>3构造ClassPathBeanDefinitionScanner（主要作用可以用来扫描得到并注册BeanDefinition），同时进行设置：</p><p>a设置this.includeFilters = AnnotationTypeFilter(Component.class)</p><p>b设置environment</p><p>c设置resourceLoader</p><p>4利用reader注册AppConfig为BeanDefinition，类型为AnnotatedGenericBeanDefinition</p><p><strong>5</strong>接下来就是调用refresh方法</p><p>6prepareRefresh()：</p><p>a记录启动时间</p><p>b可以允许子容器设置一些内容到Environment中</p><p>c验证Environment中是否包括了必须要有的属性</p><p>7obtainFreshBeanFactory()：进行BeanFactory的refresh，在这里会去调用子类的refreshBeanFactory方法，具体子类是怎么刷新的得看子类，然后再调用子类的getBeanFactory方法，重新得到一个BeanFactory</p><p>8prepareBeanFactory(beanFactory)：</p><p>a设置beanFactory的类加载器</p><p>b设置表达式解析器：StandardBeanExpressionResolver，用来解析Spring中的表达式</p><p>c添加PropertyEditorRegistrar：ResourceEditorRegistrar，PropertyEditor类型转化器注册器，用来注册一些默认的PropertyEditor</p><p>d添加一个Bean的后置处理器：ApplicationContextAwareProcessor，是一个BeanPostProcessor，用来执行EnvironmentAware、ApplicationEventPublisherAware等回调方法</p><p>e添加ignoredDependencyInterface：可以向这个属性中添加一些接口，如果某个类实现了这个接口，并且这个类中的某些set方法在接口中也存在，那么这个set方法在自动注入的时候是不会执行的，比如EnvironmentAware这个接口，如果某个类实现了这个接口，那么就必须实现它的setEnvironment方法，而这是一个set方法，和Spring中的autowire是冲突的，那么Spring在自动注入时是不会调用setEnvironment方法的，而是等到回调Aware接口时再来调用（注意，这个功能仅限于xml的autowire，@Autowired注解是忽略这个属性的）</p><p>ⅰEnvironmentAware</p><p>ⅱEmbeddedValueResolverAware</p><p>ⅲResourceLoaderAware</p><p>ⅳApplicationEventPublisherAware</p><p>ⅴMessageSourceAware</p><p>ⅵApplicationContextAware</p><p>ⅶ另外其实在构造BeanFactory的时候就已经提前添加了另外三个：</p><p>ⅷBeanNameAware</p><p>ⅸBeanClassLoaderAware</p><p>XBeanFactoryAware</p><p>f添加resolvableDependencies：在byType进行依赖注入时，会先从这个属性中根据类型找bean</p><p>ⅰBeanFactory.class：当前BeanFactory对象</p><p>ⅱResourceLoader.class：当前ApplicationContext对象</p><p>ⅲApplicationEventPublisher.class：当前ApplicationContext对象</p><p>ⅳApplicationContext.class：当前ApplicationContext对象</p><p>g添加一个Bean的后置处理器：ApplicationListenerDetector，是一个BeanPostProcessor，用来判断某个Bean是不是ApplicationListener，如果是则把这个Bean添加到ApplicationContext中去，注意一个ApplicationListener只能是单例的</p><p>h添加一个Bean的后置处理器：LoadTimeWeaverAwareProcessor，是一个BeanPostProcessor，用来判断某个Bean是不是实现了LoadTimeWeaverAware接口，如果实现了则把ApplicationContext中的loadTimeWeaver回调setLoadTimeWeaver方法设置给该Bean。</p><p>i添加一些单例bean到单例池：</p><p>ⅰ&quot;environment&quot;：Environment对象</p><p>ⅱ&quot;systemProperties&quot;：System.getProperties()返回的Map对象</p><p>ⅲ&quot;systemEnvironment&quot;：System.getenv()返回的Map对象</p><p>9postProcessBeanFactory(beanFactory) ： 提供给AbstractApplicationContext的子类进行扩展，具体的子类，可以继续向BeanFactory中再添加一些东西</p><p>10invokeBeanFactoryPostProcessors(beanFactory)：执行BeanFactoryPostProcessor</p><p>a此时在BeanFactory中会存在一个BeanFactoryPostProcessor：ConfigurationClassPostProcessor，它也是一个BeanDefinitionRegistryPostProcessor</p><p><strong>b</strong>第一阶段</p><p>c从BeanFactory中找到类型为BeanDefinitionRegistryPostProcessor的beanName，也就是ConfigurationClassPostProcessor， 然后调用BeanFactory的getBean方法得到实例对象</p><p>d执行ConfigurationClassPostProcessor的postProcessBeanDefinitionRegistry()方法:</p><p>ⅰ解析AppConfig类</p><p>ⅱ扫描得到BeanDefinition并注册</p><p>ⅲ解析@Import，@Bean等注解得到BeanDefinition并注册</p><p>ⅳ详细的看另外的笔记，专门分析了ConfigurationClassPostProcessor是如何工作的</p><p>ⅴ在这里，我们只需要知道在这一步会去得到BeanDefinition，而这些BeanDefinition中可能存在BeanFactoryPostProcessor和BeanDefinitionRegistryPostProcessor，所以执行完ConfigurationClassPostProcessor的postProcessBeanDefinitionRegistry()方法后，还需要继续执行其他BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry()方法</p><p>e执行其他BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry()方法</p><p>f执行所有BeanDefinitionRegistryPostProcessor的postProcessBeanFactory()方法</p><p><strong>g</strong>第二阶段</p><p>h从BeanFactory中找到类型为BeanFactoryPostProcessor的beanName，而这些BeanFactoryPostProcessor包括了上面的BeanDefinitionRegistryPostProcessor</p><p>i执行还没有执行过的BeanFactoryPostProcessor的postProcessBeanFactory()方法</p><p>11到此，所有的BeanFactoryPostProcessor的逻辑都执行完了，主要做的事情就是得到BeanDefinition并注册到BeanFactory中</p><p>12registerBeanPostProcessors(beanFactory)：因为上面的步骤完成了扫描，这个过程中程序员可能自己定义了一些BeanPostProcessor，在这一步就会把BeanFactory中所有的BeanPostProcessor找出来并实例化得到一个对象，并添加到BeanFactory中去（属性beanPostProcessors），最后再重新添加一个ApplicationListenerDetector对象（之前其实就添加了过，这里是为了把ApplicationListenerDetector移动到最后）</p><p>13initMessageSource()：如果BeanFactory中存在一个叫做&quot;messageSource&quot;的BeanDefinition，那么就会把这个Bean对象创建出来并赋值给ApplicationContext的messageSource属性，让ApplicationContext拥有国际化的功能</p><p>14initApplicationEventMulticaster()：如果BeanFactory中存在一个叫做&quot;applicationEventMulticaster&quot;的BeanDefinition，那么就会把这个Bean对象创建出来并赋值给ApplicationContext的applicationEventMulticaster属性，让ApplicationContext拥有事件发布的功能</p><p>15onRefresh()：提供给AbstractApplicationContext的子类进行扩展，没用</p><p>16registerListeners()：从BeanFactory中获取ApplicationListener类型的beanName，然后添加到ApplicationContext中的事件广播器applicationEventMulticaster中去，到这一步因为FactoryBean还没有调用getObject()方法生成Bean对象，所以这里要在根据类型找一下ApplicationListener，记录一下对应的beanName</p><p>17finishBeanFactoryInitialization(beanFactory)：完成BeanFactory的初始化，主要就是实例化非懒加载的单例Bean，单独的笔记去讲。</p><p>18finishRefresh()：BeanFactory的初始化完后，就到了Spring启动的最后一步了</p><p>a设置ApplicationContext的lifecycleProcessor，默认情况下设置的是DefaultLifecycleProcessor</p><p>b调用lifecycleProcessor的onRefresh()方法，如果是DefaultLifecycleProcessor，那么会获取所有类型为Lifecycle的Bean对象，然后调用它的start()方法，这就是ApplicationContext的生命周期扩展机制</p><p>c发布ContextRefreshedEvent事件</p><p>执行BeanFactoryPostProcessor</p><p>1执行通过ApplicationContext添加进来的BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry()方法</p><p>2执行BeanFactory中实现了PriorityOrdered接口的BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry()方法</p><p>3执行BeanFactory中实现了Ordered接口的BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry()方法</p><p>4执行BeanFactory中其他的BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry()方法</p><p>5执行上面所有的BeanDefinitionRegistryPostProcessor的postProcessBeanFactory()方法</p><p>6执行通过ApplicationContext添加进来的BeanFactoryPostProcessor的postProcessBeanFactory()方法</p><p>7执行BeanFactory中实现了PriorityOrdered接口的BeanFactoryPostProcessor的postProcessBeanFactory()方法</p><p>8执行BeanFactory中实现了Ordered接口的BeanFactoryPostProcessor的postProcessBeanFactory()方法</p><p>9执行BeanFactory中其他的BeanFactoryPostProcessor的postProcessBeanFactory()方法</p><p>Lifecycle的使用</p><p>Lifecycle表示的是ApplicationContext的生命周期，可以定义一个SmartLifecycle来监听ApplicationContext的启动和关闭：</p><p>Java</p><h2 id="小问题" tabindex="-1"><a class="header-anchor" href="#小问题" aria-hidden="true">#</a> 小问题</h2><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Bean</span> <span class="token punctuation">(</span>autowired<span class="token punctuation">.</span><span class="token constant">BY_TYPE</span> <span class="token operator">=</span> <span class="token string">&quot;true&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token class-name">User</span>（）<span class="token punctuation">{</span>
   <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token keyword">implements</span> <span class="token class-name">EnvironmentWare</span><span class="token punctuation">{</span>
    
    <span class="token keyword">private</span> <span class="token class-name">Environment</span> environment<span class="token punctuation">;</span>
	<span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setEnvironment</span><span class="token punctuation">(</span><span class="token class-name">Environment</span> environment<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;xxxx&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>environment <span class="token operator">=</span> environment<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>


<span class="token comment">// 在这种情况下xxxx只会打印1次，因为autowired.BY_TYPE会在底层进行判断，set方法对应的type是否在ignoreDependencyInterface集合中，在的话就会跳过，然后在执行回调的时候进行注入。</span>


<span class="token comment">// 下面这种情况会打印两次</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token keyword">implements</span> <span class="token class-name">EnvironmentWare</span><span class="token punctuation">{</span>
    
    <span class="token keyword">private</span> <span class="token class-name">Environment</span> environment<span class="token punctuation">;</span>
	<span class="token annotation punctuation">@Override</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setEnvironment</span><span class="token punctuation">(</span><span class="token class-name">Environment</span> environment<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;xxxx&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>environment <span class="token operator">=</span> environment<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如何在代码中注入BeanFactory、ResourceLoader、ApplicationContext等对象</p><ol><li><p>利用回调，实现xxxAware</p></li><li><p>直接使用<code>@Autowired</code>，因为在<code>onrefeash() --&gt; prepareBeanFactory()</code>的过程中会将这几个类直接注入进去。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// BeanFactory interface not registered as resolvable type in a plain factory.</span>
		<span class="token comment">// MessageSource registered (and found for autowiring) as a bean.</span>
		beanFactory<span class="token punctuation">.</span><span class="token function">registerResolvableDependency</span><span class="token punctuation">(</span><span class="token class-name">BeanFactory</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>
		beanFactory<span class="token punctuation">.</span><span class="token function">registerResolvableDependency</span><span class="token punctuation">(</span><span class="token class-name">ResourceLoader</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		beanFactory<span class="token punctuation">.</span><span class="token function">registerResolvableDependency</span><span class="token punctuation">(</span><span class="token class-name">ApplicationEventPublisher</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		beanFactory<span class="token punctuation">.</span><span class="token function">registerResolvableDependency</span><span class="token punctuation">(</span><span class="token class-name">ApplicationContext</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><h2 id="事件" tabindex="-1"><a class="header-anchor" href="#事件" aria-hidden="true">#</a> 事件</h2><p>基本概念：</p><ul><li>ApplicationEventMulticaster事件发布器 <ul><li>默认情况下，各个监听器是串行执行的</li><li>当然也提供了异步执行监听器的接口(线程池)</li></ul></li><li>ApplicationListener事件监听器(需要程序员自己去实现) <ul><li>两种定义监听器的方法： <ul><li>实现<code>ApplicationListener</code>接口</li><li>在方法上加<code>@EventListener</code>注解</li></ul></li></ul></li></ul><h3 id="关于事件-4个相关的类" tabindex="-1"><a class="header-anchor" href="#关于事件-4个相关的类" aria-hidden="true">#</a> 关于事件(4个相关的类)</h3><p>按顺序添加：</p><ol><li><p>在创建reader的时候，会默认加入<code>EventListenerMethodProcessor</code>、<code>DefaultEventListenerFactory</code></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">AnnotatedBeanDefinitionReader</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">!</span><span class="token class-name">AnnotationConfigUtils</span><span class="token punctuation">.</span><span class="token function">registerAnnotationConfigProcessors</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>registry<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//----下边时具体的添加细节---</span>

<span class="token comment">// 注册EventListenerMethodProcessor类型的BeanDefinition，用来处理@EventListener注解的</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>registry<span class="token punctuation">.</span><span class="token function">containsBeanDefinition</span><span class="token punctuation">(</span><span class="token constant">EVENT_LISTENER_PROCESSOR_BEAN_NAME</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">RootBeanDefinition</span> def <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RootBeanDefinition</span><span class="token punctuation">(</span><span class="token class-name">EventListenerMethodProcessor</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    def<span class="token punctuation">.</span><span class="token function">setSource</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">;</span>
    beanDefs<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">registerPostProcessor</span><span class="token punctuation">(</span>registry<span class="token punctuation">,</span> def<span class="token punctuation">,</span> <span class="token constant">EVENT_LISTENER_PROCESSOR_BEAN_NAME</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 注册DefaultEventListenerFactory类型的BeanDefinition，用来处理@EventListener注解的</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>registry<span class="token punctuation">.</span><span class="token function">containsBeanDefinition</span><span class="token punctuation">(</span><span class="token constant">EVENT_LISTENER_FACTORY_BEAN_NAME</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">RootBeanDefinition</span> def <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RootBeanDefinition</span><span class="token punctuation">(</span><span class="token class-name">DefaultEventListenerFactory</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    def<span class="token punctuation">.</span><span class="token function">setSource</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">;</span>
    beanDefs<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">registerPostProcessor</span><span class="token punctuation">(</span>registry<span class="token punctuation">,</span> def<span class="token punctuation">,</span> <span class="token constant">EVENT_LISTENER_FACTORY_BEAN_NAME</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>在<code>onfresh()</code>中的<code>prepareBeanFactory()</code>方法添加了<code>ApplicationListenerDetector</code></p><ol><li>扫描所有实现ApplicationListener接口的监听器</li></ol></li><li><p>在<code>onfresh()</code>中的<code>initApplicationEventMulticaster()</code>方法中初始化了<code>ApplicationEventMulticaster</code></p></li></ol><h3 id="eventlistenermethodprocessor" tabindex="-1"><a class="header-anchor" href="#eventlistenermethodprocessor" aria-hidden="true">#</a> EventListenerMethodProcessor</h3><p>该Processor实现了<code>SmartInitializingSingleton</code>接口，所以在所有单例Bean实例化之后会执行<code>afterSingletonsInstantiated</code>方法</p><p>在该方法中会扫描所有的Bean，找到加有<code>@EventListener</code>注解的方法，最后利用EventListenerFactory来对加了@EventListener注解的方法生成ApplicationListener对象</p><h2 id="配置类解析过程" tabindex="-1"><a class="header-anchor" href="#配置类解析过程" aria-hidden="true">#</a> 配置类解析过程</h2><figure><img src="`+i+'" alt="image-20230816223225645" tabindex="0" loading="lazy"><figcaption>image-20230816223225645</figcaption></figure><p>关于配置类还有full、lite的区分()：</p><ul><li>full配置类(proxyBeanMethods == true)</li><li>lite配置类(proxyBeanMethods == false) <ul><li><ol><li><img src="'+p+'" alt="image-20230816215631442" tabindex="0" loading="lazy"><figcaption>image-20230816215631442</figcaption></li><li>有加了@Bean的方法</li></ol></li></ul></li></ul><p>认为是一个配置类，那么就会解析配置类。</p><p>当扫描配置类时，扫描到ComponentScan注解，就会触发扫描的逻辑</p><h3 id="" tabindex="-1"><a class="header-anchor" href="#" aria-hidden="true">#</a></h3><template></template><template><p>解析配置类中的@Bean，并没有真正处理，只是暂时找出来，生成BeanMethod，并存储起来</p><p>解析配置类所实现接口中的@Bean(<code>default</code>方法)，并没有真正处理，只是暂时找出来，生成BeanMethod，并存储起来</p><p>若有@Component，还有@Bean，也是可以的。</p></template>',137),l=[r];function u(d,k){return a(),s("div",null,l)}const y=n(c,[["render",u],["__file","Spring启动过程.html.vue"]]);export{y as default};
