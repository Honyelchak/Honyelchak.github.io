const l=JSON.parse(`{"key":"v-310e8740","path":"/interview/A4-Java/JVM/JVM.html","title":"概述","lang":"zh-CN","frontmatter":{"description":"概述 为什么说Java是跨平台的语言 当Java源代码成功编译为字节码后。如果想在不同的平台上运行，无须再次编译。 JVM：跨语言的平台 image-20230228222341988 Java虚拟机不和包括Java在内的任何语言绑定，他只与\\"Class文件\\"这种特定的二进制文件格式关联。根本不关心运行在其内部的程序到底是使用何种编程语言编写的，它只关心“字节码”文件。换句话说，只要语言能够将源代码编译为正确的Class文件，那就能够在JVM上执行。Java不是最强大的语言，但是JVM是最强大的虚拟机。 有哪些JVM Sun Classic VM --&gt;解释型 SUN公司的 HotSpot VM BEA 的 JRockit --&gt; 不包含解释器，服务器端，JMC IBM 的 J9 Microsoft JVM TaobaoJVM Graal VM --&gt; 2018年,“Run Programs Faster Anywhere” image-20230228225415108","head":[["meta",{"property":"og:url","content":"https://yuejinzhao.cn/interview/A4-Java/JVM/JVM.html"}],["meta",{"property":"og:site_name","content":"Honyelchak's Blog"}],["meta",{"property":"og:title","content":"概述"}],["meta",{"property":"og:description","content":"概述 为什么说Java是跨平台的语言 当Java源代码成功编译为字节码后。如果想在不同的平台上运行，无须再次编译。 JVM：跨语言的平台 image-20230228222341988 Java虚拟机不和包括Java在内的任何语言绑定，他只与\\"Class文件\\"这种特定的二进制文件格式关联。根本不关心运行在其内部的程序到底是使用何种编程语言编写的，它只关心“字节码”文件。换句话说，只要语言能够将源代码编译为正确的Class文件，那就能够在JVM上执行。Java不是最强大的语言，但是JVM是最强大的虚拟机。 有哪些JVM Sun Classic VM --&gt;解释型 SUN公司的 HotSpot VM BEA 的 JRockit --&gt; 不包含解释器，服务器端，JMC IBM 的 J9 Microsoft JVM TaobaoJVM Graal VM --&gt; 2018年,“Run Programs Faster Anywhere” image-20230228225415108"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-12-02T09:42:10.000Z"}],["meta",{"property":"article:author","content":"Honyelchak"}],["meta",{"property":"article:modified_time","content":"2023-12-02T09:42:10.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"概述\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-12-02T09:42:10.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Honyelchak\\",\\"url\\":\\"https://yuejinzhao.cn\\"}]}"]]},"headers":[{"level":2,"title":"简图","slug":"简图","link":"#简图","children":[]},{"level":2,"title":"详细图","slug":"详细图","link":"#详细图","children":[]},{"level":2,"title":"1.1 字节码文件怎么来的？","slug":"_1-1-字节码文件怎么来的","link":"#_1-1-字节码文件怎么来的","children":[]},{"level":2,"title":"程序计数器","slug":"程序计数器","link":"#程序计数器","children":[]},{"level":2,"title":"Java 虚拟机栈","slug":"java-虚拟机栈","link":"#java-虚拟机栈","children":[{"level":3,"title":"栈帧","slug":"栈帧","link":"#栈帧","children":[]},{"level":3,"title":"栈帧-局部变量表","slug":"栈帧-局部变量表","link":"#栈帧-局部变量表","children":[]},{"level":3,"title":"栈帧-操作数栈","slug":"栈帧-操作数栈","link":"#栈帧-操作数栈","children":[]},{"level":3,"title":"栈帧-动态链接","slug":"栈帧-动态链接","link":"#栈帧-动态链接","children":[]},{"level":3,"title":"栈帧-方法返回地址","slug":"栈帧-方法返回地址","link":"#栈帧-方法返回地址","children":[]},{"level":3,"title":"问题小结","slug":"问题小结","link":"#问题小结","children":[]}]},{"level":2,"title":"本地方法栈","slug":"本地方法栈","link":"#本地方法栈","children":[]},{"level":2,"title":"方法区","slug":"方法区","link":"#方法区","children":[]},{"level":2,"title":"运行时常量池","slug":"运行时常量池","link":"#运行时常量池","children":[]},{"level":2,"title":"直接内存","slug":"直接内存","link":"#直接内存","children":[]},{"level":2,"title":"堆 Heap","slug":"堆-heap","link":"#堆-heap","children":[{"level":3,"title":"对象分配金句","slug":"对象分配金句","link":"#对象分配金句","children":[]},{"level":3,"title":"OOM如何解决","slug":"oom如何解决","link":"#oom如何解决","children":[]},{"level":3,"title":"堆参数调优","slug":"堆参数调优","link":"#堆参数调优","children":[]},{"level":3,"title":"GC是什么","slug":"gc是什么","link":"#gc是什么","children":[]},{"level":3,"title":"GC","slug":"gc","link":"#gc","children":[]},{"level":3,"title":"垃圾回收算法","slug":"垃圾回收算法","link":"#垃圾回收算法","children":[]}]},{"level":2,"title":"判断一个对象是否可被回收","slug":"判断一个对象是否可被回收","link":"#判断一个对象是否可被回收","children":[{"level":3,"title":"1. 引用计数算法","slug":"_1-引用计数算法","link":"#_1-引用计数算法","children":[]},{"level":3,"title":"2. 可达性分析算法","slug":"_2-可达性分析算法","link":"#_2-可达性分析算法","children":[]},{"level":3,"title":"3. 方法区的回收","slug":"_3-方法区的回收","link":"#_3-方法区的回收","children":[]},{"level":3,"title":"4. finalize()","slug":"_4-finalize","link":"#_4-finalize","children":[]}]},{"level":2,"title":"引用类型","slug":"引用类型","link":"#引用类型","children":[{"level":3,"title":"1. 强引用","slug":"_1-强引用","link":"#_1-强引用","children":[]},{"level":3,"title":"2. 软引用","slug":"_2-软引用","link":"#_2-软引用","children":[]},{"level":3,"title":"3. 弱引用","slug":"_3-弱引用","link":"#_3-弱引用","children":[]},{"level":3,"title":"4. 虚引用","slug":"_4-虚引用","link":"#_4-虚引用","children":[]}]},{"level":2,"title":"垃圾收集算法","slug":"垃圾收集算法","link":"#垃圾收集算法","children":[{"level":3,"title":"1. 标记 - 清除","slug":"_1-标记-清除","link":"#_1-标记-清除","children":[]},{"level":3,"title":"2. 标记 - 整理","slug":"_2-标记-整理","link":"#_2-标记-整理","children":[]},{"level":3,"title":"3. 复制","slug":"_3-复制","link":"#_3-复制","children":[]},{"level":3,"title":"4. 分代收集","slug":"_4-分代收集","link":"#_4-分代收集","children":[]}]},{"level":2,"title":"垃圾收集器","slug":"垃圾收集器","link":"#垃圾收集器","children":[{"level":3,"title":"1. Serial 收集器","slug":"_1-serial-收集器","link":"#_1-serial-收集器","children":[]},{"level":3,"title":"2. ParNew 收集器","slug":"_2-parnew-收集器","link":"#_2-parnew-收集器","children":[]},{"level":3,"title":"3. Parallel Scavenge 收集器","slug":"_3-parallel-scavenge-收集器","link":"#_3-parallel-scavenge-收集器","children":[]},{"level":3,"title":"4. Serial Old 收集器","slug":"_4-serial-old-收集器","link":"#_4-serial-old-收集器","children":[]},{"level":3,"title":"5. Parallel Old 收集器","slug":"_5-parallel-old-收集器","link":"#_5-parallel-old-收集器","children":[]},{"level":3,"title":"6. CMS 收集器","slug":"_6-cms-收集器","link":"#_6-cms-收集器","children":[]},{"level":3,"title":"7. G1 收集器","slug":"_7-g1-收集器","link":"#_7-g1-收集器","children":[]}]},{"level":2,"title":"Minor GC 和 Full GC","slug":"minor-gc-和-full-gc","link":"#minor-gc-和-full-gc","children":[]},{"level":2,"title":"内存分配策略","slug":"内存分配策略","link":"#内存分配策略","children":[{"level":3,"title":"1. 对象优先在 Eden 分配","slug":"_1-对象优先在-eden-分配","link":"#_1-对象优先在-eden-分配","children":[]},{"level":3,"title":"2. 大对象直接进入老年代","slug":"_2-大对象直接进入老年代","link":"#_2-大对象直接进入老年代","children":[]},{"level":3,"title":"3. 长期存活的对象进入老年代","slug":"_3-长期存活的对象进入老年代","link":"#_3-长期存活的对象进入老年代","children":[]},{"level":3,"title":"4. 动态对象年龄判定","slug":"_4-动态对象年龄判定","link":"#_4-动态对象年龄判定","children":[]},{"level":3,"title":"5. 空间分配担保","slug":"_5-空间分配担保","link":"#_5-空间分配担保","children":[]}]},{"level":2,"title":"Full GC 的触发条件","slug":"full-gc-的触发条件","link":"#full-gc-的触发条件","children":[{"level":3,"title":"1. 调用 System.gc()","slug":"_1-调用-system-gc","link":"#_1-调用-system-gc","children":[]},{"level":3,"title":"2. 老年代空间不足","slug":"_2-老年代空间不足","link":"#_2-老年代空间不足","children":[]},{"level":3,"title":"3. 空间分配担保失败","slug":"_3-空间分配担保失败","link":"#_3-空间分配担保失败","children":[]},{"level":3,"title":"4. JDK 1.7 及以前的永久代空间不足","slug":"_4-jdk-1-7-及以前的永久代空间不足","link":"#_4-jdk-1-7-及以前的永久代空间不足","children":[]},{"level":3,"title":"5. Concurrent Mode Failure","slug":"_5-concurrent-mode-failure","link":"#_5-concurrent-mode-failure","children":[]}]},{"level":2,"title":"类的生命周期","slug":"类的生命周期","link":"#类的生命周期","children":[]},{"level":2,"title":"类加载过程","slug":"类加载过程","link":"#类加载过程","children":[{"level":3,"title":"1. 加载","slug":"_1-加载","link":"#_1-加载","children":[]},{"level":3,"title":"2. 验证","slug":"_2-验证","link":"#_2-验证","children":[]},{"level":3,"title":"3. 准备","slug":"_3-准备","link":"#_3-准备","children":[]},{"level":3,"title":"4. 解析","slug":"_4-解析","link":"#_4-解析","children":[]},{"level":3,"title":"5. 初始化","slug":"_5-初始化","link":"#_5-初始化","children":[]}]},{"level":2,"title":"类初始化时机","slug":"类初始化时机","link":"#类初始化时机","children":[{"level":3,"title":"1. 主动引用","slug":"_1-主动引用","link":"#_1-主动引用","children":[]},{"level":3,"title":"2. 被动引用","slug":"_2-被动引用","link":"#_2-被动引用","children":[]}]},{"level":2,"title":"类与类加载器","slug":"类与类加载器","link":"#类与类加载器","children":[]},{"level":2,"title":"类加载器分类","slug":"类加载器分类","link":"#类加载器分类","children":[]},{"level":2,"title":"双亲委派模型","slug":"双亲委派模型","link":"#双亲委派模型","children":[{"level":3,"title":"1. 工作过程","slug":"_1-工作过程","link":"#_1-工作过程","children":[]},{"level":3,"title":"2. 好处","slug":"_2-好处","link":"#_2-好处","children":[]},{"level":3,"title":"3. 实现","slug":"_3-实现","link":"#_3-实现","children":[]}]},{"level":2,"title":"自定义类加载器实现","slug":"自定义类加载器实现","link":"#自定义类加载器实现","children":[]},{"level":2,"title":"finalize作用","slug":"finalize作用","link":"#finalize作用","children":[]},{"level":2,"title":"几种常量池的区别","slug":"几种常量池的区别","link":"#几种常量池的区别","children":[{"level":3,"title":"1、Class文件常量池","slug":"_1、class文件常量池","link":"#_1、class文件常量池","children":[]},{"level":3,"title":"2、 运行时常量池(方法区)","slug":"_2、-运行时常量池-方法区","link":"#_2、-运行时常量池-方法区","children":[]},{"level":3,"title":"3、字符串常量池","slug":"_3、字符串常量池","link":"#_3、字符串常量池","children":[]},{"level":3,"title":"String的intern方法","slug":"string的intern方法","link":"#string的intern方法","children":[]},{"level":3,"title":"JVM堆栈的区别","slug":"jvm堆栈的区别","link":"#jvm堆栈的区别","children":[]}]}],"git":{"createdTime":1701499503000,"updatedTime":1701510130000,"contributors":[{"name":"honyelchak","email":"554417388@qq.com","commits":2}]},"readingTime":{"minutes":49.99,"words":14997},"filePathRelative":"interview/A4-Java/JVM/JVM.md","localizedDate":"2023年12月2日","excerpt":"<h1> 概述</h1>\\n<ol>\\n<li>\\n<p>为什么说Java是跨平台的语言</p>\\n<ul>\\n<li>当Java源代码成功编译为字节码后。如果想在不同的平台上运行，无须再次编译。</li>\\n</ul>\\n</li>\\n<li>\\n<p>JVM：跨语言的平台</p>\\n<ol>\\n<li><figcaption>image-20230228222341988</figcaption></li>\\n<li>Java虚拟机不和包括Java在内的任何语言绑定，他只与\\"Class文件\\"这种特定的二进制文件格式关联。<strong>根本不关心运行在其内部的程序到底是使用何种编程语言编写的</strong>，它只关心“字节码”文件。换句话说，只要语言能够将源代码编译为正确的Class文件，那就能够在JVM上执行。Java不是最强大的语言，但是JVM是最强大的虚拟机。</li>\\n</ol>\\n</li>\\n<li>\\n<p>有哪些JVM</p>\\n<ul>\\n<li>Sun Classic VM  --&gt;解释型</li>\\n<li>SUN公司的 HotSpot VM</li>\\n<li>BEA 的 JRockit  --&gt; 不包含解释器，服务器端，JMC</li>\\n<li>IBM 的 J9</li>\\n<li>Microsoft JVM</li>\\n<li>TaobaoJVM</li>\\n<li>Graal VM --&gt; 2018年,<strong>“Run Programs Faster Anywhere”</strong></li>\\n<li><figcaption>image-20230228225415108</figcaption></li>\\n</ul>\\n</li>\\n</ol>","autoDesc":true}`);export{l as data};
