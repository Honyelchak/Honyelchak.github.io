import{_ as a}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as e,c as r,f as i}from"./app-XffPLay1.js";const t={},n=i('<h2 id="树" tabindex="-1"><a class="header-anchor" href="#树" aria-hidden="true">#</a> 树</h2><h3 id="二叉查找树-binary-search-tree" tabindex="-1"><a class="header-anchor" href="#二叉查找树-binary-search-tree" aria-hidden="true">#</a> 二叉查找树(Binary Search Tree)</h3><p>二叉查找树也称为<strong>有序二叉查找树</strong>。</p><p>任何一个结点，<strong>左比他小，右比他大</strong>，标准搜索二叉树是没有重复值的。</p><p>查数很方便，如果左子树和右子树高度差不超过一，每次搜索都筛选掉一半了。如果不平衡，会退变为O(n)的算法。</p><figure><img src="https://img2018.cnblogs.com/blog/1135185/201902/1135185-20190226100951078-767929670.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h4 id="局限及应用" tabindex="-1"><a class="header-anchor" href="#局限及应用" aria-hidden="true">#</a> 局限及应用</h4><p>一个二叉查找树是由n个节点<strong>随机构成</strong>,所以，对于某些情况,二叉查找树会退化成一个有n个节点的线性链.如下图:</p><figure><img src="https://img-blog.csdn.net/20160717085412308" alt="这里写图片描述" tabindex="0" loading="lazy"><figcaption>这里写图片描述</figcaption></figure><p>b图为一个普通的二叉查找树,大家看a图,如果我们的根节点选择是最小或者最大的数,那么二叉查找树就完全退化成了线性结构,因此,在二叉查找树的基础上,<strong>又出现了AVL树,红黑树</strong>,它们两个都是<strong>基于二叉查找树,只是在二叉查找树的基础上又对其做了限制.</strong></p><h3 id="avl" tabindex="-1"><a class="header-anchor" href="#avl" aria-hidden="true">#</a> AVL</h3><p>带有平衡条件的二叉查找树，<strong>每一个结点左右子树的高度差不能高于1。</strong></p><p>不管我们是执行插入还是删除操作,只要不满足上面的条件,就要通过旋转来保持平衡,而旋转是非常耗时的,由此我们可以知道AVL树适合用于插入删除次数比较少，但查找多的情况。</p><figure><img src="https://img-blog.csdn.net/20160717080221088" alt="这里写图片描述" tabindex="0" loading="lazy"><figcaption>这里写图片描述</figcaption></figure><p>平衡性高度严苛，任何节点高度差都不超过一。O(logn)，很可能调整频率高。</p><h4 id="局限缺点" tabindex="-1"><a class="header-anchor" href="#局限缺点" aria-hidden="true">#</a> 局限缺点</h4><p>由于维护这种高度平衡**所付出的代价比从中获得的效率收益还大,**故而实际的应用不多，更多的地方是用追求局部而不是非常严格整体平衡的红黑树.当然,如果应用场景中对插入删除不频繁,只是对查找要求较高,那么AVL还是较优于红黑树.</p><h3 id="红黑树" tabindex="-1"><a class="header-anchor" href="#红黑树" aria-hidden="true">#</a> 红黑树</h3><p>一种二叉查找树,但在每个节点增加一个存储位表示节点的颜色,可以是red或black. 通过对任何一条从根到叶子的路径上各个节点着色的方式的限制,红黑树确保没有一条路径会比其它路径长出两倍。它是一种弱平衡二叉树(<strong>由于是弱平衡,可以推出,相同的节点情况下,AVL树的高度低于红黑树</strong></p><p>相对于要求严格的<strong>AVL树</strong>来说,它的<strong>旋转次数变少</strong>,所以对于<strong>搜索,插入,删除操作多</strong>的情况下,我们就用红黑树。</p><p>阉割了平衡树，每个节点染上色，头节点黑，叶节点黑，相邻不能出现红色节点。任何一条链，要求黑色的数量不能超过一。如果尽最大能力插入红，最长和最短链的长度差也不会超过两倍。</p><h4 id="性质" tabindex="-1"><a class="header-anchor" href="#性质" aria-hidden="true">#</a> 性质</h4><ul><li>每个结点非黑即红。</li><li>根节点是黑色的。</li><li>每个叶节点(<strong>叶节点即树尾端NUL指针或NULL节点</strong>)都是黑的.</li><li>如果一个节点是红的,那么它的两儿子都是黑的.</li><li>对于任意节点而言,其到叶子点树NIL指针的每条路径都包含相同数目的黑节点.</li></ul><h3 id="b-b-树" tabindex="-1"><a class="header-anchor" href="#b-b-树" aria-hidden="true">#</a> B/B+树</h3><p>注意B-tree就是B树,-只是一个符号(<strong>并没有B-树</strong>)</p><blockquote><p>B-tree树即B树，B即Balanced，平衡的意思。因为B树的原英文名称为B-tree，而国内很多人喜欢把B-tree译作B-树，其实，这是个非常不好的直译，很容易让人产生误解。如人们可能会以为B-树是一种树，而B树又是另一种树。而事实上是，B-tree就是指的B树。</p></blockquote><h4 id="简介" tabindex="-1"><a class="header-anchor" href="#简介" aria-hidden="true">#</a> 简介</h4><p>B/B+树是为了磁盘或其他存储设备而设计的一种<strong>平衡多路查找树</strong>(想对于二叉树，B树的每个内结点有多个分支)。</p><p>与红黑树相比，在相同的结点的情况下，一颗B/B+树的高度远远小于红黑树的高度。B/B+树上的操作时间通常由存取磁盘的时间和CPU计算时间两部分构成，而CPU的速度非常快，所以B树的操作效率取决于访问磁盘的次数，关键字总数相同的情况下B树的高度越小，磁盘I/O所花的时间越少。</p><h4 id="b树的性质" tabindex="-1"><a class="header-anchor" href="#b树的性质" aria-hidden="true">#</a> B树的性质</h4><ul><li>定义任意非叶子结点最多只有M个儿子，</li></ul>',31),o=[n];function h(s,d){return e(),r("div",null,o)}const l=a(t,[["render",h],["__file","数据结构.html.vue"]]);export{l as default};
