const l=JSON.parse(`{"key":"v-1687156a","path":"/interview/A4-Java/JVM/JVM%E4%B8%8A.html","title":"1.JVM 与 Java 体系结构","lang":"zh-CN","frontmatter":{"description":"1.JVM 与 Java 体系结构 1.1. 前言 作为 Java 工程师的你曾被伤害过吗？你是否也遇到过这些问题？ 运行着的线上系统突然卡死，系统无法访问，甚至直接 OOM 想解决线上 JVM GC 问题，但却无从下手 新项目上线，对各种 JVM 参数设置一脸茫然，直接默认吧然后就 JJ 了 每次面试之前都要重新背一遍 JVM 的一些原理概念性的东西，然而面试官却经常问你在实际项目中如何调优 VM 参数，如何解决 GC、OOM 等问题，一脸懵逼","head":[["meta",{"property":"og:url","content":"https://yuejinzhao.cn/interview/A4-Java/JVM/JVM%E4%B8%8A.html"}],["meta",{"property":"og:site_name","content":"Honyelchak's Blog"}],["meta",{"property":"og:title","content":"1.JVM 与 Java 体系结构"}],["meta",{"property":"og:description","content":"1.JVM 与 Java 体系结构 1.1. 前言 作为 Java 工程师的你曾被伤害过吗？你是否也遇到过这些问题？ 运行着的线上系统突然卡死，系统无法访问，甚至直接 OOM 想解决线上 JVM GC 问题，但却无从下手 新项目上线，对各种 JVM 参数设置一脸茫然，直接默认吧然后就 JJ 了 每次面试之前都要重新背一遍 JVM 的一些原理概念性的东西，然而面试官却经常问你在实际项目中如何调优 VM 参数，如何解决 GC、OOM 等问题，一脸懵逼"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-12-02T09:42:10.000Z"}],["meta",{"property":"article:author","content":"Honyelchak"}],["meta",{"property":"article:modified_time","content":"2023-12-02T09:42:10.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"1.JVM 与 Java 体系结构\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-12-02T09:42:10.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Honyelchak\\",\\"url\\":\\"https://yuejinzhao.cn\\"}]}"]]},"headers":[{"level":2,"title":"1.1. 前言","slug":"_1-1-前言","link":"#_1-1-前言","children":[]},{"level":2,"title":"1.2. 面向人群及参考书目","slug":"_1-2-面向人群及参考书目","link":"#_1-2-面向人群及参考书目","children":[]},{"level":2,"title":"1.3. Java 及 JVM 简介","slug":"_1-3-java-及-jvm-简介","link":"#_1-3-java-及-jvm-简介","children":[]},{"level":2,"title":"1.4. Java 发展的重大事件","slug":"_1-4-java-发展的重大事件","link":"#_1-4-java-发展的重大事件","children":[]},{"level":2,"title":"1.5. 虚拟机与 Java 虚拟机","slug":"_1-5-虚拟机与-java-虚拟机","link":"#_1-5-虚拟机与-java-虚拟机","children":[]},{"level":2,"title":"1.6. JVM 的整体结构","slug":"_1-6-jvm-的整体结构","link":"#_1-6-jvm-的整体结构","children":[]},{"level":2,"title":"1.7. Java 代码执行流程","slug":"_1-7-java-代码执行流程","link":"#_1-7-java-代码执行流程","children":[]},{"level":2,"title":"1.8. JVM 的架构模型","slug":"_1-8-jvm-的架构模型","link":"#_1-8-jvm-的架构模型","children":[]},{"level":2,"title":"1.9. JVM 的生命周期","slug":"_1-9-jvm-的生命周期","link":"#_1-9-jvm-的生命周期","children":[]},{"level":2,"title":"X. JVM 的发展历程","slug":"x-jvm-的发展历程","link":"#x-jvm-的发展历程","children":[{"level":3,"title":"Sun Classic VM","slug":"sun-classic-vm","link":"#sun-classic-vm","children":[]},{"level":3,"title":"Exact VM","slug":"exact-vm","link":"#exact-vm","children":[]},{"level":3,"title":"HotSpot VM","slug":"hotspot-vm","link":"#hotspot-vm","children":[]},{"level":3,"title":"JRockit","slug":"jrockit","link":"#jrockit","children":[]},{"level":3,"title":"IBM 的 J9","slug":"ibm-的-j9","link":"#ibm-的-j9","children":[]},{"level":3,"title":"KVM 和 CDC / CLDC Hotspot","slug":"kvm-和-cdc-cldc-hotspot","link":"#kvm-和-cdc-cldc-hotspot","children":[]},{"level":3,"title":"Azul VM","slug":"azul-vm","link":"#azul-vm","children":[]},{"level":3,"title":"Liquid VM","slug":"liquid-vm","link":"#liquid-vm","children":[]},{"level":3,"title":"Apache Harmony","slug":"apache-harmony","link":"#apache-harmony","children":[]},{"level":3,"title":"Micorsoft JVM","slug":"micorsoft-jvm","link":"#micorsoft-jvm","children":[]},{"level":3,"title":"Taobao JVM","slug":"taobao-jvm","link":"#taobao-jvm","children":[]},{"level":3,"title":"Dalvik VM","slug":"dalvik-vm","link":"#dalvik-vm","children":[]},{"level":3,"title":"Graal VM","slug":"graal-vm","link":"#graal-vm","children":[]},{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]}]},{"level":2,"title":"2.1. 内存结构概述","slug":"_2-1-内存结构概述","link":"#_2-1-内存结构概述","children":[]},{"level":2,"title":"2.2. 类加载器与类的加载过程","slug":"_2-2-类加载器与类的加载过程","link":"#_2-2-类加载器与类的加载过程","children":[{"level":3,"title":"加载阶段","slug":"加载阶段","link":"#加载阶段","children":[]},{"level":3,"title":"链接阶段","slug":"链接阶段","link":"#链接阶段","children":[]},{"level":3,"title":"初始化阶段","slug":"初始化阶段","link":"#初始化阶段","children":[]}]},{"level":2,"title":"2.3. 类加载器分类","slug":"_2-3-类加载器分类","link":"#_2-3-类加载器分类","children":[{"level":3,"title":"2.3.1. 虚拟机自带的加载器","slug":"_2-3-1-虚拟机自带的加载器","link":"#_2-3-1-虚拟机自带的加载器","children":[]},{"level":3,"title":"2.3.2. 用户自定义类加载器","slug":"_2-3-2-用户自定义类加载器","link":"#_2-3-2-用户自定义类加载器","children":[]}]},{"level":2,"title":"2.4. ClassLoader 的使用说明","slug":"_2-4-classloader-的使用说明","link":"#_2-4-classloader-的使用说明","children":[]},{"level":2,"title":"2.5. 双亲委派机制","slug":"_2-5-双亲委派机制","link":"#_2-5-双亲委派机制","children":[]},{"level":2,"title":"2.6. 其他","slug":"_2-6-其他","link":"#_2-6-其他","children":[]},{"level":2,"title":"3.1. 运行时数据区","slug":"_3-1-运行时数据区","link":"#_3-1-运行时数据区","children":[{"level":3,"title":"3.1.1. 概述","slug":"_3-1-1-概述","link":"#_3-1-1-概述","children":[]},{"level":3,"title":"3.1.2. 线程","slug":"_3-1-2-线程","link":"#_3-1-2-线程","children":[]},{"level":3,"title":"3.1.3. JVM 系统线程","slug":"_3-1-3-jvm-系统线程","link":"#_3-1-3-jvm-系统线程","children":[]}]},{"level":2,"title":"3.2. 程序计数器(PC 寄存器)","slug":"_3-2-程序计数器-pc-寄存器","link":"#_3-2-程序计数器-pc-寄存器","children":[]},{"level":2,"title":"4.1. 虚拟机栈概述","slug":"_4-1-虚拟机栈概述","link":"#_4-1-虚拟机栈概述","children":[{"level":3,"title":"4.1.1. 虚拟机栈出现的背景","slug":"_4-1-1-虚拟机栈出现的背景","link":"#_4-1-1-虚拟机栈出现的背景","children":[]},{"level":3,"title":"4.1.2. 初步印象","slug":"_4-1-2-初步印象","link":"#_4-1-2-初步印象","children":[]},{"level":3,"title":"4.1.3. 内存中的栈与堆","slug":"_4-1-3-内存中的栈与堆","link":"#_4-1-3-内存中的栈与堆","children":[]},{"level":3,"title":"4.1.4. 虚拟机栈基本内容","slug":"_4-1-4-虚拟机栈基本内容","link":"#_4-1-4-虚拟机栈基本内容","children":[]}]},{"level":2,"title":"4.2. 栈的存储单位","slug":"_4-2-栈的存储单位","link":"#_4-2-栈的存储单位","children":[{"level":3,"title":"4.2.1. 栈中存储什么？","slug":"_4-2-1-栈中存储什么","link":"#_4-2-1-栈中存储什么","children":[]},{"level":3,"title":"4.2.2. 栈运行原理","slug":"_4-2-2-栈运行原理","link":"#_4-2-2-栈运行原理","children":[]},{"level":3,"title":"4.2.3. 栈帧的内部结构","slug":"_4-2-3-栈帧的内部结构","link":"#_4-2-3-栈帧的内部结构","children":[]}]},{"level":2,"title":"4.3. 局部变量表(Local Variables)","slug":"_4-3-局部变量表-local-variables","link":"#_4-3-局部变量表-local-variables","children":[{"level":3,"title":"4.3.1. 关于 Slot 的理解","slug":"_4-3-1-关于-slot-的理解","link":"#_4-3-1-关于-slot-的理解","children":[]},{"level":3,"title":"4.3.2. Slot 的重复利用","slug":"_4-3-2-slot-的重复利用","link":"#_4-3-2-slot-的重复利用","children":[]},{"level":3,"title":"4.3.3. 静态变量与局部变量的对比","slug":"_4-3-3-静态变量与局部变量的对比","link":"#_4-3-3-静态变量与局部变量的对比","children":[]},{"level":3,"title":"4.3.4. 补充说明","slug":"_4-3-4-补充说明","link":"#_4-3-4-补充说明","children":[]}]},{"level":2,"title":"4.4. 操作数栈（Operand Stack）","slug":"_4-4-操作数栈-operand-stack","link":"#_4-4-操作数栈-operand-stack","children":[]},{"level":2,"title":"4.5. 代码追踪","slug":"_4-5-代码追踪","link":"#_4-5-代码追踪","children":[]},{"level":2,"title":"4.6. 栈顶缓存技术（Top Of Stack Cashing）技术","slug":"_4-6-栈顶缓存技术-top-of-stack-cashing-技术","link":"#_4-6-栈顶缓存技术-top-of-stack-cashing-技术","children":[]},{"level":2,"title":"4.7. 动态链接（Dynamic Linking）","slug":"_4-7-动态链接-dynamic-linking","link":"#_4-7-动态链接-dynamic-linking","children":[]},{"level":2,"title":"4.8. 方法的调用：解析与分配","slug":"_4-8-方法的调用-解析与分配","link":"#_4-8-方法的调用-解析与分配","children":[{"level":3,"title":"4.8.1. 静态链接","slug":"_4-8-1-静态链接","link":"#_4-8-1-静态链接","children":[]},{"level":3,"title":"4.8.2. 动态链接","slug":"_4-8-2-动态链接","link":"#_4-8-2-动态链接","children":[]},{"level":3,"title":"4.8.3. 早期绑定","slug":"_4-8-3-早期绑定","link":"#_4-8-3-早期绑定","children":[]},{"level":3,"title":"4.8.4. 晚期绑定","slug":"_4-8-4-晚期绑定","link":"#_4-8-4-晚期绑定","children":[]},{"level":3,"title":"4.8.5. 虚方法和非虚方法","slug":"_4-8-5-虚方法和非虚方法","link":"#_4-8-5-虚方法和非虚方法","children":[]},{"level":3,"title":"4.8.6. 方法重写的本质","slug":"_4-8-6-方法重写的本质","link":"#_4-8-6-方法重写的本质","children":[]},{"level":3,"title":"4.8.7. 方法的调用：虚方法表","slug":"_4-8-7-方法的调用-虚方法表","link":"#_4-8-7-方法的调用-虚方法表","children":[]}]},{"level":2,"title":"4.9. 方法返回地址（return address）","slug":"_4-9-方法返回地址-return-address","link":"#_4-9-方法返回地址-return-address","children":[]},{"level":2,"title":"4.10. 一些附加信息","slug":"_4-10-一些附加信息","link":"#_4-10-一些附加信息","children":[]},{"level":2,"title":"4.11. 栈的相关面试题","slug":"_4-11-栈的相关面试题","link":"#_4-11-栈的相关面试题","children":[]},{"level":2,"title":"5.1. 什么是本地方法？","slug":"_5-1-什么是本地方法","link":"#_5-1-什么是本地方法","children":[]},{"level":2,"title":"5.2. 为什么使用 Native Method？","slug":"_5-2-为什么使用-native-method","link":"#_5-2-为什么使用-native-method","children":[]},{"level":2,"title":"5.2. 本地方法栈","slug":"_5-2-本地方法栈","link":"#_5-2-本地方法栈","children":[]},{"level":2,"title":"6.1. 堆（Heap）的核心概述","slug":"_6-1-堆-heap-的核心概述","link":"#_6-1-堆-heap-的核心概述","children":[{"level":3,"title":"6.1.1. 堆内存细分","slug":"_6-1-1-堆内存细分","link":"#_6-1-1-堆内存细分","children":[]},{"level":3,"title":"6.1.2. 堆空间内部结构（JDK7）","slug":"_6-1-2-堆空间内部结构-jdk7","link":"#_6-1-2-堆空间内部结构-jdk7","children":[]},{"level":3,"title":"6.1.3. 堆空间内部结构（JDK8）","slug":"_6-1-3-堆空间内部结构-jdk8","link":"#_6-1-3-堆空间内部结构-jdk8","children":[]}]},{"level":2,"title":"6.2. 设置堆内存大小与 OOM","slug":"_6-2-设置堆内存大小与-oom","link":"#_6-2-设置堆内存大小与-oom","children":[{"level":3,"title":"6.2.1. 堆空间大小的设置","slug":"_6-2-1-堆空间大小的设置","link":"#_6-2-1-堆空间大小的设置","children":[]},{"level":3,"title":"6.2.2. OutOfMemory 举例","slug":"_6-2-2-outofmemory-举例","link":"#_6-2-2-outofmemory-举例","children":[]}]},{"level":2,"title":"6.3. 年轻代与老年代","slug":"_6-3-年轻代与老年代","link":"#_6-3-年轻代与老年代","children":[]},{"level":2,"title":"6.4. 图解对象分配过程","slug":"_6-4-图解对象分配过程","link":"#_6-4-图解对象分配过程","children":[]},{"level":2,"title":"6.5. Minor GC，MajorGC、Full GC","slug":"_6-5-minor-gc-majorgc、full-gc","link":"#_6-5-minor-gc-majorgc、full-gc","children":[{"level":3,"title":"6.5.1. 最简单的分代式 GC 策略的触发条件","slug":"_6-5-1-最简单的分代式-gc-策略的触发条件","link":"#_6-5-1-最简单的分代式-gc-策略的触发条件","children":[]},{"level":3,"title":"新生代 GC（Minor GC）触发机制","slug":"新生代-gc-minor-gc-触发机制","link":"#新生代-gc-minor-gc-触发机制","children":[]},{"level":3,"title":"老年代 GC（Major GC / Full GC）触发机制","slug":"老年代-gc-major-gc-full-gc-触发机制","link":"#老年代-gc-major-gc-full-gc-触发机制","children":[]},{"level":3,"title":"Full GC 触发机制（后面细讲）：","slug":"full-gc-触发机制-后面细讲","link":"#full-gc-触发机制-后面细讲","children":[]}]},{"level":2,"title":"6.6. 堆空间分代思想","slug":"_6-6-堆空间分代思想","link":"#_6-6-堆空间分代思想","children":[]},{"level":2,"title":"6.7. 内存分配策略","slug":"_6-7-内存分配策略","link":"#_6-7-内存分配策略","children":[]},{"level":2,"title":"6.8. 为对象分配内存：TLAB","slug":"_6-8-为对象分配内存-tlab","link":"#_6-8-为对象分配内存-tlab","children":[{"level":3,"title":"6.8.1. 为什么有 TLAB（Thread Local Allocation Buffer）？","slug":"_6-8-1-为什么有-tlab-thread-local-allocation-buffer","link":"#_6-8-1-为什么有-tlab-thread-local-allocation-buffer","children":[]},{"level":3,"title":"6.8.2. 什么是 TLAB？","slug":"_6-8-2-什么是-tlab","link":"#_6-8-2-什么是-tlab","children":[]},{"level":3,"title":"6.8.3. TLAB 的再说明","slug":"_6-8-3-tlab-的再说明","link":"#_6-8-3-tlab-的再说明","children":[]}]},{"level":2,"title":"6.9. 小结：堆空间的参数设置","slug":"_6-9-小结-堆空间的参数设置","link":"#_6-9-小结-堆空间的参数设置","children":[]},{"level":2,"title":"6.X. 堆是分配对象的唯一选择么？","slug":"_6-x-堆是分配对象的唯一选择么","link":"#_6-x-堆是分配对象的唯一选择么","children":[{"level":3,"title":"6.X.1. 逃逸分析概述","slug":"_6-x-1-逃逸分析概述","link":"#_6-x-1-逃逸分析概述","children":[]},{"level":3,"title":"6.X.2. 逃逸分析：代码优化","slug":"_6-x-2-逃逸分析-代码优化","link":"#_6-x-2-逃逸分析-代码优化","children":[]},{"level":3,"title":"6.X.3. 逃逸分析小结：逃逸分析并不成熟","slug":"_6-x-3-逃逸分析小结-逃逸分析并不成熟","link":"#_6-x-3-逃逸分析小结-逃逸分析并不成熟","children":[]}]},{"level":2,"title":"本章小结","slug":"本章小结","link":"#本章小结","children":[]},{"level":2,"title":"7.1. 栈、堆、方法区的交互关系","slug":"_7-1-栈、堆、方法区的交互关系","link":"#_7-1-栈、堆、方法区的交互关系","children":[]},{"level":2,"title":"7.2. 方法区的理解","slug":"_7-2-方法区的理解","link":"#_7-2-方法区的理解","children":[{"level":3,"title":"7.2.1. 方法区在哪里？","slug":"_7-2-1-方法区在哪里","link":"#_7-2-1-方法区在哪里","children":[]},{"level":3,"title":"7.2.2. 方法区的基本理解","slug":"_7-2-2-方法区的基本理解","link":"#_7-2-2-方法区的基本理解","children":[]},{"level":3,"title":"7.2.3. HotSpot 中方法区的演进","slug":"_7-2-3-hotspot-中方法区的演进","link":"#_7-2-3-hotspot-中方法区的演进","children":[]}]},{"level":2,"title":"7.3. 设置方法区大小与 OOM","slug":"_7-3-设置方法区大小与-oom","link":"#_7-3-设置方法区大小与-oom","children":[{"level":3,"title":"7.3.1. 设置方法区内存的大小","slug":"_7-3-1-设置方法区内存的大小","link":"#_7-3-1-设置方法区内存的大小","children":[]},{"level":3,"title":"7.3.2. 如何解决这些 OOM","slug":"_7-3-2-如何解决这些-oom","link":"#_7-3-2-如何解决这些-oom","children":[]}]},{"level":2,"title":"7.4. 方法区的内部结构","slug":"_7-4-方法区的内部结构","link":"#_7-4-方法区的内部结构","children":[{"level":3,"title":"7.4.1. 方法区（Method Area）存储什么？","slug":"_7-4-1-方法区-method-area-存储什么","link":"#_7-4-1-方法区-method-area-存储什么","children":[]},{"level":3,"title":"7.4.2. 方法区的内部结构","slug":"_7-4-2-方法区的内部结构","link":"#_7-4-2-方法区的内部结构","children":[]},{"level":3,"title":"7.4.3. 运行时常量池 VS 常量池","slug":"_7-4-3-运行时常量池-vs-常量池","link":"#_7-4-3-运行时常量池-vs-常量池","children":[]},{"level":3,"title":"7.4.4. 运行时常量池","slug":"_7-4-4-运行时常量池","link":"#_7-4-4-运行时常量池","children":[]}]},{"level":2,"title":"7.5. 方法区使用举例","slug":"_7-5-方法区使用举例","link":"#_7-5-方法区使用举例","children":[]},{"level":2,"title":"7.6. 方法区的演进细节","slug":"_7-6-方法区的演进细节","link":"#_7-6-方法区的演进细节","children":[{"level":3,"title":"7.6.1. 为什么永久代要被元空间替代？","slug":"_7-6-1-为什么永久代要被元空间替代","link":"#_7-6-1-为什么永久代要被元空间替代","children":[]},{"level":3,"title":"7.6.2. StringTable 为什么要调整位置？","slug":"_7-6-2-stringtable-为什么要调整位置","link":"#_7-6-2-stringtable-为什么要调整位置","children":[]},{"level":3,"title":"7.6.3. 静态变量存放在那里？","slug":"_7-6-3-静态变量存放在那里","link":"#_7-6-3-静态变量存放在那里","children":[]}]},{"level":2,"title":"7.7. 方法区的垃圾回收","slug":"_7-7-方法区的垃圾回收","link":"#_7-7-方法区的垃圾回收","children":[]},{"level":2,"title":"总结","slug":"总结-1","link":"#总结-1","children":[]},{"level":2,"title":"常见面试题","slug":"常见面试题","link":"#常见面试题","children":[]},{"level":2,"title":"8.1. 对象实例化","slug":"_8-1-对象实例化","link":"#_8-1-对象实例化","children":[{"level":3,"title":"8.1.1. 创建对象的方式","slug":"_8-1-1-创建对象的方式","link":"#_8-1-1-创建对象的方式","children":[]},{"level":3,"title":"8.1.2. 创建对象的步骤","slug":"_8-1-2-创建对象的步骤","link":"#_8-1-2-创建对象的步骤","children":[]}]},{"level":2,"title":"8.2. 对象内存布局","slug":"_8-2-对象内存布局","link":"#_8-2-对象内存布局","children":[{"level":3,"title":"8.2.1. 对象头（Header）","slug":"_8-2-1-对象头-header","link":"#_8-2-1-对象头-header","children":[]},{"level":3,"title":"8.2.2. 实例数据（Instance Data）","slug":"_8-2-2-实例数据-instance-data","link":"#_8-2-2-实例数据-instance-data","children":[]},{"level":3,"title":"8.2.3. 对齐填充（Padding）","slug":"_8-2-3-对齐填充-padding","link":"#_8-2-3-对齐填充-padding","children":[]},{"level":3,"title":"补充","slug":"补充","link":"#补充","children":[]},{"level":3,"title":"小结","slug":"小结-1","link":"#小结-1","children":[]}]},{"level":2,"title":"8.3. 对象的访问定位","slug":"_8-3-对象的访问定位","link":"#_8-3-对象的访问定位","children":[{"level":3,"title":"8.3.1. 句柄访问","slug":"_8-3-1-句柄访问","link":"#_8-3-1-句柄访问","children":[]},{"level":3,"title":"8.3.2. 直接指针（HotSpot 采用）","slug":"_8-3-2-直接指针-hotspot-采用","link":"#_8-3-2-直接指针-hotspot-采用","children":[]}]},{"level":2,"title":"8.4. 直接内存（Direct Memory）","slug":"_8-4-直接内存-direct-memory","link":"#_8-4-直接内存-direct-memory","children":[{"level":3,"title":"8.4.1. 直接内存概述","slug":"_8-4-1-直接内存概述","link":"#_8-4-1-直接内存概述","children":[]},{"level":3,"title":"8.4.2. 非直接缓存区","slug":"_8-4-2-非直接缓存区","link":"#_8-4-2-非直接缓存区","children":[]},{"level":3,"title":"8.4.3. 直接缓存区","slug":"_8-4-3-直接缓存区","link":"#_8-4-3-直接缓存区","children":[]}]},{"level":2,"title":"9.1. 执行引擎概述","slug":"_9-1-执行引擎概述","link":"#_9-1-执行引擎概述","children":[{"level":3,"title":"9.1.1. 执行引擎的工作流程","slug":"_9-1-1-执行引擎的工作流程","link":"#_9-1-1-执行引擎的工作流程","children":[]}]},{"level":2,"title":"9.2. Java 代码编译和执行过程","slug":"_9-2-java-代码编译和执行过程","link":"#_9-2-java-代码编译和执行过程","children":[{"level":3,"title":"9.2.1. 什么是解释器（Interpreter）？什么是 JIT 编译器？","slug":"_9-2-1-什么是解释器-interpreter-什么是-jit-编译器","link":"#_9-2-1-什么是解释器-interpreter-什么是-jit-编译器","children":[]},{"level":3,"title":"9.2.2. 为什么 Java 是半编译半解释型语言？","slug":"_9-2-2-为什么-java-是半编译半解释型语言","link":"#_9-2-2-为什么-java-是半编译半解释型语言","children":[]}]},{"level":2,"title":"9.3. 机器码、指令、汇编语言","slug":"_9-3-机器码、指令、汇编语言","link":"#_9-3-机器码、指令、汇编语言","children":[{"level":3,"title":"9.3.1. 机器码","slug":"_9-3-1-机器码","link":"#_9-3-1-机器码","children":[]},{"level":3,"title":"9.3.2. 指令","slug":"_9-3-2-指令","link":"#_9-3-2-指令","children":[]},{"level":3,"title":"9.3.3. 指令集","slug":"_9-3-3-指令集","link":"#_9-3-3-指令集","children":[]},{"level":3,"title":"9.3.4. 汇编语言","slug":"_9-3-4-汇编语言","link":"#_9-3-4-汇编语言","children":[]},{"level":3,"title":"9.3.5. 高级语言","slug":"_9-3-5-高级语言","link":"#_9-3-5-高级语言","children":[]},{"level":3,"title":"9.3.6. 字节码","slug":"_9-3-6-字节码","link":"#_9-3-6-字节码","children":[]}]},{"level":2,"title":"9.4. 解释器","slug":"_9-4-解释器","link":"#_9-4-解释器","children":[{"level":3,"title":"9.4.1. 解释器工作机制","slug":"_9-4-1-解释器工作机制","link":"#_9-4-1-解释器工作机制","children":[]},{"level":3,"title":"9.4.2. 解释器分类","slug":"_9-4-2-解释器分类","link":"#_9-4-2-解释器分类","children":[]},{"level":3,"title":"9.4.3. 现状","slug":"_9-4-3-现状","link":"#_9-4-3-现状","children":[]}]},{"level":2,"title":"9.5. JIT 编译器","slug":"_9-5-jit-编译器","link":"#_9-5-jit-编译器","children":[{"level":3,"title":"9.5.1. Java 代码的执行分类","slug":"_9-5-1-java-代码的执行分类","link":"#_9-5-1-java-代码的执行分类","children":[]},{"level":3,"title":"9.5.2. HotSpot JVM 执行方式","slug":"_9-5-2-hotspot-jvm-执行方式","link":"#_9-5-2-hotspot-jvm-执行方式","children":[]},{"level":3,"title":"9.5.3. 概念解释","slug":"_9-5-3-概念解释","link":"#_9-5-3-概念解释","children":[]},{"level":3,"title":"9.5.4. 热点代码及探测技术","slug":"_9-5-4-热点代码及探测技术","link":"#_9-5-4-热点代码及探测技术","children":[]},{"level":3,"title":"9.5.5. HotSpotVM 可以设置程序执行方法","slug":"_9-5-5-hotspotvm-可以设置程序执行方法","link":"#_9-5-5-hotspotvm-可以设置程序执行方法","children":[]},{"level":3,"title":"9.5.6. HotSpotVM 中 JIT 分类","slug":"_9-5-6-hotspotvm-中-jit-分类","link":"#_9-5-6-hotspotvm-中-jit-分类","children":[]},{"level":3,"title":"总结","slug":"总结-2","link":"#总结-2","children":[]},{"level":3,"title":"写到最后 1","slug":"写到最后-1","link":"#写到最后-1","children":[]},{"level":3,"title":"写到最后 2：AOT 编译器","slug":"写到最后-2-aot-编译器","link":"#写到最后-2-aot-编译器","children":[]}]},{"level":2,"title":"10.1. String 的基本特性","slug":"_10-1-string-的基本特性","link":"#_10-1-string-的基本特性","children":[{"level":3,"title":"10.1.1. String 在 jdk9 中存储结构变更","slug":"_10-1-1-string-在-jdk9-中存储结构变更","link":"#_10-1-1-string-在-jdk9-中存储结构变更","children":[]},{"level":3,"title":"10.1.2. String 的基本特性","slug":"_10-1-2-string-的基本特性","link":"#_10-1-2-string-的基本特性","children":[]}]},{"level":2,"title":"10.2. String 的内存分配","slug":"_10-2-string-的内存分配","link":"#_10-2-string-的内存分配","children":[]},{"level":2,"title":"10.3. String 的基本操作","slug":"_10-3-string-的基本操作","link":"#_10-3-string-的基本操作","children":[]},{"level":2,"title":"10.4. 字符串拼接操作","slug":"_10-4-字符串拼接操作","link":"#_10-4-字符串拼接操作","children":[]},{"level":2,"title":"10.5. intern()的使用","slug":"_10-5-intern-的使用","link":"#_10-5-intern-的使用","children":[{"level":3,"title":"10.5.1. intern 的使用：JDK6 vs JDK7/8","slug":"_10-5-1-intern-的使用-jdk6-vs-jdk7-8","link":"#_10-5-1-intern-的使用-jdk6-vs-jdk7-8","children":[]},{"level":3,"title":"10.5.2. intern 的效率测试：空间角度","slug":"_10-5-2-intern-的效率测试-空间角度","link":"#_10-5-2-intern-的效率测试-空间角度","children":[]}]},{"level":2,"title":"10.6. StringTable 的垃圾回收","slug":"_10-6-stringtable-的垃圾回收","link":"#_10-6-stringtable-的垃圾回收","children":[]},{"level":2,"title":"10.7. G1 中的 String 去重操作","slug":"_10-7-g1-中的-string-去重操作","link":"#_10-7-g1-中的-string-去重操作","children":[]},{"level":2,"title":"11.1. 垃圾回收概述","slug":"_11-1-垃圾回收概述","link":"#_11-1-垃圾回收概述","children":[{"level":3,"title":"11.1.1. 什么是垃圾？","slug":"_11-1-1-什么是垃圾","link":"#_11-1-1-什么是垃圾","children":[]}]},{"level":2,"title":"11.1.2. 为什么需要 GC","slug":"_11-1-2-为什么需要-gc","link":"#_11-1-2-为什么需要-gc","children":[]},{"level":2,"title":"11.1.3. 早期垃圾回收","slug":"_11-1-3-早期垃圾回收","link":"#_11-1-3-早期垃圾回收","children":[]},{"level":2,"title":"11.1.4. Java 垃圾回收机制","slug":"_11-1-4-java-垃圾回收机制","link":"#_11-1-4-java-垃圾回收机制","children":[]},{"level":2,"title":"11.2. 垃圾回收相关算法","slug":"_11-2-垃圾回收相关算法","link":"#_11-2-垃圾回收相关算法","children":[{"level":3,"title":"11.2.1. 标记阶段：引用计数算法","slug":"_11-2-1-标记阶段-引用计数算法","link":"#_11-2-1-标记阶段-引用计数算法","children":[]},{"level":3,"title":"11.2.2. 标记阶段：可达性分析算法","slug":"_11-2-2-标记阶段-可达性分析算法","link":"#_11-2-2-标记阶段-可达性分析算法","children":[]},{"level":3,"title":"11.2.3. 对象的 finalization 机制","slug":"_11-2-3-对象的-finalization-机制","link":"#_11-2-3-对象的-finalization-机制","children":[]},{"level":3,"title":"11.2.4. MAT 与 JProfiler 的 GC Roots 溯源","slug":"_11-2-4-mat-与-jprofiler-的-gc-roots-溯源","link":"#_11-2-4-mat-与-jprofiler-的-gc-roots-溯源","children":[]},{"level":3,"title":"11.2.5. 清除阶段：标记-清除算法","slug":"_11-2-5-清除阶段-标记-清除算法","link":"#_11-2-5-清除阶段-标记-清除算法","children":[]},{"level":3,"title":"11.2.6. 清除阶段：复制算法","slug":"_11-2-6-清除阶段-复制算法","link":"#_11-2-6-清除阶段-复制算法","children":[]},{"level":3,"title":"11.2.7. 清除阶段：标记-压缩（整理）算法","slug":"_11-2-7-清除阶段-标记-压缩-整理-算法","link":"#_11-2-7-清除阶段-标记-压缩-整理-算法","children":[]},{"level":3,"title":"11.2.8. 小结","slug":"_11-2-8-小结","link":"#_11-2-8-小结","children":[]},{"level":3,"title":"11.2.9. 分代收集算法","slug":"_11-2-9-分代收集算法","link":"#_11-2-9-分代收集算法","children":[]},{"level":3,"title":"11.2.X. 增量收集算法、分区算法","slug":"_11-2-x-增量收集算法、分区算法","link":"#_11-2-x-增量收集算法、分区算法","children":[]}]},{"level":2,"title":"12.1. System.gc()的理解","slug":"_12-1-system-gc-的理解","link":"#_12-1-system-gc-的理解","children":[]},{"level":2,"title":"12.2. 内存溢出与内存泄露","slug":"_12-2-内存溢出与内存泄露","link":"#_12-2-内存溢出与内存泄露","children":[{"level":3,"title":"内存溢出（OOM）","slug":"内存溢出-oom","link":"#内存溢出-oom","children":[]},{"level":3,"title":"内存泄漏（Memory Leak）","slug":"内存泄漏-memory-leak","link":"#内存泄漏-memory-leak","children":[]}]},{"level":2,"title":"12.3. Stop The World","slug":"_12-3-stop-the-world","link":"#_12-3-stop-the-world","children":[]},{"level":2,"title":"12.4. 垃圾回收的并行与并发","slug":"_12-4-垃圾回收的并行与并发","link":"#_12-4-垃圾回收的并行与并发","children":[{"level":3,"title":"并发（Concurrent）","slug":"并发-concurrent","link":"#并发-concurrent","children":[]},{"level":3,"title":"并行（Parallel）","slug":"并行-parallel","link":"#并行-parallel","children":[]},{"level":3,"title":"并发 vs 并行","slug":"并发-vs-并行","link":"#并发-vs-并行","children":[]},{"level":3,"title":"垃圾回收的并发与并行","slug":"垃圾回收的并发与并行","link":"#垃圾回收的并发与并行","children":[]}]},{"level":2,"title":"12.5. 安全点与安全区域","slug":"_12-5-安全点与安全区域","link":"#_12-5-安全点与安全区域","children":[{"level":3,"title":"安全点","slug":"安全点","link":"#安全点","children":[]},{"level":3,"title":"安全区域（Safe Resion）","slug":"安全区域-safe-resion","link":"#安全区域-safe-resion","children":[]},{"level":3,"title":"实际执行时：","slug":"实际执行时","link":"#实际执行时","children":[]}]},{"level":2,"title":"12.6. 再谈引用：强引用","slug":"_12-6-再谈引用-强引用","link":"#_12-6-再谈引用-强引用","children":[{"level":3,"title":"强引用（Strong Reference）——不回收","slug":"强引用-strong-reference-——不回收","link":"#强引用-strong-reference-——不回收","children":[]}]},{"level":2,"title":"12.8. 再谈引用： 软引用","slug":"_12-8-再谈引用-软引用","link":"#_12-8-再谈引用-软引用","children":[{"level":3,"title":"软引用（Soft Reference）——内存不足即回收","slug":"软引用-soft-reference-——内存不足即回收","link":"#软引用-soft-reference-——内存不足即回收","children":[]}]},{"level":2,"title":"12.9. 再谈引用：弱引用","slug":"_12-9-再谈引用-弱引用","link":"#_12-9-再谈引用-弱引用","children":[{"level":3,"title":"弱引用（Weak Reference）——发现即回收","slug":"弱引用-weak-reference-——发现即回收","link":"#弱引用-weak-reference-——发现即回收","children":[]}]},{"level":2,"title":"12.X. 再谈引用：虚引用","slug":"_12-x-再谈引用-虚引用","link":"#_12-x-再谈引用-虚引用","children":[{"level":3,"title":"虚引用（Phantom Reference）——对象回收跟踪","slug":"虚引用-phantom-reference-——对象回收跟踪","link":"#虚引用-phantom-reference-——对象回收跟踪","children":[]}]},{"level":2,"title":"12.11. 终结器引用","slug":"_12-11-终结器引用","link":"#_12-11-终结器引用","children":[]},{"level":2,"title":"13.1. GC 分类与性能指标","slug":"_13-1-gc-分类与性能指标","link":"#_13-1-gc-分类与性能指标","children":[{"level":3,"title":"13.1.1. 垃圾回收器概述","slug":"_13-1-1-垃圾回收器概述","link":"#_13-1-1-垃圾回收器概述","children":[]},{"level":3,"title":"13.1.2. 垃圾收集器分类","slug":"_13-1-2-垃圾收集器分类","link":"#_13-1-2-垃圾收集器分类","children":[]},{"level":3,"title":"13.1.3. 评估 GC 的性能指标","slug":"_13-1-3-评估-gc-的性能指标","link":"#_13-1-3-评估-gc-的性能指标","children":[]}]},{"level":2,"title":"13.2. 不同的垃圾回收器概述","slug":"_13-2-不同的垃圾回收器概述","link":"#_13-2-不同的垃圾回收器概述","children":[{"level":3,"title":"13.2.1. 垃圾回收器发展史","slug":"_13-2-1-垃圾回收器发展史","link":"#_13-2-1-垃圾回收器发展史","children":[]},{"level":3,"title":"13.2.2. 7 种经典的垃圾收集器","slug":"_13-2-2-7-种经典的垃圾收集器","link":"#_13-2-2-7-种经典的垃圾收集器","children":[]},{"level":3,"title":"13.2.3. 7 款经典收集器与垃圾分代之间的关系","slug":"_13-2-3-7-款经典收集器与垃圾分代之间的关系","link":"#_13-2-3-7-款经典收集器与垃圾分代之间的关系","children":[]},{"level":3,"title":"13.2.4. 垃圾收集器的组合关系","slug":"_13-2-4-垃圾收集器的组合关系","link":"#_13-2-4-垃圾收集器的组合关系","children":[]},{"level":3,"title":"13.2.5. 不同的垃圾收集器概述","slug":"_13-2-5-不同的垃圾收集器概述","link":"#_13-2-5-不同的垃圾收集器概述","children":[]},{"level":3,"title":"13.2.6. 如何查看默认垃圾收集器","slug":"_13-2-6-如何查看默认垃圾收集器","link":"#_13-2-6-如何查看默认垃圾收集器","children":[]}]},{"level":2,"title":"13.3. Serial 回收器：串行回收","slug":"_13-3-serial-回收器-串行回收","link":"#_13-3-serial-回收器-串行回收","children":[]},{"level":2,"title":"13.4. ParNew 回收器：并行回收","slug":"_13-4-parnew-回收器-并行回收","link":"#_13-4-parnew-回收器-并行回收","children":[]},{"level":2,"title":"13.5. Parallel 回收器：吞吐量优先","slug":"_13-5-parallel-回收器-吞吐量优先","link":"#_13-5-parallel-回收器-吞吐量优先","children":[]},{"level":2,"title":"13.6. CMS 回收器：低延迟","slug":"_13-6-cms-回收器-低延迟","link":"#_13-6-cms-回收器-低延迟","children":[{"level":3,"title":"13.6.1. CMS 的优点","slug":"_13-6-1-cms-的优点","link":"#_13-6-1-cms-的优点","children":[]},{"level":3,"title":"13.6.2. CMS 的弊端","slug":"_13-6-2-cms-的弊端","link":"#_13-6-2-cms-的弊端","children":[]},{"level":3,"title":"13.6.3. 设置的参数","slug":"_13-6-3-设置的参数","link":"#_13-6-3-设置的参数","children":[]},{"level":3,"title":"小结","slug":"小结-3","link":"#小结-3","children":[]},{"level":3,"title":"13.6.4. JDK 后续版本中 CMS 的变化","slug":"_13-6-4-jdk-后续版本中-cms-的变化","link":"#_13-6-4-jdk-后续版本中-cms-的变化","children":[]}]},{"level":2,"title":"13.7. G1 回收器：区域化分代式","slug":"_13-7-g1-回收器-区域化分代式","link":"#_13-7-g1-回收器-区域化分代式","children":[{"level":3,"title":"13.7.1. G1 回收器的特点（优势）","slug":"_13-7-1-g1-回收器的特点-优势","link":"#_13-7-1-g1-回收器的特点-优势","children":[]},{"level":3,"title":"13.7.2. G1 垃圾收集器的缺点","slug":"_13-7-2-g1-垃圾收集器的缺点","link":"#_13-7-2-g1-垃圾收集器的缺点","children":[]},{"level":3,"title":"13.7.3. G1 回收器的参数设置","slug":"_13-7-3-g1-回收器的参数设置","link":"#_13-7-3-g1-回收器的参数设置","children":[]},{"level":3,"title":"13.7.4. G1 收集器的常见操作步骤","slug":"_13-7-4-g1-收集器的常见操作步骤","link":"#_13-7-4-g1-收集器的常见操作步骤","children":[]},{"level":3,"title":"13.7.5. G1 收集器的适用场景","slug":"_13-7-5-g1-收集器的适用场景","link":"#_13-7-5-g1-收集器的适用场景","children":[]},{"level":3,"title":"13.7.6. 分区 Region：化整为零","slug":"_13-7-6-分区-region-化整为零","link":"#_13-7-6-分区-region-化整为零","children":[]},{"level":3,"title":"13.7.7. G1 垃圾回收器的回收过程","slug":"_13-7-7-g1-垃圾回收器的回收过程","link":"#_13-7-7-g1-垃圾回收器的回收过程","children":[]},{"level":3,"title":"13.7.8. Remembered Set","slug":"_13-7-8-remembered-set","link":"#_13-7-8-remembered-set","children":[]},{"level":3,"title":"13.7.9. G1 回收过程一：年轻代 GC","slug":"_13-7-9-g1-回收过程一-年轻代-gc","link":"#_13-7-9-g1-回收过程一-年轻代-gc","children":[]},{"level":3,"title":"13.7.10. G1 回收过程二：并发标记过程","slug":"_13-7-10-g1-回收过程二-并发标记过程","link":"#_13-7-10-g1-回收过程二-并发标记过程","children":[]},{"level":3,"title":"13.7.11. G1 回收过程三：混合回收","slug":"_13-7-11-g1-回收过程三-混合回收","link":"#_13-7-11-g1-回收过程三-混合回收","children":[]},{"level":3,"title":"13.7.12. G1 回收可选的过程四：Full GC","slug":"_13-7-12-g1-回收可选的过程四-full-gc","link":"#_13-7-12-g1-回收可选的过程四-full-gc","children":[]},{"level":3,"title":"13.7.13. 补充","slug":"_13-7-13-补充","link":"#_13-7-13-补充","children":[]},{"level":3,"title":"13.7.14. G1 回收器优化建议","slug":"_13-7-14-g1-回收器优化建议","link":"#_13-7-14-g1-回收器优化建议","children":[]}]},{"level":2,"title":"13.8. 垃圾回收器总结","slug":"_13-8-垃圾回收器总结","link":"#_13-8-垃圾回收器总结","children":[{"level":3,"title":"13.8.1. 7 种经典垃圾回收器总结","slug":"_13-8-1-7-种经典垃圾回收器总结","link":"#_13-8-1-7-种经典垃圾回收器总结","children":[]},{"level":3,"title":"13.8.2. 垃圾回收器组合","slug":"_13-8-2-垃圾回收器组合","link":"#_13-8-2-垃圾回收器组合","children":[]},{"level":3,"title":"13.8.3. 怎么选择垃圾回收器","slug":"_13-8-3-怎么选择垃圾回收器","link":"#_13-8-3-怎么选择垃圾回收器","children":[]}]},{"level":2,"title":"13.9. GC 日志分析","slug":"_13-9-gc-日志分析","link":"#_13-9-gc-日志分析","children":[{"level":3,"title":"Minor GC 日志","slug":"minor-gc-日志","link":"#minor-gc-日志","children":[]},{"level":3,"title":"Full GC 日志","slug":"full-gc-日志","link":"#full-gc-日志","children":[]}]},{"level":2,"title":"13.X. 垃圾回收器的新发展","slug":"_13-x-垃圾回收器的新发展","link":"#_13-x-垃圾回收器的新发展","children":[{"level":3,"title":"13.X.1. JDK11 新特性","slug":"_13-x-1-jdk11-新特性","link":"#_13-x-1-jdk11-新特性","children":[]},{"level":3,"title":"13.X.2. Open JDK12 的 Shenandoash GC","slug":"_13-x-2-open-jdk12-的-shenandoash-gc","link":"#_13-x-2-open-jdk12-的-shenandoash-gc","children":[]},{"level":3,"title":"13.X.3. 令人震惊、革命性的 ZGC","slug":"_13-x-3-令人震惊、革命性的-zgc","link":"#_13-x-3-令人震惊、革命性的-zgc","children":[]},{"level":3,"title":"13.X.4. 其他垃圾回收器：AliGC","slug":"_13-x-4-其他垃圾回收器-aligc","link":"#_13-x-4-其他垃圾回收器-aligc","children":[]}]}],"git":{"createdTime":1701499503000,"updatedTime":1701510130000,"contributors":[{"name":"honyelchak","email":"554417388@qq.com","commits":2}]},"readingTime":{"minutes":269.87,"words":80960},"filePathRelative":"interview/A4-Java/JVM/JVM上.md","localizedDate":"2023年12月2日","excerpt":"<h1> 1.JVM 与 Java 体系结构</h1>\\n<h2> 1.1. 前言</h2>\\n<p>作为 Java 工程师的你曾被伤害过吗？你是否也遇到过这些问题？</p>\\n<ul>\\n<li>运行着的线上系统突然卡死，系统无法访问，甚至直接 OOM</li>\\n<li>想解决线上 JVM GC 问题，但却无从下手</li>\\n<li>新项目上线，对各种 JVM 参数设置一脸茫然，直接默认吧然后就 JJ 了</li>\\n<li>每次面试之前都要重新背一遍 JVM 的一些原理概念性的东西，然而面试官却经常问你在实际项目中如何调优 VM 参数，如何解决 GC、OOM 等问题，一脸懵逼</li>\\n</ul>\\n","autoDesc":true}`);export{l as data};
