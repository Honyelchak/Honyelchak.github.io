import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as a,c as i,f as t}from"./app-XffPLay1.js";const o="/assets/v2-603427db5a5e4b4ce2d8fd1b32632ee5_720w-eCr54KQj.webp",r={},l=t('<h2 id="流量削峰" tabindex="-1"><a class="header-anchor" href="#流量削峰" aria-hidden="true">#</a> 流量削峰</h2><p>当大批用户在某一瞬间同时访问系统时，由于服务器的处理的资源是有限的，所以很容易导致服务器宕机，从而出现用户无法访问的情况。通常多出现在双11或者团购秒杀等场景中。</p><blockquote><p>削峰从本质上来说就是更多地延缓用户请求，以及层层过滤用户的访问需求，遵从“最后落地到数据库的请求数要尽量少”的原则。</p></blockquote><h3 id="消息队列解决削峰" tabindex="-1"><a class="header-anchor" href="#消息队列解决削峰" aria-hidden="true">#</a> 消息队列解决削峰</h3><p>要对流量进行削峰，最容易想到的解决方案就是<code>用消息队列来缓冲瞬时流量，把同步的直接调用转换成异步的间接推送，中间通过一个队列在一端承接瞬时的流量洪峰，在另一端平滑地将消息推送出去</code>。</p><blockquote><p>消息队列中间件主要解决应用耦合，异步消息， 流量削锋等问题。</p></blockquote><p>常用消息队列系统：</p><ul><li>目前在生产环境，使用较多的消息队列有 <code>ActiveMQ、RabbitMQ、 ZeroMQ、Kafka、MetaMQ、RocketMQ</code> 等。</li></ul><h3 id="流量削峰漏斗-层层削峰" tabindex="-1"><a class="header-anchor" href="#流量削峰漏斗-层层削峰" aria-hidden="true">#</a> 流量削峰漏斗：层层削峰</h3><p>针对秒杀场景还有一种方法，就是对请求进行分层过滤，从而过滤掉一些无效的请求。</p><p>分层过滤其实就是<strong>采用“漏斗”式设计</strong>来处理请求的</p><figure><img src="'+o+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><strong>1）分层过滤的核心思想</strong></p><ul><li>通过在不同的层次尽可能地过滤掉无效请求。</li><li>通过CDN过滤掉大量的图片，静态资源的请求。</li><li>再通过类似Redis这样的分布式缓存，过滤请求等就是典型的在上游拦截读请求。</li></ul><p><strong>2）分层过滤的基本原则</strong></p><ul><li>对写数据进行基于时间的合理分片，过滤掉过期的失效请求。</li><li>对写请求做限流保护，将超出系统承载能力的请求过滤掉。</li><li>涉及到的读数据不做强一致性校验，减少因为一致性校验产生瓶颈的问题。</li><li>对写数据进行强一致性校验，只保留最后有效的数据。</li></ul><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h3><p>1.对于秒杀这样的高并发场景业务，最基本的原则就是将请求拦截在系统上游，降低下游压力。如果不在前端拦截很可能造成数据库(mysql、oracle等)读写锁冲突，甚至导致死锁，最终还有可能出现雪崩等场景。</p><p>2.划分好动静资源，静态资源使用CDN进行服务分发。</p><p>3.充分利用缓存(redis等)：增加QPS，从而加大整个集群的吞吐量。</p><p>4.高峰值流量是压垮系统很重要的原因，所以需要Kafka等消息队列在一端承接瞬时的流量洪峰，在另一端平滑地将消息推送出去。</p>',21),c=[l];function d(s,n){return a(),i("div",null,c)}const u=e(r,[["render",d],["__file","秒杀.html.vue"]]);export{u as default};
