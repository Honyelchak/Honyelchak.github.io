const l=JSON.parse(`{"key":"v-0e4296d9","path":"/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html","title":"一、基础知识","lang":"zh-CN","frontmatter":{"description":"一、基础知识 操作系统层面 IO读写的基础原理 为了避免用户进程直接操作内核， 保证内核安全， 操作系统将内存（虚拟内存） 划分为两部分， 一部分是内核空间（Kernel-Space） ， 一部分是用户空间（User-Space） 。 在 Linux系统中， 内核模块运行在内核空间， 对应的进程处于内核态； 而用户程序运行在用户空间，对应的进程处于用户态。 操作系统的核心是内核， 独立于普通的应用程序， 可以访问受保护的内核空间， 也有访问底层硬件设备的权限。 内核空间总是驻留在内存中， 它是为操作系统的内核保留的。 应用程序是不允许直接在内核空间区域进行读写， 也是不容许直接调用内核代码定义的函数的。每个应用程序进程都有一个单独的用户空间， 对应的进程处于用户态， 用户态进程不能访问内核空间中的数据， 也不能直接调用内核函数的，因此要进行系统调用的时候， 就要将进程切换到内核态才能进行。","head":[["meta",{"property":"og:url","content":"https://yuejinzhao.cn/interview/A8-%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html"}],["meta",{"property":"og:site_name","content":"Honyelchak's Blog"}],["meta",{"property":"og:title","content":"一、基础知识"}],["meta",{"property":"og:description","content":"一、基础知识 操作系统层面 IO读写的基础原理 为了避免用户进程直接操作内核， 保证内核安全， 操作系统将内存（虚拟内存） 划分为两部分， 一部分是内核空间（Kernel-Space） ， 一部分是用户空间（User-Space） 。 在 Linux系统中， 内核模块运行在内核空间， 对应的进程处于内核态； 而用户程序运行在用户空间，对应的进程处于用户态。 操作系统的核心是内核， 独立于普通的应用程序， 可以访问受保护的内核空间， 也有访问底层硬件设备的权限。 内核空间总是驻留在内存中， 它是为操作系统的内核保留的。 应用程序是不允许直接在内核空间区域进行读写， 也是不容许直接调用内核代码定义的函数的。每个应用程序进程都有一个单独的用户空间， 对应的进程处于用户态， 用户态进程不能访问内核空间中的数据， 也不能直接调用内核函数的，因此要进行系统调用的时候， 就要将进程切换到内核态才能进行。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-12-02T06:45:03.000Z"}],["meta",{"property":"article:author","content":"Honyelchak"}],["meta",{"property":"article:modified_time","content":"2023-12-02T06:45:03.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"一、基础知识\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-12-02T06:45:03.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Honyelchak\\",\\"url\\":\\"https://yuejinzhao.cn\\"}]}"]]},"headers":[{"level":2,"title":"操作系统层面","slug":"操作系统层面","link":"#操作系统层面","children":[{"level":3,"title":"IO读写的基础原理","slug":"io读写的基础原理","link":"#io读写的基础原理","children":[]},{"level":3,"title":"干掉同步与异步、阻塞与非阻塞","slug":"干掉同步与异步、阻塞与非阻塞","link":"#干掉同步与异步、阻塞与非阻塞","children":[]},{"level":3,"title":"五种IO模型","slug":"五种io模型","link":"#五种io模型","children":[]}]},{"level":2,"title":"回顾IO","slug":"回顾io","link":"#回顾io","children":[]},{"level":2,"title":"回顾BIO","slug":"回顾bio","link":"#回顾bio","children":[]},{"level":2,"title":"核心组件","slug":"核心组件","link":"#核心组件","children":[{"level":3,"title":"Channel","slug":"channel","link":"#channel","children":[]},{"level":3,"title":"Selector","slug":"selector","link":"#selector","children":[]},{"level":3,"title":"Buffer","slug":"buffer","link":"#buffer","children":[]}]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]},{"level":2,"title":"模块组件","slug":"模块组件","link":"#模块组件","children":[{"level":3,"title":"Bootstrap、ServerBootstrap","slug":"bootstrap、serverbootstrap","link":"#bootstrap、serverbootstrap","children":[]},{"level":3,"title":"Future、ChannelFuture","slug":"future、channelfuture","link":"#future、channelfuture","children":[]}]},{"level":2,"title":"服务端Netty工作架构","slug":"服务端netty工作架构","link":"#服务端netty工作架构","children":[]},{"level":2,"title":"相关面试题","slug":"相关面试题","link":"#相关面试题","children":[{"level":3,"title":"1、是否保证可靠传输？","slug":"_1、是否保证可靠传输","link":"#_1、是否保证可靠传输","children":[]}]},{"level":2,"title":"Java NIO","slug":"java-nio","link":"#java-nio","children":[]},{"level":2,"title":"Netty中的NIO","slug":"netty中的nio","link":"#netty中的nio","children":[{"level":3,"title":"Pipeline通道","slug":"pipeline通道","link":"#pipeline通道","children":[]},{"level":3,"title":"ByteBuf","slug":"bytebuf","link":"#bytebuf","children":[]}]},{"level":2,"title":"网络包接收流程","slug":"网络包接收流程","link":"#网络包接收流程","children":[]},{"level":2,"title":"性能开销","slug":"性能开销","link":"#性能开销","children":[]},{"level":2,"title":"网络包发送流程","slug":"网络包发送流程","link":"#网络包发送流程","children":[]},{"level":2,"title":"性能开销","slug":"性能开销-1","link":"#性能开销-1","children":[]},{"level":2,"title":"再谈(阻塞，非阻塞)与(同步，异步)","slug":"再谈-阻塞-非阻塞-与-同步-异步","link":"#再谈-阻塞-非阻塞-与-同步-异步","children":[]},{"level":2,"title":"阻塞与非阻塞","slug":"阻塞与非阻塞-1","link":"#阻塞与非阻塞-1","children":[{"level":3,"title":"阻塞","slug":"阻塞-1","link":"#阻塞-1","children":[]},{"level":3,"title":"非阻塞","slug":"非阻塞-1","link":"#非阻塞-1","children":[]}]},{"level":2,"title":"同步与异步","slug":"同步与异步-1","link":"#同步与异步-1","children":[{"level":3,"title":"同步","slug":"同步-1","link":"#同步-1","children":[]},{"level":3,"title":"异步","slug":"异步-1","link":"#异步-1","children":[]}]},{"level":2,"title":"IO模型","slug":"io模型","link":"#io模型","children":[]},{"level":2,"title":"阻塞IO（BIO）","slug":"阻塞io-bio","link":"#阻塞io-bio","children":[{"level":3,"title":"阻塞读","slug":"阻塞读","link":"#阻塞读","children":[]},{"level":3,"title":"阻塞写","slug":"阻塞写","link":"#阻塞写","children":[]}]},{"level":2,"title":"阻塞IO模型","slug":"阻塞io模型","link":"#阻塞io模型","children":[]},{"level":2,"title":"适用场景","slug":"适用场景","link":"#适用场景","children":[]},{"level":2,"title":"非阻塞IO（NIO）","slug":"非阻塞io-nio","link":"#非阻塞io-nio","children":[{"level":3,"title":"非阻塞读","slug":"非阻塞读","link":"#非阻塞读","children":[]},{"level":3,"title":"非阻塞写","slug":"非阻塞写","link":"#非阻塞写","children":[]}]},{"level":2,"title":"非阻塞IO模型","slug":"非阻塞io模型","link":"#非阻塞io模型","children":[]},{"level":2,"title":"适用场景","slug":"适用场景-1","link":"#适用场景-1","children":[]},{"level":2,"title":"IO多路复用","slug":"io多路复用","link":"#io多路复用","children":[]},{"level":2,"title":"select","slug":"select","link":"#select","children":[{"level":3,"title":"API介绍","slug":"api介绍","link":"#api介绍","children":[]},{"level":3,"title":"性能开销","slug":"性能开销-2","link":"#性能开销-2","children":[]}]},{"level":2,"title":"poll","slug":"poll","link":"#poll","children":[]},{"level":2,"title":"epoll","slug":"epoll","link":"#epoll","children":[{"level":3,"title":"Socket的创建","slug":"socket的创建","link":"#socket的创建","children":[]},{"level":3,"title":"进程中管理文件列表结构","slug":"进程中管理文件列表结构","link":"#进程中管理文件列表结构","children":[]},{"level":3,"title":"Socket内核结构","slug":"socket内核结构","link":"#socket内核结构","children":[]},{"level":3,"title":"阻塞IO中用户进程阻塞以及唤醒原理","slug":"阻塞io中用户进程阻塞以及唤醒原理","link":"#阻塞io中用户进程阻塞以及唤醒原理","children":[]},{"level":3,"title":"epoll_create创建epoll对象","slug":"epoll-create创建epoll对象","link":"#epoll-create创建epoll对象","children":[]},{"level":3,"title":"epoll_ctl向epoll对象中添加监听的Socket","slug":"epoll-ctl向epoll对象中添加监听的socket","link":"#epoll-ctl向epoll对象中添加监听的socket","children":[]},{"level":3,"title":"epoll_wait同步阻塞获取IO就绪的Socket","slug":"epoll-wait同步阻塞获取io就绪的socket","link":"#epoll-wait同步阻塞获取io就绪的socket","children":[]}]},{"level":2,"title":"再谈水平触发和边缘触发","slug":"再谈水平触发和边缘触发","link":"#再谈水平触发和边缘触发","children":[{"level":3,"title":"epoll对select，poll的优化总结","slug":"epoll对select-poll的优化总结","link":"#epoll对select-poll的优化总结","children":[]}]},{"level":2,"title":"信号驱动IO","slug":"信号驱动io","link":"#信号驱动io","children":[]},{"level":2,"title":"IO线程模型","slug":"io线程模型","link":"#io线程模型","children":[]},{"level":2,"title":"Reactor","slug":"reactor","link":"#reactor","children":[{"level":3,"title":"单Reactor单线程","slug":"单reactor单线程","link":"#单reactor单线程","children":[]},{"level":3,"title":"单Reactor多线程","slug":"单reactor多线程","link":"#单reactor多线程","children":[]},{"level":3,"title":"主从Reactor多线程","slug":"主从reactor多线程","link":"#主从reactor多线程","children":[]}]},{"level":2,"title":"Proactor","slug":"proactor","link":"#proactor","children":[]},{"level":2,"title":"Reactor与Proactor对比","slug":"reactor与proactor对比","link":"#reactor与proactor对比","children":[]},{"level":2,"title":"Netty的IO模型","slug":"netty的io模型","link":"#netty的io模型","children":[{"level":3,"title":"配置单Reactor单线程","slug":"配置单reactor单线程","link":"#配置单reactor单线程","children":[]},{"level":3,"title":"配置单Reactor多线程","slug":"配置单reactor多线程","link":"#配置单reactor多线程","children":[]},{"level":3,"title":"配置主从Reactor多线程","slug":"配置主从reactor多线程","link":"#配置主从reactor多线程","children":[]}]}],"git":{"createdTime":1701499503000,"updatedTime":1701499503000,"contributors":[{"name":"honyelchak","email":"554417388@qq.com","commits":1}]},"readingTime":{"minutes":93.73,"words":28119},"filePathRelative":"interview/A8-中间件/Netty.md","localizedDate":"2023年12月2日","excerpt":"<h1> 一、基础知识</h1>\\n<h2> 操作系统层面</h2>\\n<h3> IO读写的基础原理</h3>\\n<p>为了避免用户进程直接操作内核， 保证内核安全， 操作系统将内存（虚拟内存） 划分为两部分， 一部分是内核空间（Kernel-Space） ， 一部分是用户空间（User-Space） 。 在 Linux系统中， 内核模块运行在内核空间， 对应的进程处于内核态； 而用户程序运行在用户空间，对应的进程处于用户态。</p>\\n<p>操作系统的核心是内核， 独立于普通的应用程序， 可以访问受保护的内核空间， 也有访问底层硬件设备的权限。 内核空间总是驻留在内存中， 它是为操作系统的内核保留的。 <code>应用程序是不允许直接在内核空间区域进行读写</code>， <code>也是不容许直接调用内核代码定义的函数的</code>。每个应用程序进程都有一个单独的用户空间， 对应的进程处于用户态， 用户态进程不能访问内核空间中的数据， 也不能直接调用内核函数的，<mark>因此要进行系统调用的时候， 就要将进程切换到内核态才能进行。</mark></p>","autoDesc":true}`);export{l as data};
