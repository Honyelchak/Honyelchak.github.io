const e=JSON.parse(`{"key":"v-7e2efd65","path":"/interview/A5-Spring/Spring%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B.html","title":"","lang":"zh-CN","frontmatter":{"description":"通常，我们说的Spring启动，就是构造ApplicationContext对象以及调用refresh()方法的过程。 创建一个BeanFactory BeanDefinition -&gt; beanDefinitionMap beanpostProcessor -&gt; beanpostProcessors 单例池等 解析配置类， 扫描， 首先，Spring启动过程主要做了这么几 件事情： this()执行时，会先调父类构造方法，构造一个BeanFactory对象 默认在父类GenerircApplicationContext的无参构造方法中，会创建一个DefaultListableBeanFactory \\tpublic GenericApplicationContext() { \\t\\tthis.beanFactory = new DefaultListableBeanFactory(); \\t} DefaultListableBeanFactory类中有BeanDefinitionMap register(componentClasses);将类注册为BeanDefinition，并保存在BeanDefinitionMap中 解析配置类，得到BeanDefinition，并注册到BeanFactory中 解析@ComponentScan，此时就会完成扫描 解析@Import 解析@Bean 因为ApplicationContext还支持国际化，所以还需要初始化MessageSource对象 因为ApplicationC ontext还支持事件机制，所以还需要初始化ApplicationEventMulticaster对象 把用户定义的ApplicationListener对象添加到ApplicationContext中，等Spring启动完了就要发布事件了 创建非懒加载的单例Bean对象，并存在BeanFactory的单例池中。 调用Lifecycle Bean的start()方法 发布ContextRefreshedEvent事件","head":[["meta",{"property":"og:url","content":"https://yuejinzhao.cn/interview/A5-Spring/Spring%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B.html"}],["meta",{"property":"og:site_name","content":"Honyelchak's Blog"}],["meta",{"property":"og:description","content":"通常，我们说的Spring启动，就是构造ApplicationContext对象以及调用refresh()方法的过程。 创建一个BeanFactory BeanDefinition -&gt; beanDefinitionMap beanpostProcessor -&gt; beanpostProcessors 单例池等 解析配置类， 扫描， 首先，Spring启动过程主要做了这么几 件事情： this()执行时，会先调父类构造方法，构造一个BeanFactory对象 默认在父类GenerircApplicationContext的无参构造方法中，会创建一个DefaultListableBeanFactory \\tpublic GenericApplicationContext() { \\t\\tthis.beanFactory = new DefaultListableBeanFactory(); \\t} DefaultListableBeanFactory类中有BeanDefinitionMap register(componentClasses);将类注册为BeanDefinition，并保存在BeanDefinitionMap中 解析配置类，得到BeanDefinition，并注册到BeanFactory中 解析@ComponentScan，此时就会完成扫描 解析@Import 解析@Bean 因为ApplicationContext还支持国际化，所以还需要初始化MessageSource对象 因为ApplicationC ontext还支持事件机制，所以还需要初始化ApplicationEventMulticaster对象 把用户定义的ApplicationListener对象添加到ApplicationContext中，等Spring启动完了就要发布事件了 创建非懒加载的单例Bean对象，并存在BeanFactory的单例池中。 调用Lifecycle Bean的start()方法 发布ContextRefreshedEvent事件"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-12-02T06:45:03.000Z"}],["meta",{"property":"article:author","content":"Honyelchak"}],["meta",{"property":"article:modified_time","content":"2023-12-02T06:45:03.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-12-02T06:45:03.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Honyelchak\\",\\"url\\":\\"https://yuejinzhao.cn\\"}]}"]]},"headers":[{"level":2,"title":"BeanFactoryPostProcessor","slug":"beanfactorypostprocessor","link":"#beanfactorypostprocessor","children":[{"level":3,"title":"BeanDefinitionRegistryPostProcessor","slug":"beandefinitionregistrypostprocessor","link":"#beandefinitionregistrypostprocessor","children":[]}]},{"level":2,"title":"如何理解refresh()？","slug":"如何理解refresh","link":"#如何理解refresh","children":[]},{"level":2,"title":"小问题","slug":"小问题","link":"#小问题","children":[]},{"level":2,"title":"事件","slug":"事件","link":"#事件","children":[{"level":3,"title":"关于事件(4个相关的类)","slug":"关于事件-4个相关的类","link":"#关于事件-4个相关的类","children":[]},{"level":3,"title":"EventListenerMethodProcessor","slug":"eventlistenermethodprocessor","link":"#eventlistenermethodprocessor","children":[]}]},{"level":2,"title":"配置类解析过程","slug":"配置类解析过程","link":"#配置类解析过程","children":[{"level":3,"title":"","slug":"","link":"#","children":[]}]}],"git":{"createdTime":1701499503000,"updatedTime":1701499503000,"contributors":[{"name":"honyelchak","email":"554417388@qq.com","commits":1}]},"readingTime":{"minutes":11.91,"words":3572},"filePathRelative":"interview/A5-Spring/Spring启动过程.md","localizedDate":"2023年12月2日","excerpt":"<p>通常，我们说的Spring启动，就是构造ApplicationContext对象以及调用refresh()方法的过程。</p>\\n<blockquote>\\n<p>创建一个BeanFactory</p>\\n<ol>\\n<li>BeanDefinition -&gt; beanDefinitionMap</li>\\n<li>beanpostProcessor -&gt; beanpostProcessors</li>\\n<li>单例池等</li>\\n</ol>\\n<p>解析配置类，  扫描，</p>\\n</blockquote>\\n<p>首先，Spring启动过程主要做了这么几 件事情：</p>\\n<ol>\\n<li>\\n<p><code>this()</code>执行时，会先调父类构造方法，构造一个BeanFactory对象</p>\\n<ol>\\n<li>\\n<p>默认在父类<code>GenerircApplicationContext</code>的无参构造方法中，会创建一个<code>DefaultListableBeanFactory</code></p>\\n<div class=\\"language-xml line-numbers-mode\\" data-ext=\\"xml\\"><pre class=\\"language-xml\\"><code>\\tpublic GenericApplicationContext() {\\n\\t\\tthis.beanFactory = new DefaultListableBeanFactory();\\n\\t}\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div></li>\\n<li>\\n<p>DefaultListableBeanFactory类中有<code>BeanDefinitionMap</code></p>\\n</li>\\n</ol>\\n</li>\\n<li>\\n<p><code>register(componentClasses);</code>将类注册为BeanDefinition，并保存在BeanDefinitionMap中</p>\\n</li>\\n<li>\\n<p>解析配置类，得到BeanDefinition，并注册到BeanFactory中</p>\\n<ol>\\n<li>解析@ComponentScan，此时就会完成扫描</li>\\n<li>解析@Import</li>\\n<li>解析@Bean</li>\\n</ol>\\n</li>\\n<li>\\n<p>因为ApplicationContext还支持国际化，所以还需要初始化MessageSource对象</p>\\n</li>\\n<li>\\n<p>因为ApplicationC ontext还支持事件机制，所以还需要初始化ApplicationEventMulticaster对象</p>\\n</li>\\n<li>\\n<p>把用户定义的ApplicationListener对象添加到ApplicationContext中，等Spring启动完了就要发布事件了</p>\\n</li>\\n<li>\\n<p>创建非懒加载的单例Bean对象，并存在BeanFactory的单例池中。</p>\\n</li>\\n<li>\\n<p>调用Lifecycle Bean的start()方法</p>\\n</li>\\n<li>\\n<p>发布ContextRefreshedEvent事件</p>\\n</li>\\n</ol>","autoDesc":true}`);export{e as data};
