const e=JSON.parse(`{"key":"v-5209768d","path":"/interview/A4-Java/Java%E9%9B%86%E5%90%88.html","title":"","lang":"zh-CN","frontmatter":{"description":"Java容器概述 容器主要包括Collection和Map两种，Collection存储着对象的集合，而Map存储着键值对的映射表。 Collection img 1. Set TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。 注意，她是实现了SortedSet接口，所以有序。 **底层实现调用TreeMap的构造方法，**key为set中的值，Value为object对象。 // Dummy value to associate with an Object in the backing Map private static final Object PRESENT = new Object(); 添加、删除、包含等操作时间复杂度O(logN) HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。 元素都存到HashMap键值对的Key上面，而Value时有一个统一的值private static final Object PRESENT = new Object();，(定义一个虚拟的Object对象作为HashMap的value，将此对象定义为static final。) 实际底层会初始化一个空的HashMap，并使用默认初始容量为16和加载因子0.75。max((old*0.75)+1),16) 添加、删除、查找效率都是O（1） LinkedHashSet：具有 HashSet 的查找效率，并且内部使用双向链表维护元素的插入顺序。 继承了HashSet的构造方法，该方法是包访问权限，外部不能访问。 HashSet(int initialCapacity, float loadFactor, boolean dummy) { map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor); } 添加、删除、查找效率都是O（1）","head":[["meta",{"property":"og:url","content":"https://yuejinzhao.cn/interview/A4-Java/Java%E9%9B%86%E5%90%88.html"}],["meta",{"property":"og:site_name","content":"Honyelchak's Blog"}],["meta",{"property":"og:description","content":"Java容器概述 容器主要包括Collection和Map两种，Collection存储着对象的集合，而Map存储着键值对的映射表。 Collection img 1. Set TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。 注意，她是实现了SortedSet接口，所以有序。 **底层实现调用TreeMap的构造方法，**key为set中的值，Value为object对象。 // Dummy value to associate with an Object in the backing Map private static final Object PRESENT = new Object(); 添加、删除、包含等操作时间复杂度O(logN) HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。 元素都存到HashMap键值对的Key上面，而Value时有一个统一的值private static final Object PRESENT = new Object();，(定义一个虚拟的Object对象作为HashMap的value，将此对象定义为static final。) 实际底层会初始化一个空的HashMap，并使用默认初始容量为16和加载因子0.75。max((old*0.75)+1),16) 添加、删除、查找效率都是O（1） LinkedHashSet：具有 HashSet 的查找效率，并且内部使用双向链表维护元素的插入顺序。 继承了HashSet的构造方法，该方法是包访问权限，外部不能访问。 HashSet(int initialCapacity, float loadFactor, boolean dummy) { map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor); } 添加、删除、查找效率都是O（1）"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-12-02T09:42:10.000Z"}],["meta",{"property":"article:author","content":"Honyelchak"}],["meta",{"property":"article:modified_time","content":"2023-12-02T09:42:10.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-12-02T09:42:10.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Honyelchak\\",\\"url\\":\\"https://yuejinzhao.cn\\"}]}"]]},"headers":[{"level":2,"title":"Java容器概述","slug":"java容器概述","link":"#java容器概述","children":[]},{"level":2,"title":"Collection","slug":"collection","link":"#collection","children":[{"level":3,"title":"1. Set","slug":"_1-set","link":"#_1-set","children":[]},{"level":3,"title":"2. List","slug":"_2-list","link":"#_2-list","children":[]},{"level":3,"title":"3. Queue","slug":"_3-queue","link":"#_3-queue","children":[]}]},{"level":2,"title":"Map","slug":"map","link":"#map","children":[{"level":3,"title":"1. HashMap","slug":"_1-hashmap","link":"#_1-hashmap","children":[]},{"level":3,"title":"2. ConcurrentHashMap","slug":"_2-concurrenthashmap","link":"#_2-concurrenthashmap","children":[]},{"level":3,"title":"3. LinkedHashMap","slug":"_3-linkedhashmap","link":"#_3-linkedhashmap","children":[]},{"level":3,"title":"4. TreeMap","slug":"_4-treemap","link":"#_4-treemap","children":[]},{"level":3,"title":"5. HashTable与HashMap的区别","slug":"_5-hashtable与hashmap的区别","link":"#_5-hashtable与hashmap的区别","children":[]},{"level":3,"title":"6. 解决哈希冲突的方法","slug":"_6-解决哈希冲突的方法","link":"#_6-解决哈希冲突的方法","children":[]}]},{"level":2,"title":"Vector真的同步吗？","slug":"vector真的同步吗","link":"#vector真的同步吗","children":[{"level":3,"title":"替代方案","slug":"替代方案","link":"#替代方案","children":[]}]},{"level":2,"title":"快速失败(fail-fast)和安全失败(fail-safe)","slug":"快速失败-fail-fast-和安全失败-fail-safe","link":"#快速失败-fail-fast-和安全失败-fail-safe","children":[]},{"level":2,"title":"List集合的三种遍历方式、效率如何？","slug":"list集合的三种遍历方式、效率如何","link":"#list集合的三种遍历方式、效率如何","children":[]},{"level":2,"title":"Map集合的几种遍历方式","slug":"map集合的几种遍历方式","link":"#map集合的几种遍历方式","children":[]},{"level":2,"title":"如何实现数组和List之间的转换","slug":"如何实现数组和list之间的转换","link":"#如何实现数组和list之间的转换","children":[]},{"level":2,"title":"如何确保一个集合不能被修改","slug":"如何确保一个集合不能被修改","link":"#如何确保一个集合不能被修改","children":[]},{"level":2,"title":"如何获取线程安全容器","slug":"如何获取线程安全容器","link":"#如何获取线程安全容器","children":[{"level":3,"title":"使用JUC下的集合类","slug":"使用juc下的集合类","link":"#使用juc下的集合类","children":[]},{"level":3,"title":"使用Collections工具类","slug":"使用collections工具类","link":"#使用collections工具类","children":[]},{"level":3,"title":"常见的几个集合类","slug":"常见的几个集合类","link":"#常见的几个集合类","children":[]}]},{"level":2,"title":"迭代器 Itertor 是什么","slug":"迭代器-itertor-是什么","link":"#迭代器-itertor-是什么","children":[{"level":3,"title":"迭代器模式","slug":"迭代器模式","link":"#迭代器模式","children":[]},{"level":3,"title":"Iterable与Iterator","slug":"iterable与iterator","link":"#iterable与iterator","children":[]},{"level":3,"title":"foreach和Iterator的关系：","slug":"foreach和iterator的关系","link":"#foreach和iterator的关系","children":[]},{"level":3,"title":"使用for循环还是迭代器Iterator？","slug":"使用for循环还是迭代器iterator","link":"#使用for循环还是迭代器iterator","children":[]},{"level":3,"title":"Iterator、ListIterator","slug":"iterator、listiterator","link":"#iterator、listiterator","children":[]}]},{"level":2,"title":"为什么基本类型不能做为HashMap的键值？","slug":"为什么基本类型不能做为hashmap的键值","link":"#为什么基本类型不能做为hashmap的键值","children":[]},{"level":2,"title":"Array 、Arrays的关系","slug":"array-、arrays的关系","link":"#array-、arrays的关系","children":[]},{"level":2,"title":"同步容器 与 并发容器","slug":"同步容器-与-并发容器","link":"#同步容器-与-并发容器","children":[{"level":3,"title":"同步容器","slug":"同步容器","link":"#同步容器","children":[]},{"level":3,"title":"并发容器","slug":"并发容器","link":"#并发容器","children":[]}]}],"git":{"createdTime":1701499503000,"updatedTime":1701510130000,"contributors":[{"name":"honyelchak","email":"554417388@qq.com","commits":2}]},"readingTime":{"minutes":32,"words":9600},"filePathRelative":"interview/A4-Java/Java集合.md","localizedDate":"2023年12月2日","excerpt":"<h2> Java容器概述</h2>\\n<p>容器主要包括<code>Collection</code>和<code>Map</code>两种，Collection存储着对象的集合，而Map存储着键值对的映射表。</p>\\n<h2> Collection</h2>\\n<figure><figcaption>img</figcaption></figure>\\n<h3> 1. Set</h3>\\n<ul>\\n<li>\\n<p><code>TreeSet</code>：基于<mark>红黑树</mark>实现，支持<strong>有序性</strong>操作，例如根据一个范围查找元素的操作。<strong>但是查找效率不如 HashSet</strong>，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。</p>\\n<ul>\\n<li>\\n<p>注意，她是实现了<code>SortedSet</code>接口，所以有序。</p>\\n</li>\\n<li>\\n<p>**底层实现调用<code>TreeMap</code>的构造方法，**key为set中的值，Value为object对象。</p>\\n<ul>\\n<li>\\n<div class=\\"language-java line-numbers-mode\\" data-ext=\\"java\\"><pre class=\\"language-java\\"><code><span class=\\"token comment\\">// Dummy value to associate with an Object in the backing Map</span>\\n<span class=\\"token keyword\\">private</span> <span class=\\"token keyword\\">static</span> <span class=\\"token keyword\\">final</span> <span class=\\"token class-name\\">Object</span> <span class=\\"token constant\\">PRESENT</span> <span class=\\"token operator\\">=</span> <span class=\\"token keyword\\">new</span> <span class=\\"token class-name\\">Object</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div></li>\\n</ul>\\n</li>\\n<li>\\n<p>添加、删除、包含等操作时间复杂度<code>O(logN)</code></p>\\n</li>\\n</ul>\\n</li>\\n<li>\\n<p><strong>HashSet</strong>：基于<mark>哈希表</mark>实现，支持快速查找，但不支持有序性操作。<strong>并且失去了元素的插入顺序信息</strong>，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。</p>\\n<ul>\\n<li><strong>元素都存到HashMap键值对的Key上面，而Value时有一个统一的值<code>private static final Object PRESENT = new Object();</code></strong>，(定义一个虚拟的Object对象作为HashMap的value，将此对象定义为static final。)</li>\\n<li>实际底层会初始化一个空的HashMap，并使用默认初始容量为<strong>16</strong>和加载因子<strong>0.75</strong>。<code>max((old*0.75)+1),16)</code></li>\\n<li>添加、删除、查找效率都是<code>O（1）</code></li>\\n</ul>\\n</li>\\n<li>\\n<p><strong>LinkedHashSet</strong>：具有 HashSet 的查找效率，并且<strong>内部使用双向链表维护元素的插入顺序</strong>。</p>\\n<ul>\\n<li>\\n<p>继承了<code>HashSet</code>的构造方法，该方法是包访问权限，外部不能访问。</p>\\n</li>\\n<li>\\n<div class=\\"language-java line-numbers-mode\\" data-ext=\\"java\\"><pre class=\\"language-java\\"><code><span class=\\"token class-name\\">HashSet</span><span class=\\"token punctuation\\">(</span><span class=\\"token keyword\\">int</span> initialCapacity<span class=\\"token punctuation\\">,</span> <span class=\\"token keyword\\">float</span> loadFactor<span class=\\"token punctuation\\">,</span> <span class=\\"token keyword\\">boolean</span> dummy<span class=\\"token punctuation\\">)</span> <span class=\\"token punctuation\\">{</span>\\n    map <span class=\\"token operator\\">=</span> <span class=\\"token keyword\\">new</span> <span class=\\"token class-name\\">LinkedHashMap</span><span class=\\"token generics\\"><span class=\\"token punctuation\\">&lt;</span><span class=\\"token punctuation\\">&gt;</span></span><span class=\\"token punctuation\\">(</span>initialCapacity<span class=\\"token punctuation\\">,</span> loadFactor<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n<span class=\\"token punctuation\\">}</span>\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div></li>\\n<li>\\n<p><code>添加、删除、查找效率都是O（1）</code></p>\\n</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}`);export{e as data};
