const l=JSON.parse(`{"key":"v-e0b7e8ca","path":"/interview/A4-Java/JUC/%E5%B9%B6%E5%8F%91.html","title":"","lang":"zh-CN","frontmatter":{"description":"前置知识 补充JUC课程中的两个小知识 四大口诀： 在高内聚低耦合的前提下，封装思想，用线程操作资源类。 判断、干活、通知 防止虚假唤醒，wait方法要注意使用while判断 注意标志位flag，可能是volatile的 0、进程和线程的区别？ **进程：**是程序的一次执行，是系统进行资源分配和调度的独立单位，每一个进程都有它自己的内存空间和系统资源。 **线程：**在同一个进程内又可以执行多个任务，而这每一个任务我们就可以看作是一个线程。线程是CPU的执行单元，是操作系统调度的基本单位","head":[["meta",{"property":"og:url","content":"https://yuejinzhao.cn/interview/A4-Java/JUC/%E5%B9%B6%E5%8F%91.html"}],["meta",{"property":"og:site_name","content":"Honyelchak's Blog"}],["meta",{"property":"og:description","content":"前置知识 补充JUC课程中的两个小知识 四大口诀： 在高内聚低耦合的前提下，封装思想，用线程操作资源类。 判断、干活、通知 防止虚假唤醒，wait方法要注意使用while判断 注意标志位flag，可能是volatile的 0、进程和线程的区别？ **进程：**是程序的一次执行，是系统进行资源分配和调度的独立单位，每一个进程都有它自己的内存空间和系统资源。 **线程：**在同一个进程内又可以执行多个任务，而这每一个任务我们就可以看作是一个线程。线程是CPU的执行单元，是操作系统调度的基本单位"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-12-02T06:45:03.000Z"}],["meta",{"property":"article:author","content":"Honyelchak"}],["meta",{"property":"article:modified_time","content":"2023-12-02T06:45:03.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-12-02T06:45:03.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Honyelchak\\",\\"url\\":\\"https://yuejinzhao.cn\\"}]}"]]},"headers":[{"level":2,"title":"前置知识","slug":"前置知识","link":"#前置知识","children":[{"level":3,"title":"0、进程和线程的区别？","slug":"_0、进程和线程的区别","link":"#_0、进程和线程的区别","children":[]},{"level":3,"title":"1、什么是上下文切换？","slug":"_1、什么是上下文切换","link":"#_1、什么是上下文切换","children":[]},{"level":3,"title":"2、并发编程的目的与挑战","slug":"_2、并发编程的目的与挑战","link":"#_2、并发编程的目的与挑战","children":[]},{"level":3,"title":"3、线程太多的话，并发执行的速度会比串行慢","slug":"_3、线程太多的话-并发执行的速度会比串行慢","link":"#_3、线程太多的话-并发执行的速度会比串行慢","children":[]},{"level":3,"title":"4、为什么多线程这么重要？","slug":"_4、为什么多线程这么重要","link":"#_4、为什么多线程这么重要","children":[]},{"level":3,"title":"5、并行与并发的区别","slug":"_5、并行与并发的区别","link":"#_5、并行与并发的区别","children":[]}]},{"level":2,"title":"一、使用线程","slug":"一、使用线程","link":"#一、使用线程","children":[{"level":3,"title":"实现 Runnable 接口","slug":"实现-runnable-接口","link":"#实现-runnable-接口","children":[]},{"level":3,"title":"实现 Callable 接口","slug":"实现-callable-接口","link":"#实现-callable-接口","children":[]},{"level":3,"title":"继承 Thread 类","slug":"继承-thread-类","link":"#继承-thread-类","children":[]},{"level":3,"title":"其他","slug":"其他","link":"#其他","children":[]}]},{"level":2,"title":"二、基础线程机制","slug":"二、基础线程机制","link":"#二、基础线程机制","children":[{"level":3,"title":"Executor(亦可哉剋它)","slug":"executor-亦可哉剋它","link":"#executor-亦可哉剋它","children":[]},{"level":3,"title":"Daemon(滴门)","slug":"daemon-滴门","link":"#daemon-滴门","children":[]},{"level":3,"title":"sleep()","slug":"sleep","link":"#sleep","children":[]},{"level":3,"title":"yield()","slug":"yield","link":"#yield","children":[]}]},{"level":2,"title":"三、中断","slug":"三、中断","link":"#三、中断","children":[{"level":3,"title":"什么是中断","slug":"什么是中断","link":"#什么是中断","children":[]},{"level":3,"title":"中断相关API","slug":"中断相关api","link":"#中断相关api","children":[]},{"level":3,"title":"如何停止一个线程？","slug":"如何停止一个线程","link":"#如何停止一个线程","children":[]},{"level":3,"title":"InterruptedException","slug":"interruptedexception","link":"#interruptedexception","children":[]},{"level":3,"title":"interrupted()","slug":"interrupted","link":"#interrupted","children":[]},{"level":3,"title":"Executor 的中断操作","slug":"executor-的中断操作","link":"#executor-的中断操作","children":[]}]},{"level":2,"title":"四、互斥同步","slug":"四、互斥同步","link":"#四、互斥同步","children":[{"level":3,"title":"管程","slug":"管程","link":"#管程","children":[]},{"level":3,"title":"synchronized","slug":"synchronized","link":"#synchronized","children":[]},{"level":3,"title":"ReentrantLock","slug":"reentrantlock","link":"#reentrantlock","children":[]},{"level":3,"title":"Synchronzied 和Lock有什么区别？","slug":"synchronzied-和lock有什么区别","link":"#synchronzied-和lock有什么区别","children":[]}]},{"level":2,"title":"五、线程之间的协作","slug":"五、线程之间的协作","link":"#五、线程之间的协作","children":[{"level":3,"title":"join()","slug":"join","link":"#join","children":[]},{"level":3,"title":"wait() notify() notifyAll()","slug":"wait-notify-notifyall","link":"#wait-notify-notifyall","children":[]},{"level":3,"title":"await()、signal()、signalAll()","slug":"await-、signal-、signalall","link":"#await-、signal-、signalall","children":[]}]},{"level":2,"title":"六、线程状态","slug":"六、线程状态","link":"#六、线程状态","children":[{"level":3,"title":"新建（NEW）","slug":"新建-new","link":"#新建-new","children":[]},{"level":3,"title":"可运行（RUNABLE）","slug":"可运行-runable","link":"#可运行-runable","children":[]},{"level":3,"title":"阻塞（BLOCKED）","slug":"阻塞-blocked","link":"#阻塞-blocked","children":[]},{"level":3,"title":"无限期等待（WAITING）","slug":"无限期等待-waiting","link":"#无限期等待-waiting","children":[]},{"level":3,"title":"限期等待（TIMED_WAITING）","slug":"限期等待-timed-waiting","link":"#限期等待-timed-waiting","children":[]},{"level":3,"title":"死亡（TERMINATED）","slug":"死亡-terminated","link":"#死亡-terminated","children":[]}]},{"level":2,"title":"七、J.U.C - AQS","slug":"七、j-u-c-aqs","link":"#七、j-u-c-aqs","children":[{"level":3,"title":"前置知识-CAS","slug":"前置知识-cas","link":"#前置知识-cas","children":[]},{"level":3,"title":"原子类","slug":"原子类","link":"#原子类","children":[]},{"level":3,"title":"AQS详情","slug":"aqs详情","link":"#aqs详情","children":[]},{"level":3,"title":"ReentrantLock的原理","slug":"reentrantlock的原理","link":"#reentrantlock的原理","children":[]},{"level":3,"title":"ReentrantReadWriteLock","slug":"reentrantreadwritelock","link":"#reentrantreadwritelock","children":[]},{"level":3,"title":"CountDownLatch","slug":"countdownlatch","link":"#countdownlatch","children":[]},{"level":3,"title":"CyclicBarrier","slug":"cyclicbarrier","link":"#cyclicbarrier","children":[]},{"level":3,"title":"Semaphore","slug":"semaphore","link":"#semaphore","children":[]}]},{"level":2,"title":"八、J.U.C - 其它组件","slug":"八、j-u-c-其它组件","link":"#八、j-u-c-其它组件","children":[{"level":3,"title":"FutureTask","slug":"futuretask","link":"#futuretask","children":[]},{"level":3,"title":"CompletableFuture(并发编程的高级工具)","slug":"completablefuture-并发编程的高级工具","link":"#completablefuture-并发编程的高级工具","children":[]},{"level":3,"title":"BlockingQueue","slug":"blockingqueue","link":"#blockingqueue","children":[]},{"level":3,"title":"ForkJoin","slug":"forkjoin","link":"#forkjoin","children":[]}]},{"level":2,"title":"九、线程不安全示例","slug":"九、线程不安全示例","link":"#九、线程不安全示例","children":[]},{"level":2,"title":"十、JMM(规范)","slug":"十、jmm-规范","link":"#十、jmm-规范","children":[{"level":3,"title":"主内存与工作内存","slug":"主内存与工作内存","link":"#主内存与工作内存","children":[]},{"level":3,"title":"内存间交互操作","slug":"内存间交互操作","link":"#内存间交互操作","children":[]},{"level":3,"title":"内存模型三大特性","slug":"内存模型三大特性","link":"#内存模型三大特性","children":[]},{"level":3,"title":"先行发生原则(happens-before)","slug":"先行发生原则-happens-before","link":"#先行发生原则-happens-before","children":[]},{"level":3,"title":"volatile","slug":"volatile","link":"#volatile","children":[]}]},{"level":2,"title":"十一、线程安全","slug":"十一、线程安全","link":"#十一、线程安全","children":[{"level":3,"title":"不可变","slug":"不可变","link":"#不可变","children":[]},{"level":3,"title":"互斥同步","slug":"互斥同步","link":"#互斥同步","children":[]},{"level":3,"title":"非阻塞同步","slug":"非阻塞同步","link":"#非阻塞同步","children":[]},{"level":3,"title":"无锁同步方案","slug":"无锁同步方案","link":"#无锁同步方案","children":[]}]},{"level":2,"title":"十二、锁","slug":"十二、锁","link":"#十二、锁","children":[{"level":3,"title":"乐观锁和悲观锁","slug":"乐观锁和悲观锁","link":"#乐观锁和悲观锁","children":[]},{"level":3,"title":"公平和非公平锁","slug":"公平和非公平锁","link":"#公平和非公平锁","children":[]},{"level":3,"title":"可重入锁(又名递归锁)","slug":"可重入锁-又名递归锁","link":"#可重入锁-又名递归锁","children":[]},{"level":3,"title":"独占锁(写锁)/共享锁(读锁)/","slug":"独占锁-写锁-共享锁-读锁","link":"#独占锁-写锁-共享锁-读锁","children":[]},{"level":3,"title":"多线程Synchronized锁的升级原理是什么？","slug":"多线程synchronized锁的升级原理是什么","link":"#多线程synchronized锁的升级原理是什么","children":[]}]},{"level":2,"title":"十二、锁优化","slug":"十二、锁优化","link":"#十二、锁优化","children":[{"level":3,"title":"自旋锁","slug":"自旋锁","link":"#自旋锁","children":[]},{"level":3,"title":"锁消除","slug":"锁消除","link":"#锁消除","children":[]},{"level":3,"title":"锁粗化","slug":"锁粗化","link":"#锁粗化","children":[]},{"level":3,"title":"轻量级锁","slug":"轻量级锁-1","link":"#轻量级锁-1","children":[]},{"level":3,"title":"偏向锁","slug":"偏向锁-1","link":"#偏向锁-1","children":[]}]},{"level":2,"title":"十三、多线程开发良好的实践","slug":"十三、多线程开发良好的实践","link":"#十三、多线程开发良好的实践","children":[]},{"level":2,"title":"十四、synchronized锁定的到底是什么？","slug":"十四、synchronized锁定的到底是什么","link":"#十四、synchronized锁定的到底是什么","children":[]},{"level":2,"title":"十六、线程中断机制","slug":"十六、线程中断机制","link":"#十六、线程中断机制","children":[{"level":3,"title":"中断","slug":"中断","link":"#中断","children":[]},{"level":3,"title":"LockSupport","slug":"locksupport","link":"#locksupport","children":[]}]},{"level":2,"title":"十七、线程池相关知识","slug":"十七、线程池相关知识","link":"#十七、线程池相关知识","children":[{"level":3,"title":"池化技术作用","slug":"池化技术作用","link":"#池化技术作用","children":[]},{"level":3,"title":"线程池有哪些？","slug":"线程池有哪些","link":"#线程池有哪些","children":[]},{"level":3,"title":"线程池的几个重要参数","slug":"线程池的几个重要参数","link":"#线程池的几个重要参数","children":[]},{"level":3,"title":"底层工作原理","slug":"底层工作原理","link":"#底层工作原理","children":[]},{"level":3,"title":"拒绝策略(策略设计模式)","slug":"拒绝策略-策略设计模式","link":"#拒绝策略-策略设计模式","children":[]},{"level":3,"title":"如何合理的配置线程池","slug":"如何合理的配置线程池","link":"#如何合理的配置线程池","children":[]},{"level":3,"title":"核心源码","slug":"核心源码","link":"#核心源码","children":[]},{"level":3,"title":"相关面试题","slug":"相关面试题","link":"#相关面试题","children":[]}]},{"level":2,"title":"十八、高性能队列Diruptor","slug":"十八、高性能队列diruptor","link":"#十八、高性能队列diruptor","children":[]},{"level":2,"title":"补充","slug":"补充","link":"#补充","children":[]}],"git":{"createdTime":1701499503000,"updatedTime":1701499503000,"contributors":[{"name":"honyelchak","email":"554417388@qq.com","commits":1}]},"readingTime":{"minutes":146.79,"words":44038},"filePathRelative":"interview/A4-Java/JUC/并发.md","localizedDate":"2023年12月2日","excerpt":"<h2> 前置知识</h2>\\n<p>补充JUC课程中的两个小知识</p>\\n<blockquote>\\n<p>四大口诀：</p>\\n<ol>\\n<li>在高内聚低耦合的前提下，封装思想，用线程操作资源类。</li>\\n<li>判断、干活、通知</li>\\n<li>防止虚假唤醒，wait方法要注意使用while判断</li>\\n<li>注意标志位flag，可能是volatile的</li>\\n</ol>\\n</blockquote>\\n<h3> 0、进程和线程的区别？</h3>\\n<ul>\\n<li>**进程：**是程序的一次执行，是系统进行资源分配和调度的独立单位，每一个进程都有它自己的内存空间和系统资源。</li>\\n<li>**线程：**在同一个进程内又可以执行多个任务，而这每一个任务我们就可以看作是一个线程。线程是CPU的执行单元，是操作系统调度的基本单位</li>\\n</ul>","autoDesc":true}`);export{l as data};
