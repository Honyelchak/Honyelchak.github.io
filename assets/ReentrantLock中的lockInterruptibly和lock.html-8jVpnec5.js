const e=JSON.parse(`{"key":"v-047e5374","path":"/interview/A4-Java/JUC/ReentrantLock%E4%B8%AD%E7%9A%84lockInterruptibly%E5%92%8Clock.html","title":"ReentrantLock中的lockInterruptibly、lock、tryLock","lang":"zh-CN","frontmatter":{"description":"ReentrantLock中的lockInterruptibly、lock、tryLock 这篇文章的思路： 首先尝试着阅读Java文档(双语对照) 了解几个关键类之间的关系 通过源代码来了解lock和lockInterruptibly的流程 最后总结两者的区别 Java文档(双语) lock Acquires the lock unless the current thread is interrupted. 获得锁，除非当前线程被中断。 Acquires the lock if it is not held by another thread and returns immediately, setting the lock hold count to one. 如果锁未被另一个线程持有，则获取该锁并立即返回，将锁持有计数设置为1。 If the current thread already holds this lock then the hold count is incremented by one and the method returns immediately. 如果当前线程已经持有此锁，则保持计数将增加1，并且方法将立即返回。 If the lock is held by another thread then the current thread becomes disabled for thread scheduling purposes and lies dormant until the lock has been acquired, at which time the lock hold count is set to one. 如果锁被另一个线程持有，则当前线程将因线程调度而禁用，并处于休眠状态，直到获得锁为止，此时锁持有计数设置为1。","head":[["meta",{"property":"og:url","content":"https://yuejinzhao.cn/interview/A4-Java/JUC/ReentrantLock%E4%B8%AD%E7%9A%84lockInterruptibly%E5%92%8Clock.html"}],["meta",{"property":"og:site_name","content":"Honyelchak's Blog"}],["meta",{"property":"og:title","content":"ReentrantLock中的lockInterruptibly、lock、tryLock"}],["meta",{"property":"og:description","content":"ReentrantLock中的lockInterruptibly、lock、tryLock 这篇文章的思路： 首先尝试着阅读Java文档(双语对照) 了解几个关键类之间的关系 通过源代码来了解lock和lockInterruptibly的流程 最后总结两者的区别 Java文档(双语) lock Acquires the lock unless the current thread is interrupted. 获得锁，除非当前线程被中断。 Acquires the lock if it is not held by another thread and returns immediately, setting the lock hold count to one. 如果锁未被另一个线程持有，则获取该锁并立即返回，将锁持有计数设置为1。 If the current thread already holds this lock then the hold count is incremented by one and the method returns immediately. 如果当前线程已经持有此锁，则保持计数将增加1，并且方法将立即返回。 If the lock is held by another thread then the current thread becomes disabled for thread scheduling purposes and lies dormant until the lock has been acquired, at which time the lock hold count is set to one. 如果锁被另一个线程持有，则当前线程将因线程调度而禁用，并处于休眠状态，直到获得锁为止，此时锁持有计数设置为1。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-12-02T09:42:10.000Z"}],["meta",{"property":"article:author","content":"Honyelchak"}],["meta",{"property":"article:modified_time","content":"2023-12-02T09:42:10.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"ReentrantLock中的lockInterruptibly、lock、tryLock\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-12-02T09:42:10.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Honyelchak\\",\\"url\\":\\"https://yuejinzhao.cn\\"}]}"]]},"headers":[{"level":2,"title":"Java文档(双语)","slug":"java文档-双语","link":"#java文档-双语","children":[{"level":3,"title":"lock","slug":"lock","link":"#lock","children":[]},{"level":3,"title":"lockInterruptibly","slug":"lockinterruptibly","link":"#lockinterruptibly","children":[]},{"level":3,"title":"tryLock","slug":"trylock","link":"#trylock","children":[]}]},{"level":2,"title":"核心类之间的关系","slug":"核心类之间的关系","link":"#核心类之间的关系","children":[]},{"level":2,"title":"阅读源码","slug":"阅读源码","link":"#阅读源码","children":[{"level":3,"title":"Lock","slug":"lock-1","link":"#lock-1","children":[]},{"level":3,"title":"lockInterruptibly","slug":"lockinterruptibly-1","link":"#lockinterruptibly-1","children":[]},{"level":3,"title":"tryLock","slug":"trylock-1","link":"#trylock-1","children":[]}]},{"level":2,"title":"三者的区别","slug":"三者的区别","link":"#三者的区别","children":[]}],"git":{"createdTime":1701499503000,"updatedTime":1701510130000,"contributors":[{"name":"honyelchak","email":"554417388@qq.com","commits":2}]},"readingTime":{"minutes":10.26,"words":3079},"filePathRelative":"interview/A4-Java/JUC/ReentrantLock中的lockInterruptibly和lock.md","localizedDate":"2023年12月2日","excerpt":"<h1> ReentrantLock中的lockInterruptibly、lock、tryLock</h1>\\n<p>这篇文章的思路：</p>\\n<ul>\\n<li>首先尝试着阅读Java文档(双语对照)</li>\\n<li>了解几个关键类之间的关系</li>\\n<li>通过源代码来了解lock和lockInterruptibly的流程</li>\\n<li>最后总结两者的区别</li>\\n</ul>\\n<h2> Java文档(双语)</h2>\\n<h3> lock</h3>\\n<blockquote>\\n<ol>\\n<li>\\n<p>Acquires the lock unless the current thread is interrupted.</p>\\n<p><strong>获得锁，除非当前线程被中断。</strong></p>\\n</li>\\n<li>\\n<p>Acquires the lock if it is not held by another thread and returns immediately, setting the lock hold count to one.</p>\\n<p><strong>如果锁未被另一个线程持有，则获取该锁并立即返回，将锁持有计数设置为1。</strong></p>\\n</li>\\n<li>\\n<p>If the current thread already holds this lock then the hold count is incremented by one and the method returns immediately.</p>\\n<p><strong>如果当前线程已经持有此锁，则保持计数将增加1，并且方法将立即返回。</strong></p>\\n</li>\\n<li>\\n<p>If the lock is held by another thread then the current thread becomes disabled for thread scheduling purposes and lies dormant until the lock has been acquired, at which time the lock hold count is set to one.</p>\\n<p><strong>如果锁被另一个线程持有，则当前线程将因线程调度而禁用，并处于休眠状态，<mark>直到获得锁为止，此时锁持有计数设置为1</mark>。</strong></p>\\n</li>\\n</ol>\\n</blockquote>","autoDesc":true}`);export{e as data};
