import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o,c as i,f as l}from"./app-XffPLay1.js";const t={},c=l('<h2 id="udt" tabindex="-1"><a class="header-anchor" href="#udt" aria-hidden="true">#</a> UDT</h2><p>基于 UDP 的数据传输协议（UDP-based Data Transfer Protocol，简称 UDT） 是一种互联网数据传输协议。</p><p>UDT 的主要目的是支持高速广域网上的海量数据传输，最典型的例子就是建立在光纤广域网上的网格计算，一些研究所在这样的网络上运行他们的分布式的数据密集程式，例如，远程访问仪器、分布式数据挖掘 和高分辨率的多媒体流。</p><p>而互联网上的标准数据传输协议 TCP 在高带宽长距离网络上性能很差。 顾名思义，UDT 建于 UDP 之上，并引入新的拥塞控制和数据可靠性控制机制。</p><p>UDT 是<code>面向连接的双向</code>的<code>应用层</code>协议。</p><p>UDT 的特性主要包括在以下几个方面：</p><ol><li>基于 UDP 的应用层协议：有基本网络知识的朋友都知道 TCP 和 UDP 的区别和使用场景，但是有没有一种协议能同时<code>兼顾 TCP 协议的安全可靠和 UDP 协议的高效</code>，那么 UDT 就是一种。</li><li>面向连接的协议：<code>面向连接意味着两个使用协议的应用在彼此交换数据之前必须先建立一个连接</code>，当然 UDT 是逻辑上存在的连接通道。这种连接的维护是基于握手、Keep-alive（保活）以及关闭连接。</li><li>可靠的协议：<code>依靠包序号机制、接收者的 ACK 响应和丢包报告、ACK 序号机制、重传机制(基于丢包报告和超时处理)</code>来实现数据传输的可靠性。</li><li>双工的协议：每个 UDT 实例<code>包含发送端和接收端的信息</code>。</li><li>新的拥塞算法，并且具有可扩展的拥塞控制框架：新的拥塞控制算法不同于基于窗口的 TCP 拥塞控制算法(慢启动和拥塞避免)，是<code>混合的基于窗口的、基于 速率的拥塞控制算法</code>。可扩展的拥塞控制框架开源的代码和拥塞控制的 C++类架构，可支持开发者派生专用的拥塞控制算法。</li><li>带宽估计：UDT 使用对包(PP -- Packet pair)的机制来估计带宽值。即每 16 个 包为一组,最后一个是对包,即发送方不用等到下一个发送周期内再发送。接收方 接收到对包后对其到达时间进行记录,可结合上次记录的值计算出链路的带宽(计 算的方法称为中值过滤法), 并在下次 ACK 中进行反馈。</li></ol><h2 id="quic" tabindex="-1"><a class="header-anchor" href="#quic" aria-hidden="true">#</a> QUIC</h2><p>QUIC 代表”快速 UDP Internet 连接（<strong>Quick UDP Internet Connection</strong>）”，</p><p>基于 UDP 的传输层协议，它本身就是 Google 尝试将 TCP 协议重写为一种结合了 HTTP/2、TCP、UDP 和 TLS（用于加密）等多种技术的改进技术。</p><p>谷歌希望 <code>QUIC 通信技术逐渐取代 TCP 和 UDP</code>，作为在 Internet 上移动二进制数据的新选择协议。</p><p>QUIC 协议的主要目的，是为了整合 <code>TCP 协议的可靠性 和 UDP 协议的速度和效率</code>。</p><ol><li>由于TCP是在操作系统内核和中间件固件中实现的，因此对 TCP 进行重大更改几乎是不可能的（TCP 协议栈通常由操作系统实现，如 Linux、Windows 内 核或者其他移动设备操作系统。修改 TCP 协议是一项浩大的工程，因为每种设备、系统的实现都需要更新）。但是，由于 QUIC 建立在 UDP 之上，因此没有这种限制。</li><li>QUIC 的优势在于： <ol><li>采用<strong>多路复用</strong>思想，一个连接可以同时承载多个流 ( stream )，同时发起多个请求。 请求间完全独立 ，某个请求阻塞甚至报文出错均不影响其他请 求。</li><li>QUIC 只需要 1RTT（Round-Trip Time）的延迟就可以建立可靠安全的连接, 相对于 TCP+TLS 的 3 次 RTT 要更加快捷。之后客户端可以在本地缓存加密的认证信息，再次与服务器建立连接时可以实现 0-RTT 的连接建立延迟。</li><li>为了实现可靠传输，需要对传输信道的差错进行处理。处理方式一般有两种：ARQ（Automatic Repeat-reQuest），由接收方对接收到的数据包进行确认，发送回执，以指示错误和请求重传出错的报文；另一种是FEC，将在本文后面讲到。QUIC的ARQ是在TCP的基础上做了一些改进，一方面ACK报文会携带数据包的<code>接收时间和ACK的时间，以方便计算RTT</code>，另一方面QUIC的ACK是基于包的序号，并支持更多的ACK块，在乱序发送方面比TCP更灵活。</li><li>~~(已被删除)~~TCP 采用 <code>重传</code> 机制，而 QUIC 采用 <strong><code>纠错</code></strong> 机制。 <ol><li>TCP 发生丢包时，需要一个等待延时判断发生了丢包，然后再启动重传机制， 这个过程会造成一定的阻塞，影响传输时间。</li><li>而 QUIC 则采用一种更主动的方案，有点类似 RAID5 ，每 n 个包额外发一个校验和包 。 如果这 n 个包中丢了一个包，可以通过其他包和校验和恢复出来，完全不需要重传。</li></ol></li><li>QUIC 直接<strong>基于客户端(应用进程)实现</strong>，而非基于内核，可以快速迭代更新，不需要操作系统层面的改造，部署灵活。</li><li><strong>链接迁移</strong>：连接保持 QUIC 在客户端保存连接标识，当客户端 IP 或者端口发生变化时，可以快速恢复连接 —— 客户端以标识请求服务端，服务端验证标识后感知客户端新地址端口并重新关联，继续通讯。 这对于改善移动端应用连接体验意义重大(从 WiFi 切换到流量)。当客户端IP或端口发生变化时（这在移动端比较常见），TCP连接基于两端的ip:port四元组标示，因此会重新握手，而UDP不面向连接，不用握手。其上层的QUIC链路由于使用了64位Connection id作为唯一标识，四元组变化不影响链路的标示，也不用重新握手。因此网络链接状态变化时不会增加额外的握手重连耗时。</li></ol></li></ol>',13),d=[c];function n(r,C){return o(),i("div",null,d)}const P=e(t,[["render",n],["__file","UDT和QUIC.html.vue"]]);export{P as default};
