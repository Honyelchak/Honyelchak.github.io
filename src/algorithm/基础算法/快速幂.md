# 快速幂



求 `m^k%p`，时间复杂度 `O(logk)`

```c++
int qmi(int m, int k, int p)
{
    int res = 1 % p, t = m;
    while (k)
    {
        if (k&1) res = res * t % p;
        t = t * t % p;
        k >>= 1;
    }
    return res;
}
```





#### 矩阵快速幂

关于快速幂这一块还是需要做一个总结，写一篇博客捋捋思路，加深理解。



##### 为什么要用快速幂？

例如：现在有一个题目让你求 $a^{b}$ ,你可能觉得很简单啊，来一个`for`循环，循环`b-1`次就行了。但是如果b非常大的情况下，那这个做法是非常低效的，时间复杂度大致为 `O(b)`。

当用快速幂之后，时间复杂度为`O(logn)`。

##### 快速幂例子

例如我们用快速幂求 $2^{11}$ 。

将指数拆分能够得到如下的结果。
$$
2^{11} = 2^{2^{0}+2^{1}+2^{3}}
$$
学过进制转换看到11拆开的样子肯定会很眼熟，其实这里就是跟二进制有关。



11的二进制为`1011` , $11=2^{3}*1+2^{2}*0+2^{1}*1+2^{0}*1$

这样一来，我们求$2^{11}$就不需要算10次了，现在三次就够了。
$$
2^{11} = 2^{2^0} * 2^{2^{1}} * 2^{2^{3}}
$$
到这里以后，我们可能会觉得后边的这三项似乎不好求。

不着急，我们先上代码。



```c++
int poww(int a,int b){
    int ans=1,base=a;
    while(b!=0){
        if(b&1!=0)
        　　ans*=base;
        base*=base;
        b>>=1;
　 }
    return ans;
}
```



代码短小精悍，但是，我还是不太建议刻意去记它，容易忘。理解之后，自然就记住了。



我们将$2^{11}$ 带入代码走一遍或许你就能够理解了。

其实程序就是自左到右求那三项的值。

$2^{11} = 2^{2^0} * 2^{2^{1}} * 2^{2^{3}}$

上边我们已经知道11的二进制为`1011`

程序参数`a = 2,b =11`

`ans =1,base = 2`

到第四行代码处，11最后一位明显是1，那么我们就需要与结果变量`res`相乘。

其实，这里的相乘的就是$2^{2^{0}}  $ ，乘完之后`res = 2`.

到第六行代码处，base自乘。这一步我给大家详细解释一下：

base*base = $base^2$ ,$base^2 * base^2 = base^4$ , $base^4 * base^4 = base^{8}$ ,$base^{8} * base^{8} = base^{16}$

有没有发现一个问题，每次自乘的结果如下：

$base^2 、base^4、base^8、base^{16}、base^{32}$

我们换种写法你会更明白：

$base^{2^{1}} 、 base^{2^{2}}、base^{2^{3}} 、base^{2^{4}} 、base^{2^{5}} $

你会发现和上边我们要求的一样。

$2^{11} = 2^{2^0} * 2^{2^{1}} * 2^{2^{3}}$

无非是`base = 2`。

`b >>= 1`右移一位，他的作用是将`1011`变成`101`-->`10`-->`1`

当`b`的最后一位为0时，不乘base，为1的时候成base。

$2^{11} = 2^{2^0} * 2^{2^{1}} * 2^{2^{3}}$

这样我们能够让`res`乘上上边的三项，而不乘上`2^{2^2}`。

其实就是根据b的二进制来判断是否乘上二的阶乘。

如果b最后一位为`1`，也就是说$2^{x}$对b有贡献，所以我们结果乘上base。

否则，我们结果不需要乘base，但是base需要自乘，因为二进制位中左边的权重更大一些。



 矩阵快速幂，他的思想和快速幂的思想是一样的。无非就是 底数变为矩阵了。所以你只需定义一下矩阵的乘法即可。



#### 矩阵快速幂

```c++
Matrix mul(Matrix A,Matrix B){
    Matrix res;
    
    for(int i=0;i<maxn;i++){
        for(int j=0;j<maxn;j++){
            for(int k=0;k<maxn;k++){
            	res.a[i][j] += A.a[i][k]*B.a[k][j];     
            }
        }
    }
    return res;
}
```



如果说需要递推很多次就要去考虑是否要用矩阵快速幂  









