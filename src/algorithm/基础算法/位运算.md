# 位运算总结

## 经典理论

### 异或

异或，可以理解为==不进位加法==（相同则0，不同则1）

```c++
x^x = 0;
x^0 = x;
```

1. 交换律：a ^ b ^ c <=> a ^ c ^ b

2. 任何数于0异或为任何数 0 ^ n => n

3. 相同的数异或为0: n ^ n => 0

   > 自反性：连续和同一个因子做异或运算，最终结果为自己。

---

### 位运算符

**>>>表示无符号右移，也叫==逻辑右移==，即若该数为正，则高位补0，而若该数为负数，则右移后高位同样补0**

**>>表示右移，如果该数为正，则高位补0，若为负数，则高位补1**

**<<表示左移移，不分正负数，低位补0；**　



---

## 一、位运算的奇巧淫记

#### 1、判断奇偶数 | **获取二进制位是1还是0**

```c++
x&1
//为1就是奇数，为0就是偶数
```

#### 交换两个整数变量的值



#### 不用判断语句，求整数的绝对值



-----

#### 去掉最右边的一个1

```cpp
x & (x - 1)
```



#### 求一个数最低位为1的值

```cpp
x & (~x + 1)
```





#### 求一个数的二进制数中1的个数(三种解法)

```c++
//第一种
//while(n){
//		if(n&1){
//			sum++;
//		}
//		n >>= 1;
//	}
//第二种
	for (int i = 0; i < 32; i++) {
		if((n&(1<<i))==(1<<i)){
			sum++;
		}
	}
//第三种
while(n){
		n = (n-1)&n;//得出2^q(q为从右到左第一个1的位置)
		sum++;
	}
```

#### 判断是否为2的幂

**核心**：该数二进制只有一个`1`.

多种方法；

- `return (n>0) && (1<<30) % n == 0;`

- `return (n > 0) && (n & -n) == n;`

- 

  ```c++
  if(0 == (n-1)&n){
      //...Yes;
  } else {	
      //...No;
  }
  ```

- ```c++
  // 从低到高找到第一个1的位置，然后看结果是否为0
  if (n <= 0)return false;
  while(n != 0){
      if ((n & 1 )== 1) {
          n = n >> 1;
          break;
      }
      n = n >> 1;
  }
  if (n == 0)return true;
  return false;
  ```

> **引申：**判断一个数是否为4的整数次方？
>
> **思路一：**
>
> 先判断是否为2的次幂，然后判断二进制中1是否在偶数位上。
>
> 参考代码：
>
> ```c++
> if (((n & -n) == n) && ((n & 0x55555555) == n)) return true; 
> ```



#### 交换奇偶位

```c++
int ou = n&0xaaaaaaaa;
int ji = n&0x55555555;
printf("%d\n",(ou>>1)^(ji<<1));
```

#### 出现k次与出现一次

- 位运算
  - 2个相同的2进制数做不进位加法，结果为0。
  - 10个相同的10进制做不进位加法，结果为0。
  - k个相同的k进制做不进位加法，结果为0。
- 哈希表



#### 字母大小写转换

```java
统一转成大写：ch & 0b11011111 简写：ch & 0xDF
统一转成小写：ch | 0b00100000 简写：ch | 0x20
    
```



```java

if((s.charAt(i ++) & 0xDF) != (s.charAt(j --) & 0xDF)) return false; 
```

**Ps:**比较的时候注意加上小括号哦，因为位运算优先级比较低。

#### 比较两个整数的符号是否相反

```c
int x,y;
bool f = ((x ^ y) < 0) // 异号
```

​	





------

### 题目



#### 1、不得使用+、-、*、/四则运算符号，求两整数之和

- `p&q`两数相与，并左移一位，求进位。
- `p^q`不进位相加。
- ==负数同样适用==(处理负数时，需要将int 换成unsigned int)

```java
public int Add(int p,int q) {
        int t;
		while((p&q) != 0) {
			t = (p&q) << 1;
			p = p^q;
			q = t;
		}
		return p^q;
}
```



```java
010001
011001
相加等于=
101010 

//利用位运算
& 之后<< =
100010//1
^ =
001000//2
// 1 + 2相加
100010
001000
=
101010
    
//不具有普适性，需注意1、2相加存在有进位的情况
```



#### 2、[ 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)

```html
给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

示例 1:

输入: [2,2,1]
输出: 1
示例 2:

输入: [4,1,2,1,2]
输出: 4

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/single-number
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```



```java
public int singleNumber(int[] nums) {
        nums[0] = nums[0]^0;
		for(int i=1; i < nums.length; i++){
			nums[0] ^= nums[i];
		}
		return nums[0];
    }
```



#### 3、汉明距离(异或+求1的个数)

##### 法一：

```java
public int hammingDistance(int x, int y) {
    x = x^y;y = 0;
    // 求二进制中1的个数
    while(x != 0){
    if((x&1) == 1)y++;
    x = x >> 1;
    }
    return y;
}
```



##### 法二：

```java
public int hammingDistance(int x, int y) {
    return Integer.bitCount(x^y);
}
public static int bitCount(int i) {
    // HD, Figure 5-2
    // 0x55555555   01010101010101010101010101010101(16对01)
    // 保留奇数位，去除偶数位
    i = i - ((i >>> 1) & 0x55555555);
    // 0x33333333   00110011001100110011001100110011
    i = (i & 0x33333333) + ((i >>> 2) & 0x33333333);
    i = (i + (i >>> 4)) & 0x0f0f0f0f;
    i = i + (i >>> 8);
    i = i + (i >>> 16);
    return i & 0x3f;
}
```

> 注意此处的bitCount方法



#### 4、[数字转换为十六进制数](https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/)

```cpp
class Solution {
public:
    string toHex(int num) {
        if (num == 0) return "0";
        string s = "", hex = "0123456789abcdef";
        int cnt = 0;
        // 位移运算并不能保证num==0，需要使用32位int保证（对应16进制小于等于8位）。
        while(num && s.size() < 8)
        {
            // 使用0xf(00...01111b)获取num的低4位。
            s = hex[num & 0xf] + s;
            // >>算数位移，其中正数右移左边补0，负数右移左边补1。
            num >>= 4;
        }
        return s;
    }
};
```

